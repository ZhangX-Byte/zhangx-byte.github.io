{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/img/icon_wechat.png","path":"img/icon_wechat.png","modified":1,"renderable":0},{"_id":"source/img/about/about-bg.jpg","path":"img/about/about-bg.jpg","modified":1,"renderable":0},{"_id":"source/img/avatar/head.jpg","path":"img/avatar/head.jpg","modified":1,"renderable":0},{"_id":"source/img/avatar/home-bg.jpg","path":"img/avatar/home-bg.jpg","modified":1,"renderable":0},{"_id":"source/img/dapr/dapr.svg","path":"img/dapr/dapr.svg","modified":1,"renderable":0},{"_id":"source/img/dapr/overview-sidecar-kubernetes.png","path":"img/dapr/overview-sidecar-kubernetes.png","modified":1,"renderable":0},{"_id":"source/img/dapr/overview-sidecar.png","path":"img/dapr/overview-sidecar.png","modified":1,"renderable":0},{"_id":"source/img/dapr/service-invocation.png","path":"img/dapr/service-invocation.png","modified":1,"renderable":0},{"_id":"source/img/golang/golang.jpeg","path":"img/golang/golang.jpeg","modified":1,"renderable":0},{"_id":"themes/huweihuang/source/css/archive.styl","path":"css/archive.styl","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/beantech.min.css","path":"css/beantech.min.css","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/beantech.css","path":"css/beantech.css","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/donate.css","path":"css/donate.css","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/rocket.styl","path":"css/rocket.styl","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/signature.styl","path":"css/signature.styl","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/toc.styl","path":"css/toc.styl","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/widget.styl","path":"css/widget.styl","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/hux-blog.js","path":"js/hux-blog.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":1,"renderable":1},{"_id":"source/img/dapr/overview.png","path":"img/dapr/overview.png","modified":1,"renderable":0},{"_id":"source/img/dapr/overview_kubernetes.png","path":"img/dapr/overview_kubernetes.png","modified":1,"renderable":0},{"_id":"source/img/dapr/overview_standalone.png","path":"img/dapr/overview_standalone.png","modified":1,"renderable":0},{"_id":"source/img/golang/1.png","path":"img/golang/1.png","modified":1,"renderable":0},{"_id":"source/img/java/java.jpeg","path":"img/java/java.jpeg","modified":1,"renderable":0},{"_id":"source/img/java/retries.png","path":"img/java/retries.png","modified":1,"renderable":0},{"_id":"themes/huweihuang/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/toc.js","path":"js/toc.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/bootstrap.js","path":"js/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"source/img/signature/BeanTechSign-white.png","path":"img/signature/BeanTechSign-white.png","modified":1,"renderable":0},{"_id":"source/img/golang/java-http-structure.png","path":"img/golang/java-http-structure.png","modified":1,"renderable":0},{"_id":"source/img/java/2.png","path":"img/java/2.png","modified":1,"renderable":0},{"_id":"source/img/java/java-http-structure.png","path":"img/java/java-http-structure.png","modified":1,"renderable":0},{"_id":"themes/huweihuang/source/css/images/ironman.png","path":"css/images/ironman.png","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/images/rocket.png","path":"css/images/rocket.png","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/bootstrap.css","path":"css/bootstrap.css","modified":1,"renderable":1},{"_id":"source/img/dapr/building_blocks.png","path":"img/dapr/building_blocks.png","modified":1,"renderable":0},{"_id":"source/img/header_img/archive.jpg","path":"img/header_img/archive.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/archives-widget.jpg","path":"img/header_img/archives-widget.jpg","modified":1,"renderable":0},{"_id":"source/img/signature/BeanTechSign-black.png","path":"img/signature/BeanTechSign-black.png","modified":1,"renderable":0},{"_id":"source/img/golang/2.png","path":"img/golang/2.png","modified":1,"renderable":0},{"_id":"source/img/java/dapr-http-list.png","path":"img/java/dapr-http-list.png","modified":1,"renderable":0},{"_id":"themes/huweihuang/source/js/jquery.js","path":"js/jquery.js","modified":1,"renderable":1},{"_id":"source/img/article_header/article_bg.jpg","path":"img/article_header/article_bg.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/home.jpg","path":"img/header_img/home.jpg","modified":1,"renderable":0},{"_id":"source/img/blog.jpg","path":"img/blog.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/tag.png","path":"img/header_img/tag.png","modified":1,"renderable":0},{"_id":"source/img/article_header/article_header.png","path":"img/article_header/article_header.png","modified":1,"renderable":0},{"_id":"source/img/header_img/home-bg-o.png","path":"img/header_img/home-bg-o.png","modified":1,"renderable":0},{"_id":"source/img/header_img/home2.png","path":"img/header_img/home2.png","modified":1,"renderable":0},{"_id":"source/img/header_img/404.png","path":"img/header_img/404.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/404.md","hash":"8aa56af7bcd7cd23667cbf3eb5b5c9fa4533eb60","modified":1599794096748},{"_id":"source/CNAME","hash":"9e6f57443c916597fbd8257c2f90d8533eaff248","modified":1599794096748},{"_id":"source/.DS_Store","hash":"5922ec11b7ba4d81b7e55a152193107c9940911d","modified":1599794172851},{"_id":"themes/huweihuang/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1599794096817},{"_id":"themes/huweihuang/_config.yml","hash":"e800e32847df32dacddb5202823a004557023bcd","modified":1599794096818},{"_id":"source/_posts/dapr-readme.md","hash":"6b398face6d7c59c7b8f821984c17b92347db815","modified":1599804733099},{"_id":"source/_posts/dapr-doc.md","hash":"4f5d080bdc07798cccfdf3e287a65419a64c3287","modified":1600332540743},{"_id":"source/_posts/environment-setup.md","hash":"aae42d132d205156d83f496914d9edb1aa9dffee","modified":1604634795316},{"_id":"source/_posts/getting-started.md","hash":"3eb0ce24cd5fe394faa5dd595f94a94d848afe1e","modified":1604634795317},{"_id":"source/_posts/go-invoke-http.md","hash":"8fec2e8f2c66b982d3e9999247b8bf5c80620c88","modified":1604802773336},{"_id":"source/_posts/service-invocation-api.md","hash":"2e6e11f7d846ba144a5920e6c9232e1968ef961a","modified":1600223203050},{"_id":"source/_posts/java-invoke-http.md","hash":"0e043000aca8d81a3acc0e5b03afb1061d9e849e","modified":1604817033008},{"_id":"source/_posts/doc-overview.md","hash":"992d564c55b151b78a32075fc1386b75e4938649","modified":1600225093890},{"_id":"source/_posts/invoke-and-discover-services.md","hash":"a4f587fe4596d6276e3121960ebf780357640cf3","modified":1600223290314},{"_id":"source/_posts/service-invocation.md","hash":"5687260825dedfba9876529fa16385f96e8eac3b","modified":1604562468864},{"_id":"source/_posts/setup-aks.md","hash":"c693833e71ce4d6ddd7a850bc9a89751efcf956a","modified":1604634795317},{"_id":"source/_posts/setup-minikube.md","hash":"35dc29b8dba3e6649c2e24ca194e70299861d8be","modified":1604634795318},{"_id":"source/img/.DS_Store","hash":"fcc691f988309ecd1ec7a8807b25802593d0f1cb","modified":1604816656539},{"_id":"source/about/index.md","hash":"74db13a6b4da4b941cc883003dbd2a2c9ad5799a","modified":1600217752635},{"_id":"source/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1599794096813},{"_id":"source/tags/index.md","hash":"f6ad1039c242795de5cd7d81781148f8c5298c28","modified":1599794096817},{"_id":"themes/huweihuang/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1599794096819},{"_id":"themes/huweihuang/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1599794096818},{"_id":"themes/huweihuang/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1599794096819},{"_id":"themes/huweihuang/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1599794096819},{"_id":"themes/huweihuang/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1599794096820},{"_id":"themes/huweihuang/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1599794096820},{"_id":"themes/huweihuang/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1599794096821},{"_id":"themes/huweihuang/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1599794096821},{"_id":"themes/huweihuang/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1599794096821},{"_id":"themes/huweihuang/layout/404.ejs","hash":"40de38bd399f6f4aef0d6c63c7b13b02d74f1c56","modified":1599794096822},{"_id":"themes/huweihuang/layout/about.ejs","hash":"edcf8fa3bf7093c974d418ffef42ac89c19af128","modified":1599794096829},{"_id":"themes/huweihuang/layout/archive.ejs","hash":"c15726ab348cbf75291b88ffe5e5e50335b5cb0b","modified":1599794096829},{"_id":"themes/huweihuang/layout/keynote.ejs","hash":"f5689862281e34dbe8402b0e72f632902e53e88b","modified":1599794096830},{"_id":"themes/huweihuang/layout/index.ejs","hash":"9e682d5d19cce88ffcae6bbcd0d644df64a6d735","modified":1599794096830},{"_id":"themes/huweihuang/layout/post.ejs","hash":"7088681f19dee7f2bb3d52969a912521423a6494","modified":1599794096832},{"_id":"themes/huweihuang/layout/page.ejs","hash":"5e588f200a7b7cd3ae40402b0dd3b779aac6787f","modified":1599794096831},{"_id":"themes/huweihuang/layout/layout.ejs","hash":"a5af5b99ac3456ab5da1a319455904b979b91601","modified":1599794096831},{"_id":"themes/huweihuang/layout/tags.ejs","hash":"2c72eb2e89130658aa068d80d27b561b509c5dcd","modified":1599794096833},{"_id":"source/img/about/about-bg.jpg","hash":"c92ad7eed5af90b07f73733ae54330d5744c8023","modified":1599794149238},{"_id":"source/img/avatar/head.jpg","hash":"29cd76dc99a7dfef64ffb8195ab75d52e8282bcb","modified":1599794136780},{"_id":"source/img/avatar/home-bg.jpg","hash":"e81513cb4806bfa0cd25a678fd3fa230ffa316bf","modified":1599794143395},{"_id":"source/img/avatar/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1599794258619},{"_id":"source/img/about/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1599794201699},{"_id":"source/img/dapr/dapr.svg","hash":"fee095056405185e7401b35bf2cb0452c6ede45d","modified":1599794096789},{"_id":"source/img/dapr/overview-sidecar-kubernetes.png","hash":"0566eeedbc3ab9d00cffe43e33004bed13645050","modified":1600217752637},{"_id":"source/img/dapr/overview-sidecar.png","hash":"3c48e68030f974128f19cfeebd0322412e0b3c29","modified":1600217752637},{"_id":"source/img/dapr/service-invocation.png","hash":"818f4068046e78f8ec9b17008be656fddcf9416a","modified":1600217752639},{"_id":"source/img/golang/golang.jpeg","hash":"89732b9b4dcd3d8c6e97d732a96794c3191d353b","modified":1604542699643},{"_id":"source/img/java/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1604808127969},{"_id":"themes/huweihuang/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1599794096824},{"_id":"themes/huweihuang/layout/_partial/footer.ejs","hash":"f164abfa96eeefbc2270f3b7d4e0c7fc9abe7a6b","modified":1604455552914},{"_id":"themes/huweihuang/layout/_partial/sidebar.ejs","hash":"2e4e528a555917b2a267da4db2440bcc4a7a65ab","modified":1599794096825},{"_id":"themes/huweihuang/layout/_partial/head.ejs","hash":"720349195a5ea7b610a82ce3ce74298fb2bc7347","modified":1599794096823},{"_id":"themes/huweihuang/layout/_partial/header.ejs","hash":"3bd09df76e0622d76d186b020393fcab361e6c97","modified":1599794096823},{"_id":"themes/huweihuang/layout/_partial/toc.ejs","hash":"40e11b303df113c64a5ca35b79dd53c824010c09","modified":1599794096826},{"_id":"themes/huweihuang/layout/_partial/nav.ejs","hash":"4c905166c960852e9b9a3c9d5c680091e37b481f","modified":1599794096824},{"_id":"themes/huweihuang/layout/_widget/archive.ejs","hash":"7594929d472806ca4c64d9906d9903a96de111a0","modified":1599794096826},{"_id":"themes/huweihuang/layout/_widget/category.ejs","hash":"1cf485def07dc06e870dc9613767c6c614bcf428","modified":1599794096827},{"_id":"themes/huweihuang/layout/_widget/short-about.ejs","hash":"315de02246f07c747c32495e107ad7b19cb3ff54","modified":1599794096828},{"_id":"themes/huweihuang/layout/_widget/recent-posts.ejs","hash":"e08ab8ba60e31638006acf27f066b989a0a3c433","modified":1599794096828},{"_id":"themes/huweihuang/layout/_widget/friends-blog.ejs","hash":"734d3775017aedac185028924baf890a71a74548","modified":1599794096827},{"_id":"themes/huweihuang/layout/_widget/featured-tags.ejs","hash":"0c9ce1942f1943dc8891a9302a922ef1ffe300c5","modified":1599794096827},{"_id":"themes/huweihuang/source/css/archive.styl","hash":"715bcbd085eb95ec26c9805c11c374919cde971c","modified":1599794096834},{"_id":"themes/huweihuang/source/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1599794096834},{"_id":"themes/huweihuang/source/css/beantech.css","hash":"4c361354fd8e9851923fb21a620bc079380ebcd8","modified":1599794096834},{"_id":"themes/huweihuang/source/css/donate.css","hash":"f65ac8363d8d215adb896158e7b45165db259a47","modified":1599794096836},{"_id":"themes/huweihuang/source/css/highlight.styl","hash":"e842080e6d580f0f70a7df71fbde3c4e49463c19","modified":1599794096837},{"_id":"themes/huweihuang/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1599794096837},{"_id":"themes/huweihuang/source/css/rocket.styl","hash":"e15c51c8566ecd943112e57592888dd318b6fa6a","modified":1599794096838},{"_id":"themes/huweihuang/source/css/signature.styl","hash":"88159b31c59d59c01a0b534af57242662a2a3969","modified":1599794096839},{"_id":"themes/huweihuang/source/css/toc.styl","hash":"631e97f634d30f53314e2fec8bdde267c1c49f4c","modified":1599794096839},{"_id":"themes/huweihuang/source/css/widget.styl","hash":"7a9f735f5ef323dc2950fbd9d76daa16c9a0f1a9","modified":1599794096840},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1599794096840},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1599794096842},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1599794096842},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1599794096842},{"_id":"themes/huweihuang/source/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1599794096843},{"_id":"themes/huweihuang/source/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1599794096843},{"_id":"themes/huweihuang/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1599794096843},{"_id":"themes/huweihuang/source/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1599794096846},{"_id":"source/img/dapr/overview.png","hash":"3ebb0e3bd00841e91969fc0aa2863d22e50d8176","modified":1600217752637},{"_id":"source/img/dapr/overview_kubernetes.png","hash":"f55d770ee0d898b1fd7fc6f14d5016d12698545b","modified":1600217752638},{"_id":"source/img/dapr/overview_standalone.png","hash":"dce33e69dbe7ba0d9f40a318716828e335a9dd18","modified":1600217752639},{"_id":"source/img/golang/1.png","hash":"c45057fa7fdb7b5b639b4dce4f5d5bc65a1130ee","modified":1604629363625},{"_id":"source/img/java/java.jpeg","hash":"ea013bc2d070229b1d154a38f2ecaea558025abe","modified":1604455965863},{"_id":"source/img/java/retries.png","hash":"18f9f65cb49ac4ed49d64bffbe60848711f7709f","modified":1604808016759},{"_id":"themes/huweihuang/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1599794096846},{"_id":"themes/huweihuang/source/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1599794096846},{"_id":"themes/huweihuang/source/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1599794096846},{"_id":"themes/huweihuang/source/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1599794096836},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1599794096841},{"_id":"themes/huweihuang/source/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1599794096843},{"_id":"themes/huweihuang/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1599794096845},{"_id":"source/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1599794096816},{"_id":"source/img/golang/java-http-structure.png","hash":"27cc136efe98e7bccf46eae7a34d1c7698d62fd3","modified":1604800320637},{"_id":"source/img/java/2.png","hash":"06b2f2ba2d3ddeaddd13d93f70df1b14b1110e9c","modified":1604633862745},{"_id":"source/img/java/java-http-structure.png","hash":"27cc136efe98e7bccf46eae7a34d1c7698d62fd3","modified":1604800320637},{"_id":"themes/huweihuang/source/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1599794096837},{"_id":"themes/huweihuang/source/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1599794096838},{"_id":"themes/huweihuang/source/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1599794096835},{"_id":"source/img/dapr/building_blocks.png","hash":"bc13ae897d8ed056bd4ed7693b7a056190f1e96d","modified":1600217752636},{"_id":"source/img/header_img/archive.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1599794096796},{"_id":"source/img/header_img/archives-widget.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1599794096798},{"_id":"source/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1599794096814},{"_id":"source/img/golang/2.png","hash":"06b2f2ba2d3ddeaddd13d93f70df1b14b1110e9c","modified":1604633862745},{"_id":"source/img/java/dapr-http-list.png","hash":"2bd33e6720f27d1b57ac4df71f8d4dccea27e8ff","modified":1604816617441},{"_id":"themes/huweihuang/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1599794096845},{"_id":"source/img/article_header/article_bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1599794096770},{"_id":"source/img/header_img/home.jpg","hash":"8f1c440427a4aa86b623503a926c027e2e10cd66","modified":1599794096804},{"_id":"source/img/blog.jpg","hash":"a76af0b98dbe92ca2d21babcef13f094e409554b","modified":1599794096788},{"_id":"source/img/header_img/tag.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1599794096812},{"_id":"source/img/article_header/article_header.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1599794096773},{"_id":"source/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1599794096801},{"_id":"source/img/header_img/home2.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1599794096808},{"_id":"source/img/header_img/404.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1599794096794},{"_id":"public/post-sitemap.xml","hash":"980d70504f68599d4b7271ccca2ff25d87c4f9c3","modified":1604817052931},{"_id":"public/page-sitemap.xml","hash":"67679b541cb7f9dde42b1ce5e7eaa4b8476fa361","modified":1604817052999},{"_id":"public/tag-sitemap.xml","hash":"361bab78303255ab326cfa357d1a53762f56091e","modified":1604817053017},{"_id":"public/sitemap.xsl","hash":"0fd30cf5d1d596c10211a430bf1109b3318a6509","modified":1604817053018},{"_id":"public/sitemap.xml","hash":"81ed5beff86e3b18087edbf676eb896886d5ee92","modified":1604817053018},{"_id":"public/404.html","hash":"34ec261134caf4b7b3de6bd7c9fa47c0366d160d","modified":1604817053027},{"_id":"public/about/index.html","hash":"a362924b2ec9a6ceb91e4a0826552c98c8a3a3c2","modified":1604817053027},{"_id":"public/tags/index.html","hash":"ed77af34abe3f1c39a6dc18cd63a22a24d2ba781","modified":1604817053027},{"_id":"public/article/go-invoke-http/index.html","hash":"505e59c0775180b3377bf0a14f7dc72f2bb21358","modified":1604817053027},{"_id":"public/article/java-invoke-http/index.html","hash":"d6a561da21eea8c539cefbfade435b5e4c6b8ffb","modified":1604817053027},{"_id":"public/article/setup-aks/index.html","hash":"bd1995f93955e2b3789462803719b486e6eacdfb","modified":1604817053027},{"_id":"public/article/setup-minikube/index.html","hash":"67e9be27d8b17264a64c09fbc186baf238e974c0","modified":1604817053027},{"_id":"public/article/environment-setup/index.html","hash":"0d002740cb2a22f4717a530b78710bf0b353bc46","modified":1604817053027},{"_id":"public/article/dapr-doc/index.html","hash":"93c0d269627c7309e9ba840fc61daab11089810d","modified":1604817053027},{"_id":"public/article/getting-started/index.html","hash":"3c92d623438002146b88cd56f9b7d35e9fc4ecae","modified":1604817053027},{"_id":"public/article/service-invocation-api/index.html","hash":"e00a23490d63326e67b7cdc93bf183c7c56f60e6","modified":1604817053027},{"_id":"public/article/invoke-and-discover-services/index.html","hash":"4fa103410afa69121607a8eb8d1711e456d09fe4","modified":1604817053027},{"_id":"public/article/service-invocation/index.html","hash":"58fa68a3809f7dcec441b32bd27bb719642406a2","modified":1604817053027},{"_id":"public/article/doc-overview/index.html","hash":"83107942abea0f27f9acc49754f22e8593da09c8","modified":1604817053027},{"_id":"public/article/dapr-readme/index.html","hash":"5d7558fa7f9fdabd026c6a54c331d9a50b280684","modified":1604817053028},{"_id":"public/archives/index.html","hash":"be89428ddd6cd2f23451af56c6f8bcd2fab359ba","modified":1604817053028},{"_id":"public/archives/archives/2/index.html","hash":"c44bd8f112f1608e01c01efacd2f3be305897a35","modified":1604817053028},{"_id":"public/archives/2020/index.html","hash":"f3e7519ef67de917b69547df969945c633bbff74","modified":1604817053028},{"_id":"public/archives/2020/archives/2/index.html","hash":"4788b378542e30b6e9561953e77d1587b0cf9bca","modified":1604817053028},{"_id":"public/archives/2020/09/index.html","hash":"f5bcc9017abd8b2bc5aa5d8dca38fddb5c7a12e2","modified":1604817053028},{"_id":"public/archives/2020/11/index.html","hash":"0846e34165c194a827235e7dde66c2bc0c69cc16","modified":1604817053028},{"_id":"public/index.html","hash":"1a46b50142d0c26ded81d3b28126b55d1a7aba50","modified":1604817053029},{"_id":"public/page/2/index.html","hash":"3e7a7f12cbf798a0b0e9b1263ba4808516b8e484","modified":1604817053029},{"_id":"public/tags/Dapr/index.html","hash":"d2b1ad2f3e674dc4d53eb94b844b7f4f9a03536e","modified":1604817053029},{"_id":"public/tags/Dapr/archives/2/index.html","hash":"94ddde21e9221d8dc57512f2668046f718417702","modified":1604817053029},{"_id":"public/tags/原文翻译/index.html","hash":"d6b6376dffc2cdcc3c7ceabffd3ea2dd2d80fc27","modified":1604817053029},{"_id":"public/tags/Go/index.html","hash":"e6de0731ad8a76e390c5726eee0c0aef178b6f0c","modified":1604817053029},{"_id":"public/tags/Java/index.html","hash":"ae00a9a88c37c0f78705db0cad4c7478cb3390ed","modified":1604817053029},{"_id":"public/CNAME","hash":"9e6f57443c916597fbd8257c2f90d8533eaff248","modified":1604817053037},{"_id":"public/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1604817053037},{"_id":"public/img/about/about-bg.jpg","hash":"c92ad7eed5af90b07f73733ae54330d5744c8023","modified":1604817053037},{"_id":"public/img/avatar/head.jpg","hash":"29cd76dc99a7dfef64ffb8195ab75d52e8282bcb","modified":1604817053037},{"_id":"public/img/dapr/dapr.svg","hash":"fee095056405185e7401b35bf2cb0452c6ede45d","modified":1604817053037},{"_id":"public/img/avatar/home-bg.jpg","hash":"e81513cb4806bfa0cd25a678fd3fa230ffa316bf","modified":1604817053038},{"_id":"public/img/dapr/overview-sidecar-kubernetes.png","hash":"0566eeedbc3ab9d00cffe43e33004bed13645050","modified":1604817053038},{"_id":"public/img/dapr/overview-sidecar.png","hash":"3c48e68030f974128f19cfeebd0322412e0b3c29","modified":1604817053038},{"_id":"public/img/dapr/service-invocation.png","hash":"818f4068046e78f8ec9b17008be656fddcf9416a","modified":1604817053038},{"_id":"public/img/golang/golang.jpeg","hash":"89732b9b4dcd3d8c6e97d732a96794c3191d353b","modified":1604817053038},{"_id":"public/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1604817053038},{"_id":"public/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1604817053038},{"_id":"public/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1604817053038},{"_id":"public/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1604817053038},{"_id":"public/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1604817053038},{"_id":"public/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1604817053039},{"_id":"public/img/dapr/overview.png","hash":"3ebb0e3bd00841e91969fc0aa2863d22e50d8176","modified":1604817053265},{"_id":"public/img/dapr/overview_kubernetes.png","hash":"f55d770ee0d898b1fd7fc6f14d5016d12698545b","modified":1604817053266},{"_id":"public/img/dapr/overview_standalone.png","hash":"dce33e69dbe7ba0d9f40a318716828e335a9dd18","modified":1604817053268},{"_id":"public/img/java/java.jpeg","hash":"ea013bc2d070229b1d154a38f2ecaea558025abe","modified":1604817053268},{"_id":"public/img/golang/1.png","hash":"c45057fa7fdb7b5b639b4dce4f5d5bc65a1130ee","modified":1604817053268},{"_id":"public/img/java/retries.png","hash":"18f9f65cb49ac4ed49d64bffbe60848711f7709f","modified":1604817053268},{"_id":"public/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1604817053269},{"_id":"public/css/archive.css","hash":"8db895ebaeff19ac145c961abcfd5d4a8d67a8ea","modified":1604817053275},{"_id":"public/css/highlight.css","hash":"c58b4569c086e477a00dcbf5a95a166fe5fecfb0","modified":1604817053275},{"_id":"public/css/donate.css","hash":"f65ac8363d8d215adb896158e7b45165db259a47","modified":1604817053275},{"_id":"public/css/rocket.css","hash":"9456fd92f729e09d6de8cda70f95d78e0d789c70","modified":1604817053275},{"_id":"public/css/signature.css","hash":"820fa4743cea34a61808cd8f7de528605c32d7e3","modified":1604817053275},{"_id":"public/css/toc.css","hash":"f756b9e1b2208d2e5b0f3d2ac5e4fea3b7da0e10","modified":1604817053275},{"_id":"public/css/widget.css","hash":"da95ad3f1938f24d20f1fa77d7a38f0c392b5ec8","modified":1604817053276},{"_id":"public/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1604817053276},{"_id":"public/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1604817053276},{"_id":"public/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1604817053276},{"_id":"public/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1604817053276},{"_id":"public/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1604817053276},{"_id":"public/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1604817053276},{"_id":"public/css/beantech.css","hash":"4c361354fd8e9851923fb21a620bc079380ebcd8","modified":1604817053276},{"_id":"public/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1604817053276},{"_id":"public/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1604817053276},{"_id":"public/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1604817053276},{"_id":"public/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1604817053276},{"_id":"public/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1604817053276},{"_id":"public/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1604817053277},{"_id":"public/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1604817053277},{"_id":"public/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1604817053277},{"_id":"public/img/golang/java-http-structure.png","hash":"27cc136efe98e7bccf46eae7a34d1c7698d62fd3","modified":1604817053277},{"_id":"public/img/java/2.png","hash":"06b2f2ba2d3ddeaddd13d93f70df1b14b1110e9c","modified":1604817053278},{"_id":"public/img/java/java-http-structure.png","hash":"27cc136efe98e7bccf46eae7a34d1c7698d62fd3","modified":1604817053278},{"_id":"public/img/header_img/archive.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1604817053278},{"_id":"public/img/header_img/archives-widget.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1604817053278},{"_id":"public/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1604817053286},{"_id":"public/img/dapr/building_blocks.png","hash":"bc13ae897d8ed056bd4ed7693b7a056190f1e96d","modified":1604817053286},{"_id":"public/img/golang/2.png","hash":"06b2f2ba2d3ddeaddd13d93f70df1b14b1110e9c","modified":1604817053286},{"_id":"public/img/java/dapr-http-list.png","hash":"2bd33e6720f27d1b57ac4df71f8d4dccea27e8ff","modified":1604817053287},{"_id":"public/img/article_header/article_bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1604817053290},{"_id":"public/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1604817053293},{"_id":"public/img/blog.jpg","hash":"a76af0b98dbe92ca2d21babcef13f094e409554b","modified":1604817053312},{"_id":"public/img/header_img/home.jpg","hash":"8f1c440427a4aa86b623503a926c027e2e10cd66","modified":1604817053315},{"_id":"public/img/header_img/tag.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1604817053323},{"_id":"public/img/article_header/article_header.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1604817053328},{"_id":"public/img/header_img/home2.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1604817053332},{"_id":"public/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1604817053335},{"_id":"public/img/header_img/404.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1604817053340}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原","header-img":"/img/header_img/404.png","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原\"\nheader-img: \"/img/header_img/404.png\"\n---\n","date":"2020-09-11T03:14:56.748Z","updated":"2020-09-11T03:14:56.748Z","path":"404.html","title":"","comments":1,"_id":"ckh8qmygn00004x6ygeb11wh7","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"ABOUT","date":"2020-09-11T00:59:25.000Z","description":null,"header-img":"/img/about/about-bg.jpg","_content":"\n# Dapr\n\nCurrent Version: 0.10.0\n\n---\n鉴于 Dapr 即将发布 1.0 版本，我将对 Dapr 在 Java8 、.Net5、Golang、Python3 的运用做成系列文章以抛砖引玉。\n\n> *注：* Dapr 将在 2020 年底或者 2021 年初发布 1.0 稳定版。.NET5 将在 11 月份发布正式版。\n\n## Dapr 概念\n\n此节将包含部分官方文档翻译以及我对 Dapr 的理解，如有必要，将对源码进行解读。\n\n### 官方文档翻译\n\n- {% post_link dapr-readme %}\n- {% post_link doc-overview %}\n\n### 通过 Java8 使用 Dapr\n\n### 通过 .Net5 使用 Dapr\n\n### 通过 Golang 使用 Dapr\n\n### 通过 Python3 使用 Dapr\n\n## 一些章节\n\n此章节是 Dapr 0.3.0 版本我发布过的一些内容。从版本号来看确实有挺大的差距。但仍具参考价值。\n\n- [Dapr 运用](https://www.cnblogs.com/Zhang-Xiang/p/12035354.html)\n  - 使用 `Asp.Net Core` 包含3个服务\n    - ProductService\n    - StorageService\n- [Dapr 运用之 Java gRPC 调用篇](https://www.cnblogs.com/Zhang-Xiang/p/12058097.html)\n  - 使用 Java 实现 gRPC 服务，并通过 Dapr 调用\n- [Dapr Pub/Sub 集成 RabbitMQ 、Golang、Java、DotNet Core](https://www.cnblogs.com/Zhang-Xiang/p/12106577.html)\n  - 通过 Dapr 完成 Go 与 Java 的调用，并完成 Pub/Sub\n","source":"about/index.md","raw":"---\ntitle: ABOUT\ndate: 2020-09-11 08:59:25\ndescription: \nheader-img: \"/img/about/about-bg.jpg\"\n---\n\n# Dapr\n\nCurrent Version: 0.10.0\n\n---\n鉴于 Dapr 即将发布 1.0 版本，我将对 Dapr 在 Java8 、.Net5、Golang、Python3 的运用做成系列文章以抛砖引玉。\n\n> *注：* Dapr 将在 2020 年底或者 2021 年初发布 1.0 稳定版。.NET5 将在 11 月份发布正式版。\n\n## Dapr 概念\n\n此节将包含部分官方文档翻译以及我对 Dapr 的理解，如有必要，将对源码进行解读。\n\n### 官方文档翻译\n\n- {% post_link dapr-readme %}\n- {% post_link doc-overview %}\n\n### 通过 Java8 使用 Dapr\n\n### 通过 .Net5 使用 Dapr\n\n### 通过 Golang 使用 Dapr\n\n### 通过 Python3 使用 Dapr\n\n## 一些章节\n\n此章节是 Dapr 0.3.0 版本我发布过的一些内容。从版本号来看确实有挺大的差距。但仍具参考价值。\n\n- [Dapr 运用](https://www.cnblogs.com/Zhang-Xiang/p/12035354.html)\n  - 使用 `Asp.Net Core` 包含3个服务\n    - ProductService\n    - StorageService\n- [Dapr 运用之 Java gRPC 调用篇](https://www.cnblogs.com/Zhang-Xiang/p/12058097.html)\n  - 使用 Java 实现 gRPC 服务，并通过 Dapr 调用\n- [Dapr Pub/Sub 集成 RabbitMQ 、Golang、Java、DotNet Core](https://www.cnblogs.com/Zhang-Xiang/p/12106577.html)\n  - 通过 Dapr 完成 Go 与 Java 的调用，并完成 Pub/Sub\n","updated":"2020-09-16T00:55:52.635Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckh8qmyhj00024x6yezo6a5us","content":"<h1 id=\"dapr\">Dapr</h1>\n<p>Current Version: 0.10.0</p>\n<hr>\n<p>鉴于 Dapr 即将发布 1.0 版本，我将对 Dapr 在 Java8 、.Net5、Golang、Python3 的运用做成系列文章以抛砖引玉。</p>\n<blockquote>\n<p><em>注：</em> Dapr 将在 2020 年底或者 2021 年初发布 1.0 稳定版。.NET5 将在 11 月份发布正式版。</p>\n</blockquote>\n<h2 id=\"dapr-概念\">Dapr 概念</h2>\n<p>此节将包含部分官方文档翻译以及我对 Dapr 的理解，如有必要，将对源码进行解读。</p>\n<h3 id=\"官方文档翻译\">官方文档翻译</h3>\n<ul>\n<li>\n<a href=\"/article/dapr-readme/\" title=\"简介\">简介</a>\n</li>\n<li>\n<a href=\"/article/doc-overview/\" title=\"Dapr 概述\">Dapr 概述</a>\n</li>\n</ul>\n<h3 id=\"通过-java8-使用-dapr\">通过 Java8 使用 Dapr</h3>\n<h3 id=\"通过-net5-使用-dapr\">通过 .Net5 使用 Dapr</h3>\n<h3 id=\"通过-golang-使用-dapr\">通过 Golang 使用 Dapr</h3>\n<h3 id=\"通过-python3-使用-dapr\">通过 Python3 使用 Dapr</h3>\n<h2 id=\"一些章节\">一些章节</h2>\n<p>此章节是 Dapr 0.3.0 版本我发布过的一些内容。从版本号来看确实有挺大的差距。但仍具参考价值。</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/Zhang-Xiang/p/12035354.html\" target=\"_blank\" rel=\"noopener\">Dapr 运用</a>\n<ul>\n<li>使用 <code>Asp.Net Core</code> 包含3个服务\n<ul>\n<li>ProductService</li>\n<li>StorageService</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://www.cnblogs.com/Zhang-Xiang/p/12058097.html\" target=\"_blank\" rel=\"noopener\">Dapr 运用之 Java gRPC 调用篇</a>\n<ul>\n<li>使用 Java 实现 gRPC 服务，并通过 Dapr 调用</li>\n</ul>\n</li>\n<li><a href=\"https://www.cnblogs.com/Zhang-Xiang/p/12106577.html\" target=\"_blank\" rel=\"noopener\">Dapr Pub/Sub 集成 RabbitMQ 、Golang、Java、DotNet Core</a>\n<ul>\n<li>通过 Dapr 完成 Go 与 Java 的调用，并完成 Pub/Sub</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1>Dapr</h1>\n<p>Current Version: 0.10.0</p>\n<hr>\n<p>鉴于 Dapr 即将发布 1.0 版本，我将对 Dapr 在 Java8 、.Net5、Golang、Python3 的运用做成系列文章以抛砖引玉。</p>\n<blockquote>\n<p><em>注：</em> Dapr 将在 2020 年底或者 2021 年初发布 1.0 稳定版。.NET5 将在 11 月份发布正式版。</p>\n</blockquote>\n<h2>Dapr 概念</h2>\n<p>此节将包含部分官方文档翻译以及我对 Dapr 的理解，如有必要，将对源码进行解读。</p>\n<h3>官方文档翻译</h3>\n<ul>\n<li>\n<a href=\"/article/dapr-readme/\" title=\"简介\">简介</a>\n</li>\n<li>\n<a href=\"/article/doc-overview/\" title=\"Dapr 概述\">Dapr 概述</a>\n</li>\n</ul>\n<h3>通过 Java8 使用 Dapr</h3>\n<h3>通过 .Net5 使用 Dapr</h3>\n<h3>通过 Golang 使用 Dapr</h3>\n<h3>通过 Python3 使用 Dapr</h3>\n<h2>一些章节</h2>\n<p>此章节是 Dapr 0.3.0 版本我发布过的一些内容。从版本号来看确实有挺大的差距。但仍具参考价值。</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/Zhang-Xiang/p/12035354.html\" target=\"_blank\" rel=\"noopener\">Dapr 运用</a>\n<ul>\n<li>使用 <code>Asp.Net Core</code> 包含3个服务\n<ul>\n<li>ProductService</li>\n<li>StorageService</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://www.cnblogs.com/Zhang-Xiang/p/12058097.html\" target=\"_blank\" rel=\"noopener\">Dapr 运用之 Java gRPC 调用篇</a>\n<ul>\n<li>使用 Java 实现 gRPC 服务，并通过 Dapr 调用</li>\n</ul>\n</li>\n<li><a href=\"https://www.cnblogs.com/Zhang-Xiang/p/12106577.html\" target=\"_blank\" rel=\"noopener\">Dapr Pub/Sub 集成 RabbitMQ 、Golang、Java、DotNet Core</a>\n<ul>\n<li>通过 Dapr 完成 Go 与 Java 的调用，并完成 Pub/Sub</li>\n</ul>\n</li>\n</ul>\n"},{"layout":"tags","title":"Tags","description":"Hey, this is Tags.","header-img":"/img/header_img/tag.png","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"/img/header_img/tag.png\"\n---\n","date":"2020-09-11T03:14:56.817Z","updated":"2020-09-11T03:14:56.817Z","path":"tags/index.html","comments":1,"_id":"ckh8qmyhl00044x6yv04gwfsx","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"简介","catalog":true,"toc_nav_num":true,"date":"2020-09-11T00:59:25.000Z","subtitle":"Dapr 源码 readme","header-img":"/img/dapr/dapr.svg","catagories":["Dapr"],"_content":"\n## 介绍\n\n[官方文档地址](https://github.com/dapr/dapr)\n\nDapr（Distributed Application Runtime） 是一个可移植的（portable）、事件驱动（event-driven）的运行时框架。开发者通过 Dapr 可以构建弹性、无状态、有状态的运行在云上和边缘的微服务。并且拥抱开发语言和开发框架的多样性。\n\nDapr 将构建微服务的最佳实践整理为开放、独立的构建块。因此，你可以选择开发语言和框架构建可移植的应用程序。每个构建块都是独立的，你可以在你的应用程序中使用它们中的一个、几个或者所有。\n\n---\n\n### 如何工作\n\nDapr 注入一个边车(side-car)(通过容器或者进程注入)到每一个计算单元。边车通过事件触发器交互，和计算单元通过 HTTP 或者 gRPC 协议通信。这使得 Dapr 支持现有和未来的开发语言而不需要你导入框架或者库。\n\nDapr 通过标准 HTTP 动词或者 gRPC 接口提供内建状态管理、可靠消息（至少一次投递）、触发器和绑定。这表示你可以遵循相同的编程范式写无状态、有状态和类似 Actor 模型的服务。你可以自由的选择一致性模型、线程模型和消息传递模式。\n\nDapr 在 K8S 上原生运行，作为自托管二进制文件在你的机器上、物联网设备上运行，或者做为一个容器注入到云或本地的任何系统中。\n\nDapr 使用可插拔组件状态存储和消息总线，例如：Redis、gRPC 以提供一系列通信方法，包括使用 gRPC 完成 dapr 到 dapr 的直接通信，异步 Pub-sub 以保证消息传递至少一次的语义。\n\n### 为什么使用 Dapr\n\n高性能、可扩展并且可靠的分布式应用是很困难的。而 Dapr 提供已经验证过的模式和实践方式。它把事件驱动和参与者语义统一成一个简单、一致的编程模型。它支持所有编程语言并且不限定编程框架。 你不必面对底层函数比如线程、并发控制、分区和缩放。事实上，你只需要选择一个你熟悉的 Web 框架实现一个简单的 Web 服务。\n\nDapr 在线程和状态一致性模型方面很灵活。 你可以选择多个线程，并且在不同的一致性模型中选择。这种灵活性使你可以实现高级使用场景而不需要人工约束。Dapr 是独一无二的，因为你可以在平台和基础实现之间无缝过渡，而无需重写代码。\n","source":"_posts/dapr-readme.md","raw":"---\ntitle: 简介\ncatalog: true\ntoc_nav_num: true\ndate: 2020-09-11 08:59:25\nsubtitle: Dapr 源码 readme\nheader-img: /img/dapr/dapr.svg\ntags: \n- Dapr\n- 原文翻译\ncatagories:\n- Dapr\n---\n\n## 介绍\n\n[官方文档地址](https://github.com/dapr/dapr)\n\nDapr（Distributed Application Runtime） 是一个可移植的（portable）、事件驱动（event-driven）的运行时框架。开发者通过 Dapr 可以构建弹性、无状态、有状态的运行在云上和边缘的微服务。并且拥抱开发语言和开发框架的多样性。\n\nDapr 将构建微服务的最佳实践整理为开放、独立的构建块。因此，你可以选择开发语言和框架构建可移植的应用程序。每个构建块都是独立的，你可以在你的应用程序中使用它们中的一个、几个或者所有。\n\n---\n\n### 如何工作\n\nDapr 注入一个边车(side-car)(通过容器或者进程注入)到每一个计算单元。边车通过事件触发器交互，和计算单元通过 HTTP 或者 gRPC 协议通信。这使得 Dapr 支持现有和未来的开发语言而不需要你导入框架或者库。\n\nDapr 通过标准 HTTP 动词或者 gRPC 接口提供内建状态管理、可靠消息（至少一次投递）、触发器和绑定。这表示你可以遵循相同的编程范式写无状态、有状态和类似 Actor 模型的服务。你可以自由的选择一致性模型、线程模型和消息传递模式。\n\nDapr 在 K8S 上原生运行，作为自托管二进制文件在你的机器上、物联网设备上运行，或者做为一个容器注入到云或本地的任何系统中。\n\nDapr 使用可插拔组件状态存储和消息总线，例如：Redis、gRPC 以提供一系列通信方法，包括使用 gRPC 完成 dapr 到 dapr 的直接通信，异步 Pub-sub 以保证消息传递至少一次的语义。\n\n### 为什么使用 Dapr\n\n高性能、可扩展并且可靠的分布式应用是很困难的。而 Dapr 提供已经验证过的模式和实践方式。它把事件驱动和参与者语义统一成一个简单、一致的编程模型。它支持所有编程语言并且不限定编程框架。 你不必面对底层函数比如线程、并发控制、分区和缩放。事实上，你只需要选择一个你熟悉的 Web 框架实现一个简单的 Web 服务。\n\nDapr 在线程和状态一致性模型方面很灵活。 你可以选择多个线程，并且在不同的一致性模型中选择。这种灵活性使你可以实现高级使用场景而不需要人工约束。Dapr 是独一无二的，因为你可以在平台和基础实现之间无缝过渡，而无需重写代码。\n","slug":"dapr-readme","published":1,"updated":"2020-09-11T06:12:13.099Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh8qmyhf00014x6y3etn3vwk","content":"<h2 id=\"介绍\">介绍</h2>\n<p><a href=\"https://github.com/dapr/dapr\" target=\"_blank\" rel=\"noopener\">官方文档地址</a></p>\n<p>Dapr（Distributed Application Runtime） 是一个可移植的（portable）、事件驱动（event-driven）的运行时框架。开发者通过 Dapr 可以构建弹性、无状态、有状态的运行在云上和边缘的微服务。并且拥抱开发语言和开发框架的多样性。</p>\n<p>Dapr 将构建微服务的最佳实践整理为开放、独立的构建块。因此，你可以选择开发语言和框架构建可移植的应用程序。每个构建块都是独立的，你可以在你的应用程序中使用它们中的一个、几个或者所有。</p>\n<hr>\n<h3 id=\"如何工作\">如何工作</h3>\n<p>Dapr 注入一个边车(side-car)(通过容器或者进程注入)到每一个计算单元。边车通过事件触发器交互，和计算单元通过 HTTP 或者 gRPC 协议通信。这使得 Dapr 支持现有和未来的开发语言而不需要你导入框架或者库。</p>\n<p>Dapr 通过标准 HTTP 动词或者 gRPC 接口提供内建状态管理、可靠消息（至少一次投递）、触发器和绑定。这表示你可以遵循相同的编程范式写无状态、有状态和类似 Actor 模型的服务。你可以自由的选择一致性模型、线程模型和消息传递模式。</p>\n<p>Dapr 在 K8S 上原生运行，作为自托管二进制文件在你的机器上、物联网设备上运行，或者做为一个容器注入到云或本地的任何系统中。</p>\n<p>Dapr 使用可插拔组件状态存储和消息总线，例如：Redis、gRPC 以提供一系列通信方法，包括使用 gRPC 完成 dapr 到 dapr 的直接通信，异步 Pub-sub 以保证消息传递至少一次的语义。</p>\n<h3 id=\"为什么使用-dapr\">为什么使用 Dapr</h3>\n<p>高性能、可扩展并且可靠的分布式应用是很困难的。而 Dapr 提供已经验证过的模式和实践方式。它把事件驱动和参与者语义统一成一个简单、一致的编程模型。它支持所有编程语言并且不限定编程框架。 你不必面对底层函数比如线程、并发控制、分区和缩放。事实上，你只需要选择一个你熟悉的 Web 框架实现一个简单的 Web 服务。</p>\n<p>Dapr 在线程和状态一致性模型方面很灵活。 你可以选择多个线程，并且在不同的一致性模型中选择。这种灵活性使你可以实现高级使用场景而不需要人工约束。Dapr 是独一无二的，因为你可以在平台和基础实现之间无缝过渡，而无需重写代码。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>介绍</h2>\n<p><a href=\"https://github.com/dapr/dapr\" target=\"_blank\" rel=\"noopener\">官方文档地址</a></p>\n<p>Dapr（Distributed Application Runtime） 是一个可移植的（portable）、事件驱动（event-driven）的运行时框架。开发者通过 Dapr 可以构建弹性、无状态、有状态的运行在云上和边缘的微服务。并且拥抱开发语言和开发框架的多样性。</p>\n<p>Dapr 将构建微服务的最佳实践整理为开放、独立的构建块。因此，你可以选择开发语言和框架构建可移植的应用程序。每个构建块都是独立的，你可以在你的应用程序中使用它们中的一个、几个或者所有。</p>\n<hr>\n<h3>如何工作</h3>\n<p>Dapr 注入一个边车(side-car)(通过容器或者进程注入)到每一个计算单元。边车通过事件触发器交互，和计算单元通过 HTTP 或者 gRPC 协议通信。这使得 Dapr 支持现有和未来的开发语言而不需要你导入框架或者库。</p>\n<p>Dapr 通过标准 HTTP 动词或者 gRPC 接口提供内建状态管理、可靠消息（至少一次投递）、触发器和绑定。这表示你可以遵循相同的编程范式写无状态、有状态和类似 Actor 模型的服务。你可以自由的选择一致性模型、线程模型和消息传递模式。</p>\n<p>Dapr 在 K8S 上原生运行，作为自托管二进制文件在你的机器上、物联网设备上运行，或者做为一个容器注入到云或本地的任何系统中。</p>\n<p>Dapr 使用可插拔组件状态存储和消息总线，例如：Redis、gRPC 以提供一系列通信方法，包括使用 gRPC 完成 dapr 到 dapr 的直接通信，异步 Pub-sub 以保证消息传递至少一次的语义。</p>\n<h3>为什么使用 Dapr</h3>\n<p>高性能、可扩展并且可靠的分布式应用是很困难的。而 Dapr 提供已经验证过的模式和实践方式。它把事件驱动和参与者语义统一成一个简单、一致的编程模型。它支持所有编程语言并且不限定编程框架。 你不必面对底层函数比如线程、并发控制、分区和缩放。事实上，你只需要选择一个你熟悉的 Web 框架实现一个简单的 Web 服务。</p>\n<p>Dapr 在线程和状态一致性模型方面很灵活。 你可以选择多个线程，并且在不同的一致性模型中选择。这种灵活性使你可以实现高级使用场景而不需要人工约束。Dapr 是独一无二的，因为你可以在平台和基础实现之间无缝过渡，而无需重写代码。</p>\n"},{"title":"Dapr 文档","catalog":true,"toc_nav_num":true,"date":"2020-09-17T08:18:58.000Z","subtitle":"dapr/docs","header-img":"/img/dapr/dapr.svg","top":1,"catagories":["Dapr"],"_content":"\n## Dapr 文档\n\n---\n\n### 内容\n\n主题|描述\n--|--\n{% post_link doc-overview 概述%}|Dapr 概述以及你如何使用它构建事件驱动、分部署应用程序\n{% post_link getting-started 快速开始 %}|设置你的开发环境\n概念|Dapr 概念解释\n如何做|指导解释如何完成指定的任务\n最佳实践|指导解释使用 Dapr 最佳实践\n引用|API 和绑定引用文档\nFAQ|常见问答\n\n### 更多文档\n","source":"_posts/dapr-doc.md","raw":"---\ntitle: Dapr 文档\ncatalog: true\ntoc_nav_num: true\ndate: 2020-09-17 16:18:58\nsubtitle: dapr/docs\nheader-img: /img/dapr/dapr.svg\ntop: 1\ntags: \n- Dapr\n- 原文翻译\ncatagories:\n- Dapr\n---\n\n## Dapr 文档\n\n---\n\n### 内容\n\n主题|描述\n--|--\n{% post_link doc-overview 概述%}|Dapr 概述以及你如何使用它构建事件驱动、分部署应用程序\n{% post_link getting-started 快速开始 %}|设置你的开发环境\n概念|Dapr 概念解释\n如何做|指导解释如何完成指定的任务\n最佳实践|指导解释使用 Dapr 最佳实践\n引用|API 和绑定引用文档\nFAQ|常见问答\n\n### 更多文档\n","slug":"dapr-doc","published":1,"updated":"2020-09-17T08:49:00.743Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh8qmyhk00034x6y4jf1ffwh","content":"<h2 id=\"dapr-文档\">Dapr 文档</h2>\n<hr>\n<h3 id=\"内容\">内容</h3>\n<table>\n<thead>\n<tr>\n<th>主题</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"/article/doc-overview/\" title=\"概述\">概述</a></td>\n<td>Dapr 概述以及你如何使用它构建事件驱动、分部署应用程序</td>\n</tr>\n<tr>\n<td><a href=\"/article/getting-started/\" title=\"快速开始\">快速开始</a></td>\n<td>设置你的开发环境</td>\n</tr>\n<tr>\n<td>概念</td>\n<td>Dapr 概念解释</td>\n</tr>\n<tr>\n<td>如何做</td>\n<td>指导解释如何完成指定的任务</td>\n</tr>\n<tr>\n<td>最佳实践</td>\n<td>指导解释使用 Dapr 最佳实践</td>\n</tr>\n<tr>\n<td>引用</td>\n<td>API 和绑定引用文档</td>\n</tr>\n<tr>\n<td>FAQ</td>\n<td>常见问答</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"更多文档\">更多文档</h3>\n","site":{"data":{}},"excerpt":"","more":"<h2>Dapr 文档</h2>\n<hr>\n<h3>内容</h3>\n<table>\n<thead>\n<tr>\n<th>主题</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"/article/doc-overview/\" title=\"概述\">概述</a></td>\n<td>Dapr 概述以及你如何使用它构建事件驱动、分部署应用程序</td>\n</tr>\n<tr>\n<td><a href=\"/article/getting-started/\" title=\"快速开始\">快速开始</a></td>\n<td>设置你的开发环境</td>\n</tr>\n<tr>\n<td>概念</td>\n<td>Dapr 概念解释</td>\n</tr>\n<tr>\n<td>如何做</td>\n<td>指导解释如何完成指定的任务</td>\n</tr>\n<tr>\n<td>最佳实践</td>\n<td>指导解释使用 Dapr 最佳实践</td>\n</tr>\n<tr>\n<td>引用</td>\n<td>API 和绑定引用文档</td>\n</tr>\n<tr>\n<td>FAQ</td>\n<td>常见问答</td>\n</tr>\n</tbody>\n</table>\n<h3>更多文档</h3>\n"},{"title":"环境设置","catalog":true,"toc_nav_num":true,"date":"2020-09-19T08:27:14.000Z","subtitle":"docs/getting-started/environment-setup","header-img":"/img/dapr/dapr.svg","catagories":["Dapr"],"_content":"\n## 环境设置\n\n---\n\nDapr 既可以使用自托管模式运行也可以运行在 K8S 模式下。通过自托管模式运行 Dapr 运行时使你可以在本地开发环境开发 Dapr 应用程序，然后部署到其它支持 Dapr 运行的环境。例如：你可以在自托管模式下开发 Dapr 应用程序然后把应用程序部署到任何 K8S 集群。\n\n### 内容\n\n---\n\n- [环境设置](#环境设置)\n  - [内容](#内容)\n  - [先决条件](#先决条件)\n  - [安装 Dapr 命令行](#安装-dapr-命令行)\n    - [Windows](#windows)\n    - [Linux](#linux)\n    - [MacOS](#macos)\n    - [通过二进制版本](#通过二进制版本)\n  - [自托管模式安装 Dapr](#自托管模式安装-dapr)\n    - [使用命令行界面初始化 Dapr](#使用命令行界面初始化-dapr)\n    - [安装指定运行时版本](#安装指定运行时版本)\n    - [自托管模式卸载 Dapr](#自托管模式卸载-dapr)\n  - [在 K8S 集群下安装 Dapr](#在-k8s-集群下安装-dapr)\n    - [设置集群](#设置集群)\n    - [使用 Dapr 命令行界面](#使用-dapr-命令行界面)\n      - [安装 Dapr 到 K8S](#安装-dapr-到-k8s)\n    - [使用 Helm （高级）](#使用-helm-高级)\n      - [在 K8S 中安装 Dapr](#在-k8s-中安装-dapr)\n      - [验证安装](#验证安装)\n      - [边车注释](#边车注释)\n      - [从 K8S 中卸载 Dapr](#从-k8s-中卸载-dapr)\n\n### 先决条件\n\n---\n\n默认情况下，Dapr 使用 Docker 容器安装开发环境以便你轻松上手。然而，Dapr 不依赖 Docker 运行（查看【这里】介绍使用 Docker 轻量化初始本地安装 Dapr）。这个入门指南假设 Dapr 是和开发人员环境一起安装的。\n\n- 安装 [Docker](https://docs.docker.com/get-docker/)\n\n> Windows 用户，确保 `Docker Desktop For Windows` 使用 Linux 容器。\n\n### 安装 Dapr 命令行\n\n---\n\n使用脚本安装最新版本\n\n#### Windows\n\n安装最新的 windows Dapr 命令行界面到  `c:\\dapr` 并添加这个文件夹到 User Path 环境变量中。\n\n``` powershell\npowershell -Command \"iwr -useb https://raw.githubusercontent.com/dapr/cli/master/install/install.ps1 | iex\"\n```\n\n#### Linux\n\n安装最新的 linux Dapr 命令行界面到 `/usr/local/bin`\n\n``` bash\nwget -q https://raw.githubusercontent.com/dapr/cli/master/install/install.sh -O - | /bin/bash\n```\n\n#### MacOS\n\n安装最新的 darwin Dapr 命令行界面到 `/usr/local/bin`\n\n``` bash\ncurl -fsSL https://raw.githubusercontent.com/dapr/cli/master/install/install.sh | /bin/bash\n```\n\n或者使用 Homebrew 安装\n\n``` bash\nbrew install dapr/tap/dapr-cli\n```\n\n#### 通过二进制版本\n\nDapr 命令行界面每个发布版本都包含各种系统和架构。这些二进制版本可以手动下载和安装。\n\n1. 下载[Dapr 命令行界面](https://github.com/dapr/cli/releases)\n2. 解压（例如：dapr_linux_amd64.tar.gz, dapr_windows_amd64.zip）\n3. 把解压后文件移动到你希望的位置。\n   - Linux/MacOS - /usr/local/bin\n   - Windows，创建一个文件夹并添加文件夹路径到系统路径中。例如：创建一个文件夹 `c:\\dapr` 并把文件夹路径加入到系统环境变量中。\n\n### 自托管模式安装 Dapr\n\n---\n\n#### 使用命令行界面初始化 Dapr\n\n默认情况下，初始化 Dapr 命令行界面过程中会安装 Dapr 二进制文件，同时设置一个开发者环境以帮助你轻松上手 Dapr。这个环境使用 Docker 容器，因此 Docker 列入到先决条件中。\n\n>如果你不想使用这个环境并且不依赖 Docker 运行 Dapr，查看命令行界面[文档](https://github.com/dapr/cli/blob/master/README.md)，当使用 init 命令时同时使用 `--slim` 命令。注意，如果你时一个新手，强烈推荐安装 Docker 并且使用常规初始化（init）命令。\n>对于 Linux 用户，如果你运行 docker 命令使用 sudo 或者安装路径时 `/usr/local/bin` （默认安装路径），你需要使用“sudo dapr init”。对于 Windows 用户，确保你使用管理员模式运行命令行终端。注意：查看[Dapr 命令行界面]以了解使用 Dapr 命令行界面的细节。\n\n``` cmd\n$ dapr init\n⌛  Making the jump to hyperspace...\nDownloading binaries and setting up components\n✅  Success! Dapr is up and running. To get started, go here: https://aka.ms/dapr-getting-started\n```\n\n查看 Dapr 安装成功，从命令提示符中运行 `docker ps` 命令并检查 `daprio/dapr:latest` 和 `redis` 容器镜像同时在运行。\n\n#### 安装指定运行时版本\n\n你可以安装或升级到指定版本的 Dapr 运行时，通过使用 `dapr init --runtime-version` 。在 [Dapr 发布版本](https://github.com/dapr/dapr/releases)列表中查找。\n\n``` cmd\n# Install v0.1.0 runtime\n$ dapr init --runtime-version 0.1.0\n\n# Check the versions of cli and runtime\n$ dapr --version\ncli version: v0.1.0\nruntime version: v0.1.0\n```\n\n#### 自托管模式卸载 Dapr\n\n卸载将移除放置服务的容器或放置服务的二进制文件。\n\n``` cmd\n$dapr uninstall\n```\n\n>对于 Linux 用户，如果你运行你的 docker 命令通过 sudo 或者安装路径为 `/usr/local/bin`（默认路径），你需要使用 `sudo dapr uninstall` 移除 dapr 二进制文件或者容器。\n\n默认它不会移除 Redis 或者 Zipkin 容器以防你对它们有其它用途。要移除 Redis、Zipkin 和 actor 部署容器和移除位于 `$HOME/.dapr` 或者 `%USERPROFILE%\\.dapr\\` 的默认 Dapr 目录， ，运行：\n\n``` cmd\n$dapr uninstall --all\n```\n\n你应该总在运行 `dapr init` 之前运行 `dapr uninstall` 。\n\n### 在 K8S 集群下安装 Dapr\n\n---\n\n当设置 K8S 时，你可以通过 Dapr 命令行界面或者 Helm 。\n\nDapr 安装以下 pods：\n\n- dapr-operator：管理组件更新和 Dapr K8S 服务终端（状态存储、发布-订阅、等等）\n- dapr-sidecar-injector：注入 Dapr 到已注释的部署 pods 中\n- dapr-placement：仅用于 actors ，创建映射表以映射 actor 实例到 pods 中\n- dapr-sentry：管理服务之间的 mTLS 并充当证书颁发机构\n\n#### 设置集群\n\n你可以在任何 K8S 集群安装 Dapr 。以下是一些有用的链接：\n\n- {% post_link setup-minikube Setup Minikube Cluster %}\n- {% post_link setup-aks Setup Azure Kubernetes Service Cluster %}\n- [Setup Google Cloud Kubernetes Engine](https://cloud.google.com/kubernetes-engine/docs/quickstart)\n- [Setup Amazon Elastic Kubernetes Service](https://docs.aws.amazon.com/eks/latest/userguide/getting-started.html)\n\n> 注意：Dapr 命令行界面和 Dapr Helm 图表都会自动部署具有 `kubernetes.io/os=linux` 标签关联的节点。你可以部署 Dapr 到 Windows 节点，但大多数用户应该不需要。更多信息查看 [Deploying to a Hybrid Linux/Windows K8s Cluster](https://github.com/dapr/docs/tree/master/howto/windows-k8s)\n\n#### 使用 Dapr 命令行界面\n\n你可以使用命令行界面安装 Dapr 到 K8S 集群。\n\n##### 安装 Dapr 到 K8S\n\n>注意：默认命名空间是 dapr-system\n\n``` cmd\n$ dapr init -k\n\n⌛  Making the jump to hyperspace...\nℹ️  Note: To install Dapr using Helm, see here:  https://github.com/dapr/docs/blob/master/getting-started/environment-setup.md#using-helm-advanced\n\n✅  Deploying the Dapr control plane to your cluster...\n✅  Success! Dapr has been installed to namespace dapr-system. To verify, run \"dapr status -k\" in your terminal. To get started, go here: https://aka.ms/dapr-getting-started\n```\n\n安装到自定义命名空间：\n\n``` cmd\ndapr init -k -n mynamespace\n```\n\n高可用模式安装：\n\n``` cmd\ndapr init -k --enable-ha=true\n```\n\n禁用 mTLS：\n\n``` cmd\ndapr init -k --enable-mtls=false\n```\n\n从 K8S 中卸载 Dapr\n\n``` cmd\n$dapr uninstall --kubernetes\n```\n\n#### 使用 Helm （高级）\n\n你可以使用 Helm 3 图表安装 K8S 集群。\n\n>注意：最新的 Darp helm 图表不在支持 Helm v2。请跟随[指南](https://helm.sh/blog/migrate-from-helm-v2-to-helm-v3/)迁移 helm v2 到 helm v3。\n\n##### 在 K8S 中安装 Dapr\n\n1. 确认 Helm 3 已经安装到你的机器上\n2. 添加 Azure 容器注册表做为 Helm 仓库\n\n  ``` cmd\n  helm repo add dapr https://dapr.github.io/helm-charts/\n  helm repo update\n  ```\n\n3. 在你的 K8S 集群中创建 `dapr-system` 命名空间\n\n  ``` cmd\n  kubectl create namespace dapr-system\n  ```\n\n4. 在你的集群 `dapr-system` 命名空间中安装 Dapr 图表。\n\n``` cmd\nhelm install dapr dapr/dapr --namespace dapr-system\n```\n\n##### 验证安装\n\n一旦图表完成安装，验证 dapr-operator, dapr-placement, dapr-sidecar-injector 和 dapr-sentry pods 在 `dapr-system` 命名空间中运行。\n\n``` cmd\n$ kubectl get pods -n dapr-system -w\n\nNAME                                     READY     STATUS    RESTARTS   AGE\ndapr-operator-7bd6cbf5bf-xglsr           1/1       Running   0          40s\ndapr-placement-7f8f76778f-6vhl2          1/1       Running   0          40s\ndapr-sidecar-injector-8555576b6f-29cqm   1/1       Running   0          40s\ndapr-sentry-9435776c7f-8f7yd             1/1       Running   0          40s\n```\n\n##### 边车注释\n\n要查看在 K8S 中所有 Dapr 边车支持的注释，访问[这里](https://github.com/dapr/docs/blob/master/howto/configure-k8s/README.md)查看。\n\n##### 从 K8S 中卸载 Dapr\n\nHelm3\n\n``` cmd\nhelm uninstall dapr -n dapr-system\n```\n\n> 注意：点击[这里](https://github.com/dapr/dapr/blob/master/charts/dapr/README.md)查看 Dapr helm 图表细节。","source":"_posts/environment-setup.md","raw":"---\ntitle: 环境设置\ncatalog: true\ntoc_nav_num: true\ndate: 2020-09-19 16:27:14\nsubtitle: docs/getting-started/environment-setup\nheader-img: /img/dapr/dapr.svg\ntags: \n- Dapr\n- 原文翻译\ncatagories:\n- Dapr\n---\n\n## 环境设置\n\n---\n\nDapr 既可以使用自托管模式运行也可以运行在 K8S 模式下。通过自托管模式运行 Dapr 运行时使你可以在本地开发环境开发 Dapr 应用程序，然后部署到其它支持 Dapr 运行的环境。例如：你可以在自托管模式下开发 Dapr 应用程序然后把应用程序部署到任何 K8S 集群。\n\n### 内容\n\n---\n\n- [环境设置](#环境设置)\n  - [内容](#内容)\n  - [先决条件](#先决条件)\n  - [安装 Dapr 命令行](#安装-dapr-命令行)\n    - [Windows](#windows)\n    - [Linux](#linux)\n    - [MacOS](#macos)\n    - [通过二进制版本](#通过二进制版本)\n  - [自托管模式安装 Dapr](#自托管模式安装-dapr)\n    - [使用命令行界面初始化 Dapr](#使用命令行界面初始化-dapr)\n    - [安装指定运行时版本](#安装指定运行时版本)\n    - [自托管模式卸载 Dapr](#自托管模式卸载-dapr)\n  - [在 K8S 集群下安装 Dapr](#在-k8s-集群下安装-dapr)\n    - [设置集群](#设置集群)\n    - [使用 Dapr 命令行界面](#使用-dapr-命令行界面)\n      - [安装 Dapr 到 K8S](#安装-dapr-到-k8s)\n    - [使用 Helm （高级）](#使用-helm-高级)\n      - [在 K8S 中安装 Dapr](#在-k8s-中安装-dapr)\n      - [验证安装](#验证安装)\n      - [边车注释](#边车注释)\n      - [从 K8S 中卸载 Dapr](#从-k8s-中卸载-dapr)\n\n### 先决条件\n\n---\n\n默认情况下，Dapr 使用 Docker 容器安装开发环境以便你轻松上手。然而，Dapr 不依赖 Docker 运行（查看【这里】介绍使用 Docker 轻量化初始本地安装 Dapr）。这个入门指南假设 Dapr 是和开发人员环境一起安装的。\n\n- 安装 [Docker](https://docs.docker.com/get-docker/)\n\n> Windows 用户，确保 `Docker Desktop For Windows` 使用 Linux 容器。\n\n### 安装 Dapr 命令行\n\n---\n\n使用脚本安装最新版本\n\n#### Windows\n\n安装最新的 windows Dapr 命令行界面到  `c:\\dapr` 并添加这个文件夹到 User Path 环境变量中。\n\n``` powershell\npowershell -Command \"iwr -useb https://raw.githubusercontent.com/dapr/cli/master/install/install.ps1 | iex\"\n```\n\n#### Linux\n\n安装最新的 linux Dapr 命令行界面到 `/usr/local/bin`\n\n``` bash\nwget -q https://raw.githubusercontent.com/dapr/cli/master/install/install.sh -O - | /bin/bash\n```\n\n#### MacOS\n\n安装最新的 darwin Dapr 命令行界面到 `/usr/local/bin`\n\n``` bash\ncurl -fsSL https://raw.githubusercontent.com/dapr/cli/master/install/install.sh | /bin/bash\n```\n\n或者使用 Homebrew 安装\n\n``` bash\nbrew install dapr/tap/dapr-cli\n```\n\n#### 通过二进制版本\n\nDapr 命令行界面每个发布版本都包含各种系统和架构。这些二进制版本可以手动下载和安装。\n\n1. 下载[Dapr 命令行界面](https://github.com/dapr/cli/releases)\n2. 解压（例如：dapr_linux_amd64.tar.gz, dapr_windows_amd64.zip）\n3. 把解压后文件移动到你希望的位置。\n   - Linux/MacOS - /usr/local/bin\n   - Windows，创建一个文件夹并添加文件夹路径到系统路径中。例如：创建一个文件夹 `c:\\dapr` 并把文件夹路径加入到系统环境变量中。\n\n### 自托管模式安装 Dapr\n\n---\n\n#### 使用命令行界面初始化 Dapr\n\n默认情况下，初始化 Dapr 命令行界面过程中会安装 Dapr 二进制文件，同时设置一个开发者环境以帮助你轻松上手 Dapr。这个环境使用 Docker 容器，因此 Docker 列入到先决条件中。\n\n>如果你不想使用这个环境并且不依赖 Docker 运行 Dapr，查看命令行界面[文档](https://github.com/dapr/cli/blob/master/README.md)，当使用 init 命令时同时使用 `--slim` 命令。注意，如果你时一个新手，强烈推荐安装 Docker 并且使用常规初始化（init）命令。\n>对于 Linux 用户，如果你运行 docker 命令使用 sudo 或者安装路径时 `/usr/local/bin` （默认安装路径），你需要使用“sudo dapr init”。对于 Windows 用户，确保你使用管理员模式运行命令行终端。注意：查看[Dapr 命令行界面]以了解使用 Dapr 命令行界面的细节。\n\n``` cmd\n$ dapr init\n⌛  Making the jump to hyperspace...\nDownloading binaries and setting up components\n✅  Success! Dapr is up and running. To get started, go here: https://aka.ms/dapr-getting-started\n```\n\n查看 Dapr 安装成功，从命令提示符中运行 `docker ps` 命令并检查 `daprio/dapr:latest` 和 `redis` 容器镜像同时在运行。\n\n#### 安装指定运行时版本\n\n你可以安装或升级到指定版本的 Dapr 运行时，通过使用 `dapr init --runtime-version` 。在 [Dapr 发布版本](https://github.com/dapr/dapr/releases)列表中查找。\n\n``` cmd\n# Install v0.1.0 runtime\n$ dapr init --runtime-version 0.1.0\n\n# Check the versions of cli and runtime\n$ dapr --version\ncli version: v0.1.0\nruntime version: v0.1.0\n```\n\n#### 自托管模式卸载 Dapr\n\n卸载将移除放置服务的容器或放置服务的二进制文件。\n\n``` cmd\n$dapr uninstall\n```\n\n>对于 Linux 用户，如果你运行你的 docker 命令通过 sudo 或者安装路径为 `/usr/local/bin`（默认路径），你需要使用 `sudo dapr uninstall` 移除 dapr 二进制文件或者容器。\n\n默认它不会移除 Redis 或者 Zipkin 容器以防你对它们有其它用途。要移除 Redis、Zipkin 和 actor 部署容器和移除位于 `$HOME/.dapr` 或者 `%USERPROFILE%\\.dapr\\` 的默认 Dapr 目录， ，运行：\n\n``` cmd\n$dapr uninstall --all\n```\n\n你应该总在运行 `dapr init` 之前运行 `dapr uninstall` 。\n\n### 在 K8S 集群下安装 Dapr\n\n---\n\n当设置 K8S 时，你可以通过 Dapr 命令行界面或者 Helm 。\n\nDapr 安装以下 pods：\n\n- dapr-operator：管理组件更新和 Dapr K8S 服务终端（状态存储、发布-订阅、等等）\n- dapr-sidecar-injector：注入 Dapr 到已注释的部署 pods 中\n- dapr-placement：仅用于 actors ，创建映射表以映射 actor 实例到 pods 中\n- dapr-sentry：管理服务之间的 mTLS 并充当证书颁发机构\n\n#### 设置集群\n\n你可以在任何 K8S 集群安装 Dapr 。以下是一些有用的链接：\n\n- {% post_link setup-minikube Setup Minikube Cluster %}\n- {% post_link setup-aks Setup Azure Kubernetes Service Cluster %}\n- [Setup Google Cloud Kubernetes Engine](https://cloud.google.com/kubernetes-engine/docs/quickstart)\n- [Setup Amazon Elastic Kubernetes Service](https://docs.aws.amazon.com/eks/latest/userguide/getting-started.html)\n\n> 注意：Dapr 命令行界面和 Dapr Helm 图表都会自动部署具有 `kubernetes.io/os=linux` 标签关联的节点。你可以部署 Dapr 到 Windows 节点，但大多数用户应该不需要。更多信息查看 [Deploying to a Hybrid Linux/Windows K8s Cluster](https://github.com/dapr/docs/tree/master/howto/windows-k8s)\n\n#### 使用 Dapr 命令行界面\n\n你可以使用命令行界面安装 Dapr 到 K8S 集群。\n\n##### 安装 Dapr 到 K8S\n\n>注意：默认命名空间是 dapr-system\n\n``` cmd\n$ dapr init -k\n\n⌛  Making the jump to hyperspace...\nℹ️  Note: To install Dapr using Helm, see here:  https://github.com/dapr/docs/blob/master/getting-started/environment-setup.md#using-helm-advanced\n\n✅  Deploying the Dapr control plane to your cluster...\n✅  Success! Dapr has been installed to namespace dapr-system. To verify, run \"dapr status -k\" in your terminal. To get started, go here: https://aka.ms/dapr-getting-started\n```\n\n安装到自定义命名空间：\n\n``` cmd\ndapr init -k -n mynamespace\n```\n\n高可用模式安装：\n\n``` cmd\ndapr init -k --enable-ha=true\n```\n\n禁用 mTLS：\n\n``` cmd\ndapr init -k --enable-mtls=false\n```\n\n从 K8S 中卸载 Dapr\n\n``` cmd\n$dapr uninstall --kubernetes\n```\n\n#### 使用 Helm （高级）\n\n你可以使用 Helm 3 图表安装 K8S 集群。\n\n>注意：最新的 Darp helm 图表不在支持 Helm v2。请跟随[指南](https://helm.sh/blog/migrate-from-helm-v2-to-helm-v3/)迁移 helm v2 到 helm v3。\n\n##### 在 K8S 中安装 Dapr\n\n1. 确认 Helm 3 已经安装到你的机器上\n2. 添加 Azure 容器注册表做为 Helm 仓库\n\n  ``` cmd\n  helm repo add dapr https://dapr.github.io/helm-charts/\n  helm repo update\n  ```\n\n3. 在你的 K8S 集群中创建 `dapr-system` 命名空间\n\n  ``` cmd\n  kubectl create namespace dapr-system\n  ```\n\n4. 在你的集群 `dapr-system` 命名空间中安装 Dapr 图表。\n\n``` cmd\nhelm install dapr dapr/dapr --namespace dapr-system\n```\n\n##### 验证安装\n\n一旦图表完成安装，验证 dapr-operator, dapr-placement, dapr-sidecar-injector 和 dapr-sentry pods 在 `dapr-system` 命名空间中运行。\n\n``` cmd\n$ kubectl get pods -n dapr-system -w\n\nNAME                                     READY     STATUS    RESTARTS   AGE\ndapr-operator-7bd6cbf5bf-xglsr           1/1       Running   0          40s\ndapr-placement-7f8f76778f-6vhl2          1/1       Running   0          40s\ndapr-sidecar-injector-8555576b6f-29cqm   1/1       Running   0          40s\ndapr-sentry-9435776c7f-8f7yd             1/1       Running   0          40s\n```\n\n##### 边车注释\n\n要查看在 K8S 中所有 Dapr 边车支持的注释，访问[这里](https://github.com/dapr/docs/blob/master/howto/configure-k8s/README.md)查看。\n\n##### 从 K8S 中卸载 Dapr\n\nHelm3\n\n``` cmd\nhelm uninstall dapr -n dapr-system\n```\n\n> 注意：点击[这里](https://github.com/dapr/dapr/blob/master/charts/dapr/README.md)查看 Dapr helm 图表细节。","slug":"environment-setup","published":1,"updated":"2020-11-06T03:53:15.316Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh8qmyho00064x6y2ou8jxgq","content":"<h2 id=\"环境设置\">环境设置</h2>\n<hr>\n<p>Dapr 既可以使用自托管模式运行也可以运行在 K8S 模式下。通过自托管模式运行 Dapr 运行时使你可以在本地开发环境开发 Dapr 应用程序，然后部署到其它支持 Dapr 运行的环境。例如：你可以在自托管模式下开发 Dapr 应用程序然后把应用程序部署到任何 K8S 集群。</p>\n<h3 id=\"内容\">内容</h3>\n<hr>\n<ul>\n<li><a href=\"#%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE\">环境设置</a>\n<ul>\n<li><a href=\"#%E5%86%85%E5%AE%B9\">内容</a></li>\n<li><a href=\"#%E5%85%88%E5%86%B3%E6%9D%A1%E4%BB%B6\">先决条件</a></li>\n<li><a href=\"#%E5%AE%89%E8%A3%85-dapr-%E5%91%BD%E4%BB%A4%E8%A1%8C\">安装 Dapr 命令行</a>\n<ul>\n<li><a href=\"#windows\">Windows</a></li>\n<li><a href=\"#linux\">Linux</a></li>\n<li><a href=\"#macos\">MacOS</a></li>\n<li><a href=\"#%E9%80%9A%E8%BF%87%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%89%88%E6%9C%AC\">通过二进制版本</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%87%AA%E6%89%98%E7%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%89%E8%A3%85-dapr\">自托管模式安装 Dapr</a>\n<ul>\n<li><a href=\"#%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2%E5%88%9D%E5%A7%8B%E5%8C%96-dapr\">使用命令行界面初始化 Dapr</a></li>\n<li><a href=\"#%E5%AE%89%E8%A3%85%E6%8C%87%E5%AE%9A%E8%BF%90%E8%A1%8C%E6%97%B6%E7%89%88%E6%9C%AC\">安装指定运行时版本</a></li>\n<li><a href=\"#%E8%87%AA%E6%89%98%E7%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%B8%E8%BD%BD-dapr\">自托管模式卸载 Dapr</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%9C%A8-k8s-%E9%9B%86%E7%BE%A4%E4%B8%8B%E5%AE%89%E8%A3%85-dapr\">在 K8S 集群下安装 Dapr</a>\n<ul>\n<li><a href=\"#%E8%AE%BE%E7%BD%AE%E9%9B%86%E7%BE%A4\">设置集群</a></li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8-dapr-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2\">使用 Dapr 命令行界面</a>\n<ul>\n<li><a href=\"#%E5%AE%89%E8%A3%85-dapr-%E5%88%B0-k8s\">安装 Dapr 到 K8S</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8-helm-%E9%AB%98%E7%BA%A7\">使用 Helm （高级）</a>\n<ul>\n<li><a href=\"#%E5%9C%A8-k8s-%E4%B8%AD%E5%AE%89%E8%A3%85-dapr\">在 K8S 中安装 Dapr</a></li>\n<li><a href=\"#%E9%AA%8C%E8%AF%81%E5%AE%89%E8%A3%85\">验证安装</a></li>\n<li><a href=\"#%E8%BE%B9%E8%BD%A6%E6%B3%A8%E9%87%8A\">边车注释</a></li>\n<li><a href=\"#%E4%BB%8E-k8s-%E4%B8%AD%E5%8D%B8%E8%BD%BD-dapr\">从 K8S 中卸载 Dapr</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"先决条件\">先决条件</h3>\n<hr>\n<p>默认情况下，Dapr 使用 Docker 容器安装开发环境以便你轻松上手。然而，Dapr 不依赖 Docker 运行（查看【这里】介绍使用 Docker 轻量化初始本地安装 Dapr）。这个入门指南假设 Dapr 是和开发人员环境一起安装的。</p>\n<ul>\n<li>安装 <a href=\"https://docs.docker.com/get-docker/\" target=\"_blank\" rel=\"noopener\">Docker</a></li>\n</ul>\n<blockquote>\n<p>Windows 用户，确保 <code>Docker Desktop For Windows</code> 使用 Linux 容器。</p>\n</blockquote>\n<h3 id=\"安装-dapr-命令行\">安装 Dapr 命令行</h3>\n<hr>\n<p>使用脚本安装最新版本</p>\n<h4 id=\"windows\">Windows</h4>\n<p>安装最新的 windows Dapr 命令行界面到  <code>c:\\dapr</code> 并添加这个文件夹到 User Path 环境变量中。</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">powershell -Command <span class=\"string\">\"iwr -useb https://raw.githubusercontent.com/dapr/cli/master/install/install.ps1 | iex\"</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"linux\">Linux</h4>\n<p>安装最新的 linux Dapr 命令行界面到 <code>/usr/local/bin</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -q https://raw.githubusercontent.com/dapr/cli/master/install/install.sh -O - | /bin/bash</span><br></pre></td></tr></table></figure>\n<h4 id=\"macos\">MacOS</h4>\n<p>安装最新的 darwin Dapr 命令行界面到 <code>/usr/local/bin</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -fsSL https://raw.githubusercontent.com/dapr/cli/master/install/install.sh | /bin/bash</span><br></pre></td></tr></table></figure>\n<p>或者使用 Homebrew 安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install dapr/tap/dapr-cli</span><br></pre></td></tr></table></figure>\n<h4 id=\"通过二进制版本\">通过二进制版本</h4>\n<p>Dapr 命令行界面每个发布版本都包含各种系统和架构。这些二进制版本可以手动下载和安装。</p>\n<ol>\n<li>下载<a href=\"https://github.com/dapr/cli/releases\" target=\"_blank\" rel=\"noopener\">Dapr 命令行界面</a></li>\n<li>解压（例如：dapr_linux_amd64.tar.gz, dapr_windows_amd64.zip）</li>\n<li>把解压后文件移动到你希望的位置。\n<ul>\n<li>Linux/MacOS - /usr/local/bin</li>\n<li>Windows，创建一个文件夹并添加文件夹路径到系统路径中。例如：创建一个文件夹 <code>c:\\dapr</code> 并把文件夹路径加入到系统环境变量中。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"自托管模式安装-dapr\">自托管模式安装 Dapr</h3>\n<hr>\n<h4 id=\"使用命令行界面初始化-dapr\">使用命令行界面初始化 Dapr</h4>\n<p>默认情况下，初始化 Dapr 命令行界面过程中会安装 Dapr 二进制文件，同时设置一个开发者环境以帮助你轻松上手 Dapr。这个环境使用 Docker 容器，因此 Docker 列入到先决条件中。</p>\n<blockquote>\n<p>如果你不想使用这个环境并且不依赖 Docker 运行 Dapr，查看命令行界面<a href=\"https://github.com/dapr/cli/blob/master/README.md\" target=\"_blank\" rel=\"noopener\">文档</a>，当使用 init 命令时同时使用 <code>--slim</code> 命令。注意，如果你时一个新手，强烈推荐安装 Docker 并且使用常规初始化（init）命令。<br>\n对于 Linux 用户，如果你运行 docker 命令使用 sudo 或者安装路径时 <code>/usr/local/bin</code> （默认安装路径），你需要使用“sudo dapr init”。对于 Windows 用户，确保你使用管理员模式运行命令行终端。注意：查看[Dapr 命令行界面]以了解使用 Dapr 命令行界面的细节。</p>\n</blockquote>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ dapr init</span><br><span class=\"line\">⌛  Making the jump to hyperspace...</span><br><span class=\"line\">Downloading binaries and setting up components</span><br><span class=\"line\">✅  Success! Dapr is up and running. To get started, go here: https://aka.ms/dapr-getting-started</span><br></pre></td></tr></table></figure>\n<p>查看 Dapr 安装成功，从命令提示符中运行 <code>docker ps</code> 命令并检查 <code>daprio/dapr:latest</code> 和 <code>redis</code> 容器镜像同时在运行。</p>\n<h4 id=\"安装指定运行时版本\">安装指定运行时版本</h4>\n<p>你可以安装或升级到指定版本的 Dapr 运行时，通过使用 <code>dapr init --runtime-version</code> 。在 <a href=\"https://github.com/dapr/dapr/releases\" target=\"_blank\" rel=\"noopener\">Dapr 发布版本</a>列表中查找。</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Install v0.<span class=\"number\">1</span>.<span class=\"number\">0</span> runtime</span><br><span class=\"line\">$ dapr init --runtime-version <span class=\"number\">0</span>.<span class=\"number\">1</span>.<span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"># Check the versions of cli and runtime</span><br><span class=\"line\">$ dapr --version</span><br><span class=\"line\">cli version: v0.<span class=\"number\">1</span>.<span class=\"number\">0</span></span><br><span class=\"line\">runtime version: v0.<span class=\"number\">1</span>.<span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"自托管模式卸载-dapr\">自托管模式卸载 Dapr</h4>\n<p>卸载将移除放置服务的容器或放置服务的二进制文件。</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$dapr uninstall</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>对于 Linux 用户，如果你运行你的 docker 命令通过 sudo 或者安装路径为 <code>/usr/local/bin</code>（默认路径），你需要使用 <code>sudo dapr uninstall</code> 移除 dapr 二进制文件或者容器。</p>\n</blockquote>\n<p>默认它不会移除 Redis 或者 Zipkin 容器以防你对它们有其它用途。要移除 Redis、Zipkin 和 actor 部署容器和移除位于 <code>$HOME/.dapr</code> 或者 <code>%USERPROFILE%\\.dapr\\</code> 的默认 Dapr 目录， ，运行：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$dapr uninstall --all</span><br></pre></td></tr></table></figure>\n<p>你应该总在运行 <code>dapr init</code> 之前运行 <code>dapr uninstall</code> 。</p>\n<h3 id=\"在-k8s-集群下安装-dapr\">在 K8S 集群下安装 Dapr</h3>\n<hr>\n<p>当设置 K8S 时，你可以通过 Dapr 命令行界面或者 Helm 。</p>\n<p>Dapr 安装以下 pods：</p>\n<ul>\n<li>dapr-operator：管理组件更新和 Dapr K8S 服务终端（状态存储、发布-订阅、等等）</li>\n<li>dapr-sidecar-injector：注入 Dapr 到已注释的部署 pods 中</li>\n<li>dapr-placement：仅用于 actors ，创建映射表以映射 actor 实例到 pods 中</li>\n<li>dapr-sentry：管理服务之间的 mTLS 并充当证书颁发机构</li>\n</ul>\n<h4 id=\"设置集群\">设置集群</h4>\n<p>你可以在任何 K8S 集群安装 Dapr 。以下是一些有用的链接：</p>\n<ul>\n<li>\n<a href=\"/article/setup-minikube/\" title=\"Setup Minikube Cluster\">Setup Minikube Cluster</a>\n</li>\n<li>\n<a href=\"/article/setup-aks/\" title=\"Setup Azure Kubernetes Service Cluster\">Setup Azure Kubernetes Service Cluster</a>\n</li>\n<li><a href=\"https://cloud.google.com/kubernetes-engine/docs/quickstart\" target=\"_blank\" rel=\"noopener\">Setup Google Cloud Kubernetes Engine</a></li>\n<li><a href=\"https://docs.aws.amazon.com/eks/latest/userguide/getting-started.html\" target=\"_blank\" rel=\"noopener\">Setup Amazon Elastic Kubernetes Service</a></li>\n</ul>\n<blockquote>\n<p>注意：Dapr 命令行界面和 Dapr Helm 图表都会自动部署具有 <code>kubernetes.io/os=linux</code> 标签关联的节点。你可以部署 Dapr 到 Windows 节点，但大多数用户应该不需要。更多信息查看 <a href=\"https://github.com/dapr/docs/tree/master/howto/windows-k8s\" target=\"_blank\" rel=\"noopener\">Deploying to a Hybrid Linux/Windows K8s Cluster</a></p>\n</blockquote>\n<h4 id=\"使用-dapr-命令行界面\">使用 Dapr 命令行界面</h4>\n<p>你可以使用命令行界面安装 Dapr 到 K8S 集群。</p>\n<h5 id=\"安装-dapr-到-k8s\">安装 Dapr 到 K8S</h5>\n<blockquote>\n<p>注意：默认命名空间是 dapr-system</p>\n</blockquote>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ dapr init -k</span><br><span class=\"line\"></span><br><span class=\"line\">⌛  Making the jump to hyperspace...</span><br><span class=\"line\">ℹ️  Note: To install Dapr using Helm, see here:  https://github.com/dapr/docs/blob/master/getting-started/environment-setup.<span class=\"built_in\">md</span>#using-helm-advanced</span><br><span class=\"line\"></span><br><span class=\"line\">✅  Deploying the Dapr control plane to your cluster...</span><br><span class=\"line\">✅  Success! Dapr has been installed to namespace dapr-system. To <span class=\"built_in\">verify</span>, run \"dapr status -k\" <span class=\"keyword\">in</span> your terminal. To get started, go here: https://aka.ms/dapr-getting-started</span><br></pre></td></tr></table></figure>\n<p>安装到自定义命名空间：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dapr init -k -n mynamespace</span><br></pre></td></tr></table></figure>\n<p>高可用模式安装：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dapr init -k --enable-ha=true</span><br></pre></td></tr></table></figure>\n<p>禁用 mTLS：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dapr init -k --enable-mtls=false</span><br></pre></td></tr></table></figure>\n<p>从 K8S 中卸载 Dapr</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$dapr uninstall --kubernetes</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用-helm-高级\">使用 Helm （高级）</h4>\n<p>你可以使用 Helm 3 图表安装 K8S 集群。</p>\n<blockquote>\n<p>注意：最新的 Darp helm 图表不在支持 Helm v2。请跟随<a href=\"https://helm.sh/blog/migrate-from-helm-v2-to-helm-v3/\" target=\"_blank\" rel=\"noopener\">指南</a>迁移 helm v2 到 helm v3。</p>\n</blockquote>\n<h5 id=\"在-k8s-中安装-dapr\">在 K8S 中安装 Dapr</h5>\n<ol>\n<li>确认 Helm 3 已经安装到你的机器上</li>\n<li>添加 Azure 容器注册表做为 Helm 仓库</li>\n</ol>\n  <figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm repo add dapr https://dapr.github.io/helm-charts/</span><br><span class=\"line\">helm repo update</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>在你的 K8S 集群中创建 <code>dapr-system</code> 命名空间</li>\n</ol>\n  <figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create namespace dapr-system</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>在你的集群 <code>dapr-system</code> 命名空间中安装 Dapr 图表。</li>\n</ol>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm install dapr dapr/dapr --namespace dapr-system</span><br></pre></td></tr></table></figure>\n<h5 id=\"验证安装\">验证安装</h5>\n<p>一旦图表完成安装，验证 dapr-operator, dapr-placement, dapr-sidecar-injector 和 dapr-sentry pods 在 <code>dapr-system</code> 命名空间中运行。</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl get pods -n dapr-system -w</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                                     READY     STATUS    RESTARTS   AGE</span><br><span class=\"line\">dapr-operator-<span class=\"number\">7</span>bd6cbf5bf-xglsr           <span class=\"number\">1</span>/<span class=\"number\">1</span>       Running   <span class=\"number\">0</span>          <span class=\"number\">40</span>s</span><br><span class=\"line\">dapr-placement-<span class=\"number\">7</span>f8f76778f-<span class=\"number\">6</span>vhl2          <span class=\"number\">1</span>/<span class=\"number\">1</span>       Running   <span class=\"number\">0</span>          <span class=\"number\">40</span>s</span><br><span class=\"line\">dapr-sidecar-injector-<span class=\"number\">8555576</span>b6f-<span class=\"number\">29</span>cqm   <span class=\"number\">1</span>/<span class=\"number\">1</span>       Running   <span class=\"number\">0</span>          <span class=\"number\">40</span>s</span><br><span class=\"line\">dapr-sentry-<span class=\"number\">9435776</span>c7f-<span class=\"number\">8</span>f7yd             <span class=\"number\">1</span>/<span class=\"number\">1</span>       Running   <span class=\"number\">0</span>          <span class=\"number\">40</span>s</span><br></pre></td></tr></table></figure>\n<h5 id=\"边车注释\">边车注释</h5>\n<p>要查看在 K8S 中所有 Dapr 边车支持的注释，访问<a href=\"https://github.com/dapr/docs/blob/master/howto/configure-k8s/README.md\" target=\"_blank\" rel=\"noopener\">这里</a>查看。</p>\n<h5 id=\"从-k8s-中卸载-dapr\">从 K8S 中卸载 Dapr</h5>\n<p>Helm3</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm uninstall dapr -n dapr-system</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：点击<a href=\"https://github.com/dapr/dapr/blob/master/charts/dapr/README.md\" target=\"_blank\" rel=\"noopener\">这里</a>查看 Dapr helm 图表细节。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2>环境设置</h2>\n<hr>\n<p>Dapr 既可以使用自托管模式运行也可以运行在 K8S 模式下。通过自托管模式运行 Dapr 运行时使你可以在本地开发环境开发 Dapr 应用程序，然后部署到其它支持 Dapr 运行的环境。例如：你可以在自托管模式下开发 Dapr 应用程序然后把应用程序部署到任何 K8S 集群。</p>\n<h3>内容</h3>\n<hr>\n<ul>\n<li><a href=\"#%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE\">环境设置</a>\n<ul>\n<li><a href=\"#%E5%86%85%E5%AE%B9\">内容</a></li>\n<li><a href=\"#%E5%85%88%E5%86%B3%E6%9D%A1%E4%BB%B6\">先决条件</a></li>\n<li><a href=\"#%E5%AE%89%E8%A3%85-dapr-%E5%91%BD%E4%BB%A4%E8%A1%8C\">安装 Dapr 命令行</a>\n<ul>\n<li><a href=\"#windows\">Windows</a></li>\n<li><a href=\"#linux\">Linux</a></li>\n<li><a href=\"#macos\">MacOS</a></li>\n<li><a href=\"#%E9%80%9A%E8%BF%87%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%89%88%E6%9C%AC\">通过二进制版本</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%87%AA%E6%89%98%E7%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%89%E8%A3%85-dapr\">自托管模式安装 Dapr</a>\n<ul>\n<li><a href=\"#%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2%E5%88%9D%E5%A7%8B%E5%8C%96-dapr\">使用命令行界面初始化 Dapr</a></li>\n<li><a href=\"#%E5%AE%89%E8%A3%85%E6%8C%87%E5%AE%9A%E8%BF%90%E8%A1%8C%E6%97%B6%E7%89%88%E6%9C%AC\">安装指定运行时版本</a></li>\n<li><a href=\"#%E8%87%AA%E6%89%98%E7%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%B8%E8%BD%BD-dapr\">自托管模式卸载 Dapr</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%9C%A8-k8s-%E9%9B%86%E7%BE%A4%E4%B8%8B%E5%AE%89%E8%A3%85-dapr\">在 K8S 集群下安装 Dapr</a>\n<ul>\n<li><a href=\"#%E8%AE%BE%E7%BD%AE%E9%9B%86%E7%BE%A4\">设置集群</a></li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8-dapr-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2\">使用 Dapr 命令行界面</a>\n<ul>\n<li><a href=\"#%E5%AE%89%E8%A3%85-dapr-%E5%88%B0-k8s\">安装 Dapr 到 K8S</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8-helm-%E9%AB%98%E7%BA%A7\">使用 Helm （高级）</a>\n<ul>\n<li><a href=\"#%E5%9C%A8-k8s-%E4%B8%AD%E5%AE%89%E8%A3%85-dapr\">在 K8S 中安装 Dapr</a></li>\n<li><a href=\"#%E9%AA%8C%E8%AF%81%E5%AE%89%E8%A3%85\">验证安装</a></li>\n<li><a href=\"#%E8%BE%B9%E8%BD%A6%E6%B3%A8%E9%87%8A\">边车注释</a></li>\n<li><a href=\"#%E4%BB%8E-k8s-%E4%B8%AD%E5%8D%B8%E8%BD%BD-dapr\">从 K8S 中卸载 Dapr</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3>先决条件</h3>\n<hr>\n<p>默认情况下，Dapr 使用 Docker 容器安装开发环境以便你轻松上手。然而，Dapr 不依赖 Docker 运行（查看【这里】介绍使用 Docker 轻量化初始本地安装 Dapr）。这个入门指南假设 Dapr 是和开发人员环境一起安装的。</p>\n<ul>\n<li>安装 <a href=\"https://docs.docker.com/get-docker/\" target=\"_blank\" rel=\"noopener\">Docker</a></li>\n</ul>\n<blockquote>\n<p>Windows 用户，确保 <code>Docker Desktop For Windows</code> 使用 Linux 容器。</p>\n</blockquote>\n<h3>安装 Dapr 命令行</h3>\n<hr>\n<p>使用脚本安装最新版本</p>\n<h4>Windows</h4>\n<p>安装最新的 windows Dapr 命令行界面到  <code>c:\\dapr</code> 并添加这个文件夹到 User Path 环境变量中。</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">powershell -Command <span class=\"string\">\"iwr -useb https://raw.githubusercontent.com/dapr/cli/master/install/install.ps1 | iex\"</span></span><br></pre></td></tr></table></figure>\n<h4>Linux</h4>\n<p>安装最新的 linux Dapr 命令行界面到 <code>/usr/local/bin</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -q https://raw.githubusercontent.com/dapr/cli/master/install/install.sh -O - | /bin/bash</span><br></pre></td></tr></table></figure>\n<h4>MacOS</h4>\n<p>安装最新的 darwin Dapr 命令行界面到 <code>/usr/local/bin</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -fsSL https://raw.githubusercontent.com/dapr/cli/master/install/install.sh | /bin/bash</span><br></pre></td></tr></table></figure>\n<p>或者使用 Homebrew 安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install dapr/tap/dapr-cli</span><br></pre></td></tr></table></figure>\n<h4>通过二进制版本</h4>\n<p>Dapr 命令行界面每个发布版本都包含各种系统和架构。这些二进制版本可以手动下载和安装。</p>\n<ol>\n<li>下载<a href=\"https://github.com/dapr/cli/releases\" target=\"_blank\" rel=\"noopener\">Dapr 命令行界面</a></li>\n<li>解压（例如：dapr_linux_amd64.tar.gz, dapr_windows_amd64.zip）</li>\n<li>把解压后文件移动到你希望的位置。\n<ul>\n<li>Linux/MacOS - /usr/local/bin</li>\n<li>Windows，创建一个文件夹并添加文件夹路径到系统路径中。例如：创建一个文件夹 <code>c:\\dapr</code> 并把文件夹路径加入到系统环境变量中。</li>\n</ul>\n</li>\n</ol>\n<h3>自托管模式安装 Dapr</h3>\n<hr>\n<h4>使用命令行界面初始化 Dapr</h4>\n<p>默认情况下，初始化 Dapr 命令行界面过程中会安装 Dapr 二进制文件，同时设置一个开发者环境以帮助你轻松上手 Dapr。这个环境使用 Docker 容器，因此 Docker 列入到先决条件中。</p>\n<blockquote>\n<p>如果你不想使用这个环境并且不依赖 Docker 运行 Dapr，查看命令行界面<a href=\"https://github.com/dapr/cli/blob/master/README.md\" target=\"_blank\" rel=\"noopener\">文档</a>，当使用 init 命令时同时使用 <code>--slim</code> 命令。注意，如果你时一个新手，强烈推荐安装 Docker 并且使用常规初始化（init）命令。<br>\n对于 Linux 用户，如果你运行 docker 命令使用 sudo 或者安装路径时 <code>/usr/local/bin</code> （默认安装路径），你需要使用“sudo dapr init”。对于 Windows 用户，确保你使用管理员模式运行命令行终端。注意：查看[Dapr 命令行界面]以了解使用 Dapr 命令行界面的细节。</p>\n</blockquote>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ dapr init</span><br><span class=\"line\">⌛  Making the jump to hyperspace...</span><br><span class=\"line\">Downloading binaries and setting up components</span><br><span class=\"line\">✅  Success! Dapr is up and running. To get started, go here: https://aka.ms/dapr-getting-started</span><br></pre></td></tr></table></figure>\n<p>查看 Dapr 安装成功，从命令提示符中运行 <code>docker ps</code> 命令并检查 <code>daprio/dapr:latest</code> 和 <code>redis</code> 容器镜像同时在运行。</p>\n<h4>安装指定运行时版本</h4>\n<p>你可以安装或升级到指定版本的 Dapr 运行时，通过使用 <code>dapr init --runtime-version</code> 。在 <a href=\"https://github.com/dapr/dapr/releases\" target=\"_blank\" rel=\"noopener\">Dapr 发布版本</a>列表中查找。</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Install v0.<span class=\"number\">1</span>.<span class=\"number\">0</span> runtime</span><br><span class=\"line\">$ dapr init --runtime-version <span class=\"number\">0</span>.<span class=\"number\">1</span>.<span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"># Check the versions of cli and runtime</span><br><span class=\"line\">$ dapr --version</span><br><span class=\"line\">cli version: v0.<span class=\"number\">1</span>.<span class=\"number\">0</span></span><br><span class=\"line\">runtime version: v0.<span class=\"number\">1</span>.<span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h4>自托管模式卸载 Dapr</h4>\n<p>卸载将移除放置服务的容器或放置服务的二进制文件。</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$dapr uninstall</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>对于 Linux 用户，如果你运行你的 docker 命令通过 sudo 或者安装路径为 <code>/usr/local/bin</code>（默认路径），你需要使用 <code>sudo dapr uninstall</code> 移除 dapr 二进制文件或者容器。</p>\n</blockquote>\n<p>默认它不会移除 Redis 或者 Zipkin 容器以防你对它们有其它用途。要移除 Redis、Zipkin 和 actor 部署容器和移除位于 <code>$HOME/.dapr</code> 或者 <code>%USERPROFILE%\\.dapr\\</code> 的默认 Dapr 目录， ，运行：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$dapr uninstall --all</span><br></pre></td></tr></table></figure>\n<p>你应该总在运行 <code>dapr init</code> 之前运行 <code>dapr uninstall</code> 。</p>\n<h3>在 K8S 集群下安装 Dapr</h3>\n<hr>\n<p>当设置 K8S 时，你可以通过 Dapr 命令行界面或者 Helm 。</p>\n<p>Dapr 安装以下 pods：</p>\n<ul>\n<li>dapr-operator：管理组件更新和 Dapr K8S 服务终端（状态存储、发布-订阅、等等）</li>\n<li>dapr-sidecar-injector：注入 Dapr 到已注释的部署 pods 中</li>\n<li>dapr-placement：仅用于 actors ，创建映射表以映射 actor 实例到 pods 中</li>\n<li>dapr-sentry：管理服务之间的 mTLS 并充当证书颁发机构</li>\n</ul>\n<h4>设置集群</h4>\n<p>你可以在任何 K8S 集群安装 Dapr 。以下是一些有用的链接：</p>\n<ul>\n<li>\n<a href=\"/article/setup-minikube/\" title=\"Setup Minikube Cluster\">Setup Minikube Cluster</a>\n</li>\n<li>\n<a href=\"/article/setup-aks/\" title=\"Setup Azure Kubernetes Service Cluster\">Setup Azure Kubernetes Service Cluster</a>\n</li>\n<li><a href=\"https://cloud.google.com/kubernetes-engine/docs/quickstart\" target=\"_blank\" rel=\"noopener\">Setup Google Cloud Kubernetes Engine</a></li>\n<li><a href=\"https://docs.aws.amazon.com/eks/latest/userguide/getting-started.html\" target=\"_blank\" rel=\"noopener\">Setup Amazon Elastic Kubernetes Service</a></li>\n</ul>\n<blockquote>\n<p>注意：Dapr 命令行界面和 Dapr Helm 图表都会自动部署具有 <code>kubernetes.io/os=linux</code> 标签关联的节点。你可以部署 Dapr 到 Windows 节点，但大多数用户应该不需要。更多信息查看 <a href=\"https://github.com/dapr/docs/tree/master/howto/windows-k8s\" target=\"_blank\" rel=\"noopener\">Deploying to a Hybrid Linux/Windows K8s Cluster</a></p>\n</blockquote>\n<h4>使用 Dapr 命令行界面</h4>\n<p>你可以使用命令行界面安装 Dapr 到 K8S 集群。</p>\n<h5>安装 Dapr 到 K8S</h5>\n<blockquote>\n<p>注意：默认命名空间是 dapr-system</p>\n</blockquote>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ dapr init -k</span><br><span class=\"line\"></span><br><span class=\"line\">⌛  Making the jump to hyperspace...</span><br><span class=\"line\">ℹ️  Note: To install Dapr using Helm, see here:  https://github.com/dapr/docs/blob/master/getting-started/environment-setup.<span class=\"built_in\">md</span>#using-helm-advanced</span><br><span class=\"line\"></span><br><span class=\"line\">✅  Deploying the Dapr control plane to your cluster...</span><br><span class=\"line\">✅  Success! Dapr has been installed to namespace dapr-system. To <span class=\"built_in\">verify</span>, run \"dapr status -k\" <span class=\"keyword\">in</span> your terminal. To get started, go here: https://aka.ms/dapr-getting-started</span><br></pre></td></tr></table></figure>\n<p>安装到自定义命名空间：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dapr init -k -n mynamespace</span><br></pre></td></tr></table></figure>\n<p>高可用模式安装：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dapr init -k --enable-ha=true</span><br></pre></td></tr></table></figure>\n<p>禁用 mTLS：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dapr init -k --enable-mtls=false</span><br></pre></td></tr></table></figure>\n<p>从 K8S 中卸载 Dapr</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$dapr uninstall --kubernetes</span><br></pre></td></tr></table></figure>\n<h4>使用 Helm （高级）</h4>\n<p>你可以使用 Helm 3 图表安装 K8S 集群。</p>\n<blockquote>\n<p>注意：最新的 Darp helm 图表不在支持 Helm v2。请跟随<a href=\"https://helm.sh/blog/migrate-from-helm-v2-to-helm-v3/\" target=\"_blank\" rel=\"noopener\">指南</a>迁移 helm v2 到 helm v3。</p>\n</blockquote>\n<h5>在 K8S 中安装 Dapr</h5>\n<ol>\n<li>确认 Helm 3 已经安装到你的机器上</li>\n<li>添加 Azure 容器注册表做为 Helm 仓库</li>\n</ol>\n  <figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm repo add dapr https://dapr.github.io/helm-charts/</span><br><span class=\"line\">helm repo update</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>在你的 K8S 集群中创建 <code>dapr-system</code> 命名空间</li>\n</ol>\n  <figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create namespace dapr-system</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>在你的集群 <code>dapr-system</code> 命名空间中安装 Dapr 图表。</li>\n</ol>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm install dapr dapr/dapr --namespace dapr-system</span><br></pre></td></tr></table></figure>\n<h5>验证安装</h5>\n<p>一旦图表完成安装，验证 dapr-operator, dapr-placement, dapr-sidecar-injector 和 dapr-sentry pods 在 <code>dapr-system</code> 命名空间中运行。</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl get pods -n dapr-system -w</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                                     READY     STATUS    RESTARTS   AGE</span><br><span class=\"line\">dapr-operator-<span class=\"number\">7</span>bd6cbf5bf-xglsr           <span class=\"number\">1</span>/<span class=\"number\">1</span>       Running   <span class=\"number\">0</span>          <span class=\"number\">40</span>s</span><br><span class=\"line\">dapr-placement-<span class=\"number\">7</span>f8f76778f-<span class=\"number\">6</span>vhl2          <span class=\"number\">1</span>/<span class=\"number\">1</span>       Running   <span class=\"number\">0</span>          <span class=\"number\">40</span>s</span><br><span class=\"line\">dapr-sidecar-injector-<span class=\"number\">8555576</span>b6f-<span class=\"number\">29</span>cqm   <span class=\"number\">1</span>/<span class=\"number\">1</span>       Running   <span class=\"number\">0</span>          <span class=\"number\">40</span>s</span><br><span class=\"line\">dapr-sentry-<span class=\"number\">9435776</span>c7f-<span class=\"number\">8</span>f7yd             <span class=\"number\">1</span>/<span class=\"number\">1</span>       Running   <span class=\"number\">0</span>          <span class=\"number\">40</span>s</span><br></pre></td></tr></table></figure>\n<h5>边车注释</h5>\n<p>要查看在 K8S 中所有 Dapr 边车支持的注释，访问<a href=\"https://github.com/dapr/docs/blob/master/howto/configure-k8s/README.md\" target=\"_blank\" rel=\"noopener\">这里</a>查看。</p>\n<h5>从 K8S 中卸载 Dapr</h5>\n<p>Helm3</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm uninstall dapr -n dapr-system</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：点击<a href=\"https://github.com/dapr/dapr/blob/master/charts/dapr/README.md\" target=\"_blank\" rel=\"noopener\">这里</a>查看 Dapr helm 图表细节。</p>\n</blockquote>\n"},{"title":"入门","catalog":true,"toc_nav_num":true,"date":"2020-09-17T07:05:58.000Z","subtitle":"docs/getting-started","header-img":"/img/dapr/dapr.svg","catagories":["Dapr"],"_content":"\n## 入门\n\n---\n\napr（Distributed Application Runtime） 是一个可移植的（portable）、事件驱动（event-driven）的运行时框架。开发者通过 Dapr 可以构建弹性、无状态、有状态的运行在云上和边缘的微服务。并且拥抱开发语言和开发框架的多样性。\n\n### 核心概念\n\n---\n\n- **构建块**是一个实现分布式系统能力的组件集，比如：pub/sub，状态管理、资源绑定和分布式追踪。\n- **组建**是构建块 API 的封装实现。例如状态构建块实现可能包含 Redis、Azure Storage、Azure Cosmos DB 和 AWS DynamoDB。很多组件都是可插拔的，所以一个实现可以替换为另一个。\n\n查看 Dapr 概念 了解更多信息。\n\n### 设置开发环境\n\n---\n\nDapr 可以在本地或者 K8S 上运行。我们推荐从本地设置开始探索 Dapr 核心概念并且熟悉 Dapr CLI。跟随这些指令{% post_link environment-setup 配置本地和 K8S Dapr %}。\n\n## 下一步\n\n---\n\n1. 安装完 Dapr 后，查看[Hello World 快速开始]以继续。\n2. 探索其它[快速开始]了解更多高级概念，比如：服务调用、发布/订阅、状态管理。\n3. 跟随[如何引导]了解 Dapr 如何解决指定问题，比如创建一个[限速应用]。\n","source":"_posts/getting-started.md","raw":"---\ntitle: 入门\ncatalog: true\ntoc_nav_num: true\ndate: 2020-09-17 15:05:58\nsubtitle: docs/getting-started\nheader-img: /img/dapr/dapr.svg\ntags: \n- Dapr\n- 原文翻译\ncatagories:\n- Dapr\n---\n\n## 入门\n\n---\n\napr（Distributed Application Runtime） 是一个可移植的（portable）、事件驱动（event-driven）的运行时框架。开发者通过 Dapr 可以构建弹性、无状态、有状态的运行在云上和边缘的微服务。并且拥抱开发语言和开发框架的多样性。\n\n### 核心概念\n\n---\n\n- **构建块**是一个实现分布式系统能力的组件集，比如：pub/sub，状态管理、资源绑定和分布式追踪。\n- **组建**是构建块 API 的封装实现。例如状态构建块实现可能包含 Redis、Azure Storage、Azure Cosmos DB 和 AWS DynamoDB。很多组件都是可插拔的，所以一个实现可以替换为另一个。\n\n查看 Dapr 概念 了解更多信息。\n\n### 设置开发环境\n\n---\n\nDapr 可以在本地或者 K8S 上运行。我们推荐从本地设置开始探索 Dapr 核心概念并且熟悉 Dapr CLI。跟随这些指令{% post_link environment-setup 配置本地和 K8S Dapr %}。\n\n## 下一步\n\n---\n\n1. 安装完 Dapr 后，查看[Hello World 快速开始]以继续。\n2. 探索其它[快速开始]了解更多高级概念，比如：服务调用、发布/订阅、状态管理。\n3. 跟随[如何引导]了解 Dapr 如何解决指定问题，比如创建一个[限速应用]。\n","slug":"getting-started","published":1,"updated":"2020-11-06T03:53:15.317Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh8qmyhp00074x6y5bps6sc6","content":"<h2 id=\"入门\">入门</h2>\n<hr>\n<p>apr（Distributed Application Runtime） 是一个可移植的（portable）、事件驱动（event-driven）的运行时框架。开发者通过 Dapr 可以构建弹性、无状态、有状态的运行在云上和边缘的微服务。并且拥抱开发语言和开发框架的多样性。</p>\n<h3 id=\"核心概念\">核心概念</h3>\n<hr>\n<ul>\n<li><strong>构建块</strong>是一个实现分布式系统能力的组件集，比如：pub/sub，状态管理、资源绑定和分布式追踪。</li>\n<li><strong>组建</strong>是构建块 API 的封装实现。例如状态构建块实现可能包含 Redis、Azure Storage、Azure Cosmos DB 和 AWS DynamoDB。很多组件都是可插拔的，所以一个实现可以替换为另一个。</li>\n</ul>\n<p>查看 Dapr 概念 了解更多信息。</p>\n<h3 id=\"设置开发环境\">设置开发环境</h3>\n<hr>\n<p>Dapr 可以在本地或者 K8S 上运行。我们推荐从本地设置开始探索 Dapr 核心概念并且熟悉 Dapr CLI。跟随这些指令<a href=\"/article/environment-setup/\" title=\"配置本地和 K8S Dapr\">配置本地和 K8S Dapr</a>。</p>\n<h2 id=\"下一步\">下一步</h2>\n<hr>\n<ol>\n<li>安装完 Dapr 后，查看[Hello World 快速开始]以继续。</li>\n<li>探索其它[快速开始]了解更多高级概念，比如：服务调用、发布/订阅、状态管理。</li>\n<li>跟随[如何引导]了解 Dapr 如何解决指定问题，比如创建一个[限速应用]。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2>入门</h2>\n<hr>\n<p>apr（Distributed Application Runtime） 是一个可移植的（portable）、事件驱动（event-driven）的运行时框架。开发者通过 Dapr 可以构建弹性、无状态、有状态的运行在云上和边缘的微服务。并且拥抱开发语言和开发框架的多样性。</p>\n<h3>核心概念</h3>\n<hr>\n<ul>\n<li><strong>构建块</strong>是一个实现分布式系统能力的组件集，比如：pub/sub，状态管理、资源绑定和分布式追踪。</li>\n<li><strong>组建</strong>是构建块 API 的封装实现。例如状态构建块实现可能包含 Redis、Azure Storage、Azure Cosmos DB 和 AWS DynamoDB。很多组件都是可插拔的，所以一个实现可以替换为另一个。</li>\n</ul>\n<p>查看 Dapr 概念 了解更多信息。</p>\n<h3>设置开发环境</h3>\n<hr>\n<p>Dapr 可以在本地或者 K8S 上运行。我们推荐从本地设置开始探索 Dapr 核心概念并且熟悉 Dapr CLI。跟随这些指令<a href=\"/article/environment-setup/\" title=\"配置本地和 K8S Dapr\">配置本地和 K8S Dapr</a>。</p>\n<h2>下一步</h2>\n<hr>\n<ol>\n<li>安装完 Dapr 后，查看[Hello World 快速开始]以继续。</li>\n<li>探索其它[快速开始]了解更多高级概念，比如：服务调用、发布/订阅、状态管理。</li>\n<li>跟随[如何引导]了解 Dapr 如何解决指定问题，比如创建一个[限速应用]。</li>\n</ol>\n"},{"title":"Dapr Golang HTTP 调用","catalog":true,"toc_nav_num":true,"date":"2020-11-04T01:37:41.000Z","subtitle":"go_invoke_http","header-img":"/img/golang/golang.jpeg","catagories":["Go"],"_content":"\n## 版本介绍\n\n- Go 版本：1.15\n- Dapr Go SKD 版本：0.11.1\n\n## 工程结构\n\n![工程结构](/img/golang/1.png)\n\n从上图可知，新建 3 个 Go 启动项目,cmd 为启动项目目录，其中 client/a/main.go 为客户端，用于调用服务。service/http/b、service/http/c 为服务项目。调用路径如下图所示。新建两个 service 的意义在于展示 http 链路调用通过 dapr 如何实现。\n\n```mermaid\ngraph LR;\n    go-client-a--1-->go-service-b;\n    go-service-b--2-->go-service-c;\n    go-service-c--3-->go-service-b;\n    go-service-b--4-->go-client-a;\n```\n\n1. go-client-a 做为客户端调用服务 go-service-b;\n2. go-service-b 做为服务中转，既收来自 go-client-a 客户端的请求，又发起对 go-service-c 的调用;\n3. go-service-c 响应 go-service-b 的请求；\n4. go-service-b 响应 go-client-a 的请求。\n\n### internal\n\nresponse.go 文件，封装返回数据。数据结构如下：\n\n``` go\npackage internal\n\nimport (\n\t\"encoding/json\"\n\t\"log\"\n)\n\ntype HttpResult struct {\n\tMessage string\n}\n\nfunc (r *HttpResult) ToBytes() (bytes []byte) {\n\tvar err error\n\tbytes, err = json.Marshal(r)\n\tif err != nil {\n\t\tlog.Fatal(\"数据转换失败\")\n\t}\n\treturn\n}\n```\n\n## go-service-c\n\ngo-service-c 做为调用链路末端，只需要提供监听端口，以及绑定路由。下面方法通过 `s.AddServiceInvocationHandler(\"/hello\", helloHandler)` 方法绑定路由和处理方法。以下为 go-service-c 源码。\n\n``` go\npackage main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"github.com/Zhang-Byte/dapr-golang/internal\"\n\t\"github.com/dapr/go-sdk/service/common\"\n\tdaprd \"github.com/dapr/go-sdk/service/http\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\ts := daprd.NewService(\":9003\")\n\tif err := s.AddServiceInvocationHandler(\"/hello\", helloHandler); err != nil {\n\t\tlog.Fatalf(\"error adding invocation handler: %v\", err)\n\t}\n\n\tif err := s.Start(); err != nil && err != http.ErrServerClosed {\n\t\tlog.Fatalf(\"error listenning: %v\", err)\n\t}\n}\n\nfunc helloHandler(_ context.Context, in *common.InvocationEvent) (out *common.Content, err error) {\n\tif in == nil {\n\t\terr = errors.New(\"invocation parameter required\")\n\t\treturn\n\t}\n\tlog.Printf(\"The go-service-c service method hello has been invoked,recieve message is %v\", string(in.Data))\n\thttpResult := internal.HttpResult{Message: \"This message is from Service C.\"}\n\tout = &common.Content{\n\t\tData:        httpResult.ToBytes(),\n\t\tContentType: in.ContentType,\n\t\tDataTypeURL: in.DataTypeURL,\n\t}\n\treturn\n}\n```\n\n启动命令：\n\n``` cmd\ndapr run --app-id go-service-c \\\n         --app-protocol http \\\n         --app-port 9003 \\\n         --dapr-http-port 3501 \\\n         --log-level debug \\\n         --components-path ./config \\\n         go run ./cmd/service/http/c/main.go\n```\n\n## go-service-b\n\ngo-service-b 相较于 go-service-c 的代码来说，添加了初始化客户端并发送请求的内容。查看代码 `invokeService()` 每次都会调用 `client()`,在 `client()` 中方法看上去每次都会新建一个客户端，查看 dapr 源码注释可知(Note, this default factory function creates Dapr client only once. All subsequent invocations will return the already created instance. ) 每次只会返回已经创建好的实例，因此使用完以后不必关闭此客户端。\n\n``` go\npackage main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"github.com/Zhang-Byte/dapr-golang/internal\"\n\tdapr \"github.com/dapr/go-sdk/client\"\n\t\"github.com/dapr/go-sdk/service/common\"\n\t\"log\"\n\t\"net/http\"\n)\nimport daprd \"github.com/dapr/go-sdk/service/http\"\n\nfunc main() {\n\ts := daprd.NewService(\":9002\")\n\tif err := s.AddServiceInvocationHandler(\"/hello\", helloHandler); err != nil {\n\t\tlog.Fatalf(\"error adding invocation handler: %v\", err)\n\t}\n\n\tif err := s.Start(); err != nil && err != http.ErrServerClosed {\n\t\tlog.Fatalf(\"error listenning: %v\", err)\n\t}\n}\n\nfunc helloHandler(ctx context.Context, in *common.InvocationEvent) (out *common.Content, err error) {\n\tif in == nil {\n\t\terr = errors.New(\"invocation parameter required\")\n\t\treturn\n\t}\n\tlog.Printf(\"The go-service-b service method hello has been invoked,recieve message is %v\", string(in.Data))\n\n\tmsg := invokeService(ctx)\n\thttpResult := internal.HttpResult{Message: msg}\n\n\tout = &common.Content{\n\t\tData:        httpResult.ToBytes(),\n\t\tContentType: in.ContentType,\n\t\tDataTypeURL: in.DataTypeURL,\n\t}\n\treturn\n}\n\nfunc invokeService(ctx context.Context) (msg string) {\n\tclient := client()\n\tcontent := &dapr.DataContent{\n\t\tContentType: \"text/plain\",\n\t\tData:        []byte(\"This is golang Service B.\"),\n\t}\n\tresp, err := client.InvokeServiceWithContent(ctx, \"go-service-c\", \"hello\", content)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tvar result internal.HttpResult\n\tif err := json.Unmarshal(resp, &result); err != nil {\n\t\tlog.Printf(err.Error())\n\t}\n\tmsg = result.Message\n\treturn\n}\n\nfunc client() dapr.Client {\n\tclient, err := dapr.NewClient()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn client\n}\n```\n\n启动命令：\n\n``` cmd\ndapr run --app-id go-service-b \\\n         --app-protocol http \\\n         --app-port 9002 \\\n         --dapr-http-port 3500 \\\n         --log-level debug \\\n         --components-path ./config \\\n         go run ./cmd/service/http/b/main.go\n```\n\n## go-client-a\n\n最后创建客户端，客户端每间隔 5 秒发起一次请求到 go-service-b 。\n\n``` go\npackage main\n\nimport (\n\t\"context\"\n\tdapr \"github.com/dapr/go-sdk/client\"\n\t\"log\"\n\t\"time\"\n)\n\nfunc main() {\n\tctx := context.Background()\n\n\t// create the client\n\tclient, err := dapr.NewClient()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer client.Close()\n\n\tcontent := &dapr.DataContent{\n\t\tContentType: \"text/plain\",\n\t\tData:        []byte(\"This is client A.\"),\n\t}\n\tfor {\n\t\tresp, err := client.InvokeServiceWithContent(ctx, \"go-service-b\", \"hello\", content)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tlog.Printf(\"go-service-b method hello has invoked, response: %s\", string(resp))\n\n\t\ttime.Sleep(time.Second * 5)\n\t}\n\n}\n```\n\n启动命令：\n\n``` cmd\ndapr run --app-id go-client-a \\\n         --components-path ./config \\\n         --log-level debug \\\n         go run ./cmd/client/a/main.go\n```\n\n## 总结\n\nclient 启动后，得到返回值\n\n``` cmd\n== APP == 2020/11/06 11:26:41 go-service-b method hello has invoked, response: {\"Message\":\"This message is from Service C.\"}\n```\n\ngo-service-b 打印内容为：\n\n``` cmd\n== APP == 2020/11/06 11:31:51 The go-service-b service has been invoked,recieve message is This is client A.\n```\n\ngo-service-c 打印内容为：\n\n``` cmd\n== APP == 2020/11/06 11:33:31 The go-service-c service method hello has been invoked,recieve message is This is golang Service B.\n```\n\n在命令行界面中输入 `dapr dashboard` 得到输出 `Dapr Dashboard running on http://localhost:8080`，访问 `http://localhost:8080`\n\n![dashboard](/img/golang/2.png)\n\n源码地址：https://github.com/ZhangX-Byte/dapr-golang","source":"_posts/go-invoke-http.md","raw":"---\ntitle: Dapr Golang HTTP 调用\ncatalog: true\ntoc_nav_num: true\ndate: 2020-11-04 09:37:41\nsubtitle: go_invoke_http\nheader-img: /img/golang/golang.jpeg\ntags: \n- Dapr\n- Go\ncatagories:\n- Go\n---\n\n## 版本介绍\n\n- Go 版本：1.15\n- Dapr Go SKD 版本：0.11.1\n\n## 工程结构\n\n![工程结构](/img/golang/1.png)\n\n从上图可知，新建 3 个 Go 启动项目,cmd 为启动项目目录，其中 client/a/main.go 为客户端，用于调用服务。service/http/b、service/http/c 为服务项目。调用路径如下图所示。新建两个 service 的意义在于展示 http 链路调用通过 dapr 如何实现。\n\n```mermaid\ngraph LR;\n    go-client-a--1-->go-service-b;\n    go-service-b--2-->go-service-c;\n    go-service-c--3-->go-service-b;\n    go-service-b--4-->go-client-a;\n```\n\n1. go-client-a 做为客户端调用服务 go-service-b;\n2. go-service-b 做为服务中转，既收来自 go-client-a 客户端的请求，又发起对 go-service-c 的调用;\n3. go-service-c 响应 go-service-b 的请求；\n4. go-service-b 响应 go-client-a 的请求。\n\n### internal\n\nresponse.go 文件，封装返回数据。数据结构如下：\n\n``` go\npackage internal\n\nimport (\n\t\"encoding/json\"\n\t\"log\"\n)\n\ntype HttpResult struct {\n\tMessage string\n}\n\nfunc (r *HttpResult) ToBytes() (bytes []byte) {\n\tvar err error\n\tbytes, err = json.Marshal(r)\n\tif err != nil {\n\t\tlog.Fatal(\"数据转换失败\")\n\t}\n\treturn\n}\n```\n\n## go-service-c\n\ngo-service-c 做为调用链路末端，只需要提供监听端口，以及绑定路由。下面方法通过 `s.AddServiceInvocationHandler(\"/hello\", helloHandler)` 方法绑定路由和处理方法。以下为 go-service-c 源码。\n\n``` go\npackage main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"github.com/Zhang-Byte/dapr-golang/internal\"\n\t\"github.com/dapr/go-sdk/service/common\"\n\tdaprd \"github.com/dapr/go-sdk/service/http\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\ts := daprd.NewService(\":9003\")\n\tif err := s.AddServiceInvocationHandler(\"/hello\", helloHandler); err != nil {\n\t\tlog.Fatalf(\"error adding invocation handler: %v\", err)\n\t}\n\n\tif err := s.Start(); err != nil && err != http.ErrServerClosed {\n\t\tlog.Fatalf(\"error listenning: %v\", err)\n\t}\n}\n\nfunc helloHandler(_ context.Context, in *common.InvocationEvent) (out *common.Content, err error) {\n\tif in == nil {\n\t\terr = errors.New(\"invocation parameter required\")\n\t\treturn\n\t}\n\tlog.Printf(\"The go-service-c service method hello has been invoked,recieve message is %v\", string(in.Data))\n\thttpResult := internal.HttpResult{Message: \"This message is from Service C.\"}\n\tout = &common.Content{\n\t\tData:        httpResult.ToBytes(),\n\t\tContentType: in.ContentType,\n\t\tDataTypeURL: in.DataTypeURL,\n\t}\n\treturn\n}\n```\n\n启动命令：\n\n``` cmd\ndapr run --app-id go-service-c \\\n         --app-protocol http \\\n         --app-port 9003 \\\n         --dapr-http-port 3501 \\\n         --log-level debug \\\n         --components-path ./config \\\n         go run ./cmd/service/http/c/main.go\n```\n\n## go-service-b\n\ngo-service-b 相较于 go-service-c 的代码来说，添加了初始化客户端并发送请求的内容。查看代码 `invokeService()` 每次都会调用 `client()`,在 `client()` 中方法看上去每次都会新建一个客户端，查看 dapr 源码注释可知(Note, this default factory function creates Dapr client only once. All subsequent invocations will return the already created instance. ) 每次只会返回已经创建好的实例，因此使用完以后不必关闭此客户端。\n\n``` go\npackage main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"github.com/Zhang-Byte/dapr-golang/internal\"\n\tdapr \"github.com/dapr/go-sdk/client\"\n\t\"github.com/dapr/go-sdk/service/common\"\n\t\"log\"\n\t\"net/http\"\n)\nimport daprd \"github.com/dapr/go-sdk/service/http\"\n\nfunc main() {\n\ts := daprd.NewService(\":9002\")\n\tif err := s.AddServiceInvocationHandler(\"/hello\", helloHandler); err != nil {\n\t\tlog.Fatalf(\"error adding invocation handler: %v\", err)\n\t}\n\n\tif err := s.Start(); err != nil && err != http.ErrServerClosed {\n\t\tlog.Fatalf(\"error listenning: %v\", err)\n\t}\n}\n\nfunc helloHandler(ctx context.Context, in *common.InvocationEvent) (out *common.Content, err error) {\n\tif in == nil {\n\t\terr = errors.New(\"invocation parameter required\")\n\t\treturn\n\t}\n\tlog.Printf(\"The go-service-b service method hello has been invoked,recieve message is %v\", string(in.Data))\n\n\tmsg := invokeService(ctx)\n\thttpResult := internal.HttpResult{Message: msg}\n\n\tout = &common.Content{\n\t\tData:        httpResult.ToBytes(),\n\t\tContentType: in.ContentType,\n\t\tDataTypeURL: in.DataTypeURL,\n\t}\n\treturn\n}\n\nfunc invokeService(ctx context.Context) (msg string) {\n\tclient := client()\n\tcontent := &dapr.DataContent{\n\t\tContentType: \"text/plain\",\n\t\tData:        []byte(\"This is golang Service B.\"),\n\t}\n\tresp, err := client.InvokeServiceWithContent(ctx, \"go-service-c\", \"hello\", content)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tvar result internal.HttpResult\n\tif err := json.Unmarshal(resp, &result); err != nil {\n\t\tlog.Printf(err.Error())\n\t}\n\tmsg = result.Message\n\treturn\n}\n\nfunc client() dapr.Client {\n\tclient, err := dapr.NewClient()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn client\n}\n```\n\n启动命令：\n\n``` cmd\ndapr run --app-id go-service-b \\\n         --app-protocol http \\\n         --app-port 9002 \\\n         --dapr-http-port 3500 \\\n         --log-level debug \\\n         --components-path ./config \\\n         go run ./cmd/service/http/b/main.go\n```\n\n## go-client-a\n\n最后创建客户端，客户端每间隔 5 秒发起一次请求到 go-service-b 。\n\n``` go\npackage main\n\nimport (\n\t\"context\"\n\tdapr \"github.com/dapr/go-sdk/client\"\n\t\"log\"\n\t\"time\"\n)\n\nfunc main() {\n\tctx := context.Background()\n\n\t// create the client\n\tclient, err := dapr.NewClient()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer client.Close()\n\n\tcontent := &dapr.DataContent{\n\t\tContentType: \"text/plain\",\n\t\tData:        []byte(\"This is client A.\"),\n\t}\n\tfor {\n\t\tresp, err := client.InvokeServiceWithContent(ctx, \"go-service-b\", \"hello\", content)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tlog.Printf(\"go-service-b method hello has invoked, response: %s\", string(resp))\n\n\t\ttime.Sleep(time.Second * 5)\n\t}\n\n}\n```\n\n启动命令：\n\n``` cmd\ndapr run --app-id go-client-a \\\n         --components-path ./config \\\n         --log-level debug \\\n         go run ./cmd/client/a/main.go\n```\n\n## 总结\n\nclient 启动后，得到返回值\n\n``` cmd\n== APP == 2020/11/06 11:26:41 go-service-b method hello has invoked, response: {\"Message\":\"This message is from Service C.\"}\n```\n\ngo-service-b 打印内容为：\n\n``` cmd\n== APP == 2020/11/06 11:31:51 The go-service-b service has been invoked,recieve message is This is client A.\n```\n\ngo-service-c 打印内容为：\n\n``` cmd\n== APP == 2020/11/06 11:33:31 The go-service-c service method hello has been invoked,recieve message is This is golang Service B.\n```\n\n在命令行界面中输入 `dapr dashboard` 得到输出 `Dapr Dashboard running on http://localhost:8080`，访问 `http://localhost:8080`\n\n![dashboard](/img/golang/2.png)\n\n源码地址：https://github.com/ZhangX-Byte/dapr-golang","slug":"go-invoke-http","published":1,"updated":"2020-11-08T02:32:53.336Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh8qmyhr00084x6yq7qpfl15","content":"<h2 id=\"版本介绍\">版本介绍</h2>\n<ul>\n<li>Go 版本：1.15</li>\n<li>Dapr Go SKD 版本：0.11.1</li>\n</ul>\n<h2 id=\"工程结构\">工程结构</h2>\n<p><img src=\"/img/golang/1.png\" alt=\"工程结构\"></p>\n<p>从上图可知，新建 3 个 Go 启动项目,cmd 为启动项目目录，其中 client/a/main.go 为客户端，用于调用服务。service/http/b、service/http/c 为服务项目。调用路径如下图所示。新建两个 service 的意义在于展示 http 链路调用通过 dapr 如何实现。</p>\n<pre class=\"mermaid\">graph LR;\n    go-client-a--1-->go-service-b;\n    go-service-b--2-->go-service-c;\n    go-service-c--3-->go-service-b;\n    go-service-b--4-->go-client-a;</pre>\n<ol>\n<li>go-client-a 做为客户端调用服务 go-service-b;</li>\n<li>go-service-b 做为服务中转，既收来自 go-client-a 客户端的请求，又发起对 go-service-c 的调用;</li>\n<li>go-service-c 响应 go-service-b 的请求；</li>\n<li>go-service-b 响应 go-client-a 的请求。</li>\n</ol>\n<h3 id=\"internal\">internal</h3>\n<p>response.go 文件，封装返回数据。数据结构如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> internal</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"encoding/json\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"log\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> HttpResult <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tMessage <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r *HttpResult)</span> <span class=\"title\">ToBytes</span><span class=\"params\">()</span> <span class=\"params\">(bytes []<span class=\"keyword\">byte</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> err error</span><br><span class=\"line\">\tbytes, err = json.Marshal(r)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(<span class=\"string\">\"数据转换失败\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"go-service-c\">go-service-c</h2>\n<p>go-service-c 做为调用链路末端，只需要提供监听端口，以及绑定路由。下面方法通过 <code>s.AddServiceInvocationHandler(&quot;/hello&quot;, helloHandler)</code> 方法绑定路由和处理方法。以下为 go-service-c 源码。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"context\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"errors\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"github.com/Zhang-Byte/dapr-golang/internal\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"github.com/dapr/go-sdk/service/common\"</span></span><br><span class=\"line\">\tdaprd <span class=\"string\">\"github.com/dapr/go-sdk/service/http\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"log\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"net/http\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ts := daprd.NewService(<span class=\"string\">\":9003\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := s.AddServiceInvocationHandler(<span class=\"string\">\"/hello\"</span>, helloHandler); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatalf(<span class=\"string\">\"error adding invocation handler: %v\"</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := s.Start(); err != <span class=\"literal\">nil</span> &amp;&amp; err != http.ErrServerClosed &#123;</span><br><span class=\"line\">\t\tlog.Fatalf(<span class=\"string\">\"error listenning: %v\"</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">helloHandler</span><span class=\"params\">(_ context.Context, in *common.InvocationEvent)</span> <span class=\"params\">(out *common.Content, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> in == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\terr = errors.New(<span class=\"string\">\"invocation parameter required\"</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlog.Printf(<span class=\"string\">\"The go-service-c service method hello has been invoked,recieve message is %v\"</span>, <span class=\"keyword\">string</span>(in.Data))</span><br><span class=\"line\">\thttpResult := internal.HttpResult&#123;Message: <span class=\"string\">\"This message is from Service C.\"</span>&#125;</span><br><span class=\"line\">\tout = &amp;common.Content&#123;</span><br><span class=\"line\">\t\tData:        httpResult.ToBytes(),</span><br><span class=\"line\">\t\tContentType: in.ContentType,</span><br><span class=\"line\">\t\tDataTypeURL: in.DataTypeURL,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>启动命令：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dapr run --app-id go-service-c \\</span><br><span class=\"line\">         --app-protocol http \\</span><br><span class=\"line\">         --app-port <span class=\"number\">9003</span> \\</span><br><span class=\"line\">         --dapr-http-port <span class=\"number\">3501</span> \\</span><br><span class=\"line\">         --log-level debug \\</span><br><span class=\"line\">         --components-<span class=\"built_in\">path</span> ./config \\</span><br><span class=\"line\">         go run ./<span class=\"built_in\">cmd</span>/service/http/c/main.go</span><br></pre></td></tr></table></figure>\n<h2 id=\"go-service-b\">go-service-b</h2>\n<p>go-service-b 相较于 go-service-c 的代码来说，添加了初始化客户端并发送请求的内容。查看代码 <code>invokeService()</code> 每次都会调用 <code>client()</code>,在 <code>client()</code> 中方法看上去每次都会新建一个客户端，查看 dapr 源码注释可知(Note, this default factory function creates Dapr client only once. All subsequent invocations will return the already created instance. ) 每次只会返回已经创建好的实例，因此使用完以后不必关闭此客户端。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"context\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"encoding/json\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"errors\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"github.com/Zhang-Byte/dapr-golang/internal\"</span></span><br><span class=\"line\">\tdapr <span class=\"string\">\"github.com/dapr/go-sdk/client\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"github.com/dapr/go-sdk/service/common\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"log\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"net/http\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">import</span> daprd <span class=\"string\">\"github.com/dapr/go-sdk/service/http\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ts := daprd.NewService(<span class=\"string\">\":9002\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := s.AddServiceInvocationHandler(<span class=\"string\">\"/hello\"</span>, helloHandler); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatalf(<span class=\"string\">\"error adding invocation handler: %v\"</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := s.Start(); err != <span class=\"literal\">nil</span> &amp;&amp; err != http.ErrServerClosed &#123;</span><br><span class=\"line\">\t\tlog.Fatalf(<span class=\"string\">\"error listenning: %v\"</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">helloHandler</span><span class=\"params\">(ctx context.Context, in *common.InvocationEvent)</span> <span class=\"params\">(out *common.Content, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> in == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\terr = errors.New(<span class=\"string\">\"invocation parameter required\"</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlog.Printf(<span class=\"string\">\"The go-service-b service method hello has been invoked,recieve message is %v\"</span>, <span class=\"keyword\">string</span>(in.Data))</span><br><span class=\"line\"></span><br><span class=\"line\">\tmsg := invokeService(ctx)</span><br><span class=\"line\">\thttpResult := internal.HttpResult&#123;Message: msg&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tout = &amp;common.Content&#123;</span><br><span class=\"line\">\t\tData:        httpResult.ToBytes(),</span><br><span class=\"line\">\t\tContentType: in.ContentType,</span><br><span class=\"line\">\t\tDataTypeURL: in.DataTypeURL,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">invokeService</span><span class=\"params\">(ctx context.Context)</span> <span class=\"params\">(msg <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\tclient := client()</span><br><span class=\"line\">\tcontent := &amp;dapr.DataContent&#123;</span><br><span class=\"line\">\t\tContentType: <span class=\"string\">\"text/plain\"</span>,</span><br><span class=\"line\">\t\tData:        []<span class=\"keyword\">byte</span>(<span class=\"string\">\"This is golang Service B.\"</span>),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tresp, err := client.InvokeServiceWithContent(ctx, <span class=\"string\">\"go-service-c\"</span>, <span class=\"string\">\"hello\"</span>, content)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> result internal.HttpResult</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := json.Unmarshal(resp, &amp;result); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Printf(err.Error())</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmsg = result.Message</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">client</span><span class=\"params\">()</span> <span class=\"title\">dapr</span>.<span class=\"title\">Client</span></span> &#123;</span><br><span class=\"line\">\tclient, err := dapr.NewClient()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> client</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>启动命令：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dapr run --app-id go-service-b \\</span><br><span class=\"line\">         --app-protocol http \\</span><br><span class=\"line\">         --app-port <span class=\"number\">9002</span> \\</span><br><span class=\"line\">         --dapr-http-port <span class=\"number\">3500</span> \\</span><br><span class=\"line\">         --log-level debug \\</span><br><span class=\"line\">         --components-<span class=\"built_in\">path</span> ./config \\</span><br><span class=\"line\">         go run ./<span class=\"built_in\">cmd</span>/service/http/b/main.go</span><br></pre></td></tr></table></figure>\n<h2 id=\"go-client-a\">go-client-a</h2>\n<p>最后创建客户端，客户端每间隔 5 秒发起一次请求到 go-service-b 。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"context\"</span></span><br><span class=\"line\">\tdapr <span class=\"string\">\"github.com/dapr/go-sdk/client\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"log\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"time\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tctx := context.Background()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// create the client</span></span><br><span class=\"line\">\tclient, err := dapr.NewClient()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> client.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">\tcontent := &amp;dapr.DataContent&#123;</span><br><span class=\"line\">\t\tContentType: <span class=\"string\">\"text/plain\"</span>,</span><br><span class=\"line\">\t\tData:        []<span class=\"keyword\">byte</span>(<span class=\"string\">\"This is client A.\"</span>),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\tresp, err := client.InvokeServiceWithContent(ctx, <span class=\"string\">\"go-service-b\"</span>, <span class=\"string\">\"hello\"</span>, content)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tlog.Printf(<span class=\"string\">\"go-service-b method hello has invoked, response: %s\"</span>, <span class=\"keyword\">string</span>(resp))</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttime.Sleep(time.Second * <span class=\"number\">5</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>启动命令：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dapr run --app-id go-client-a \\</span><br><span class=\"line\">         --components-<span class=\"built_in\">path</span> ./config \\</span><br><span class=\"line\">         --log-level debug \\</span><br><span class=\"line\">         go run ./<span class=\"built_in\">cmd</span>/client/a/main.go</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\">总结</h2>\n<p>client 启动后，得到返回值</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">== APP == <span class=\"number\">2020</span>/<span class=\"number\">11</span>/<span class=\"number\">06</span> <span class=\"number\">11</span>:<span class=\"number\">26</span>:<span class=\"number\">41</span> go-service-b method hello has invoked, response: &#123;\"Message\":\"This message is from Service C.\"&#125;</span><br></pre></td></tr></table></figure>\n<p>go-service-b 打印内容为：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">== APP == <span class=\"number\">2020</span>/<span class=\"number\">11</span>/<span class=\"number\">06</span> <span class=\"number\">11</span>:<span class=\"number\">31</span>:<span class=\"number\">51</span> The go-service-b service has been invoked,recieve message is This is client A.</span><br></pre></td></tr></table></figure>\n<p>go-service-c 打印内容为：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">== APP == <span class=\"number\">2020</span>/<span class=\"number\">11</span>/<span class=\"number\">06</span> <span class=\"number\">11</span>:<span class=\"number\">33</span>:<span class=\"number\">31</span> The go-service-c service method hello has been invoked,recieve message is This is golang Service B.</span><br></pre></td></tr></table></figure>\n<p>在命令行界面中输入 <code>dapr dashboard</code> 得到输出 <code>Dapr Dashboard running on http://localhost:8080</code>，访问 <code>http://localhost:8080</code></p>\n<p><img src=\"/img/golang/2.png\" alt=\"dashboard\"></p>\n<p>源码地址：<a href=\"https://github.com/ZhangX-Byte/dapr-golang\" target=\"_blank\" rel=\"noopener\">https://github.com/ZhangX-Byte/dapr-golang</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2>版本介绍</h2>\n<ul>\n<li>Go 版本：1.15</li>\n<li>Dapr Go SKD 版本：0.11.1</li>\n</ul>\n<h2>工程结构</h2>\n<p><img src=\"/img/golang/1.png\" alt=\"工程结构\"></p>\n<p>从上图可知，新建 3 个 Go 启动项目,cmd 为启动项目目录，其中 client/a/main.go 为客户端，用于调用服务。service/http/b、service/http/c 为服务项目。调用路径如下图所示。新建两个 service 的意义在于展示 http 链路调用通过 dapr 如何实现。</p>\n<pre class=\"mermaid\">graph LR;\n    go-client-a--1-->go-service-b;\n    go-service-b--2-->go-service-c;\n    go-service-c--3-->go-service-b;\n    go-service-b--4-->go-client-a;</pre>\n<ol>\n<li>go-client-a 做为客户端调用服务 go-service-b;</li>\n<li>go-service-b 做为服务中转，既收来自 go-client-a 客户端的请求，又发起对 go-service-c 的调用;</li>\n<li>go-service-c 响应 go-service-b 的请求；</li>\n<li>go-service-b 响应 go-client-a 的请求。</li>\n</ol>\n<h3>internal</h3>\n<p>response.go 文件，封装返回数据。数据结构如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> internal</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"encoding/json\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"log\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> HttpResult <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tMessage <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r *HttpResult)</span> <span class=\"title\">ToBytes</span><span class=\"params\">()</span> <span class=\"params\">(bytes []<span class=\"keyword\">byte</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> err error</span><br><span class=\"line\">\tbytes, err = json.Marshal(r)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(<span class=\"string\">\"数据转换失败\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>go-service-c</h2>\n<p>go-service-c 做为调用链路末端，只需要提供监听端口，以及绑定路由。下面方法通过 <code>s.AddServiceInvocationHandler(&quot;/hello&quot;, helloHandler)</code> 方法绑定路由和处理方法。以下为 go-service-c 源码。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"context\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"errors\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"github.com/Zhang-Byte/dapr-golang/internal\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"github.com/dapr/go-sdk/service/common\"</span></span><br><span class=\"line\">\tdaprd <span class=\"string\">\"github.com/dapr/go-sdk/service/http\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"log\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"net/http\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ts := daprd.NewService(<span class=\"string\">\":9003\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := s.AddServiceInvocationHandler(<span class=\"string\">\"/hello\"</span>, helloHandler); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatalf(<span class=\"string\">\"error adding invocation handler: %v\"</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := s.Start(); err != <span class=\"literal\">nil</span> &amp;&amp; err != http.ErrServerClosed &#123;</span><br><span class=\"line\">\t\tlog.Fatalf(<span class=\"string\">\"error listenning: %v\"</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">helloHandler</span><span class=\"params\">(_ context.Context, in *common.InvocationEvent)</span> <span class=\"params\">(out *common.Content, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> in == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\terr = errors.New(<span class=\"string\">\"invocation parameter required\"</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlog.Printf(<span class=\"string\">\"The go-service-c service method hello has been invoked,recieve message is %v\"</span>, <span class=\"keyword\">string</span>(in.Data))</span><br><span class=\"line\">\thttpResult := internal.HttpResult&#123;Message: <span class=\"string\">\"This message is from Service C.\"</span>&#125;</span><br><span class=\"line\">\tout = &amp;common.Content&#123;</span><br><span class=\"line\">\t\tData:        httpResult.ToBytes(),</span><br><span class=\"line\">\t\tContentType: in.ContentType,</span><br><span class=\"line\">\t\tDataTypeURL: in.DataTypeURL,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>启动命令：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dapr run --app-id go-service-c \\</span><br><span class=\"line\">         --app-protocol http \\</span><br><span class=\"line\">         --app-port <span class=\"number\">9003</span> \\</span><br><span class=\"line\">         --dapr-http-port <span class=\"number\">3501</span> \\</span><br><span class=\"line\">         --log-level debug \\</span><br><span class=\"line\">         --components-<span class=\"built_in\">path</span> ./config \\</span><br><span class=\"line\">         go run ./<span class=\"built_in\">cmd</span>/service/http/c/main.go</span><br></pre></td></tr></table></figure>\n<h2>go-service-b</h2>\n<p>go-service-b 相较于 go-service-c 的代码来说，添加了初始化客户端并发送请求的内容。查看代码 <code>invokeService()</code> 每次都会调用 <code>client()</code>,在 <code>client()</code> 中方法看上去每次都会新建一个客户端，查看 dapr 源码注释可知(Note, this default factory function creates Dapr client only once. All subsequent invocations will return the already created instance. ) 每次只会返回已经创建好的实例，因此使用完以后不必关闭此客户端。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"context\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"encoding/json\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"errors\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"github.com/Zhang-Byte/dapr-golang/internal\"</span></span><br><span class=\"line\">\tdapr <span class=\"string\">\"github.com/dapr/go-sdk/client\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"github.com/dapr/go-sdk/service/common\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"log\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"net/http\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">import</span> daprd <span class=\"string\">\"github.com/dapr/go-sdk/service/http\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ts := daprd.NewService(<span class=\"string\">\":9002\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := s.AddServiceInvocationHandler(<span class=\"string\">\"/hello\"</span>, helloHandler); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatalf(<span class=\"string\">\"error adding invocation handler: %v\"</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := s.Start(); err != <span class=\"literal\">nil</span> &amp;&amp; err != http.ErrServerClosed &#123;</span><br><span class=\"line\">\t\tlog.Fatalf(<span class=\"string\">\"error listenning: %v\"</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">helloHandler</span><span class=\"params\">(ctx context.Context, in *common.InvocationEvent)</span> <span class=\"params\">(out *common.Content, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> in == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\terr = errors.New(<span class=\"string\">\"invocation parameter required\"</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlog.Printf(<span class=\"string\">\"The go-service-b service method hello has been invoked,recieve message is %v\"</span>, <span class=\"keyword\">string</span>(in.Data))</span><br><span class=\"line\"></span><br><span class=\"line\">\tmsg := invokeService(ctx)</span><br><span class=\"line\">\thttpResult := internal.HttpResult&#123;Message: msg&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tout = &amp;common.Content&#123;</span><br><span class=\"line\">\t\tData:        httpResult.ToBytes(),</span><br><span class=\"line\">\t\tContentType: in.ContentType,</span><br><span class=\"line\">\t\tDataTypeURL: in.DataTypeURL,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">invokeService</span><span class=\"params\">(ctx context.Context)</span> <span class=\"params\">(msg <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\tclient := client()</span><br><span class=\"line\">\tcontent := &amp;dapr.DataContent&#123;</span><br><span class=\"line\">\t\tContentType: <span class=\"string\">\"text/plain\"</span>,</span><br><span class=\"line\">\t\tData:        []<span class=\"keyword\">byte</span>(<span class=\"string\">\"This is golang Service B.\"</span>),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tresp, err := client.InvokeServiceWithContent(ctx, <span class=\"string\">\"go-service-c\"</span>, <span class=\"string\">\"hello\"</span>, content)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> result internal.HttpResult</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := json.Unmarshal(resp, &amp;result); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Printf(err.Error())</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmsg = result.Message</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">client</span><span class=\"params\">()</span> <span class=\"title\">dapr</span>.<span class=\"title\">Client</span></span> &#123;</span><br><span class=\"line\">\tclient, err := dapr.NewClient()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> client</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>启动命令：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dapr run --app-id go-service-b \\</span><br><span class=\"line\">         --app-protocol http \\</span><br><span class=\"line\">         --app-port <span class=\"number\">9002</span> \\</span><br><span class=\"line\">         --dapr-http-port <span class=\"number\">3500</span> \\</span><br><span class=\"line\">         --log-level debug \\</span><br><span class=\"line\">         --components-<span class=\"built_in\">path</span> ./config \\</span><br><span class=\"line\">         go run ./<span class=\"built_in\">cmd</span>/service/http/b/main.go</span><br></pre></td></tr></table></figure>\n<h2>go-client-a</h2>\n<p>最后创建客户端，客户端每间隔 5 秒发起一次请求到 go-service-b 。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"context\"</span></span><br><span class=\"line\">\tdapr <span class=\"string\">\"github.com/dapr/go-sdk/client\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"log\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"time\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tctx := context.Background()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// create the client</span></span><br><span class=\"line\">\tclient, err := dapr.NewClient()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> client.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">\tcontent := &amp;dapr.DataContent&#123;</span><br><span class=\"line\">\t\tContentType: <span class=\"string\">\"text/plain\"</span>,</span><br><span class=\"line\">\t\tData:        []<span class=\"keyword\">byte</span>(<span class=\"string\">\"This is client A.\"</span>),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\tresp, err := client.InvokeServiceWithContent(ctx, <span class=\"string\">\"go-service-b\"</span>, <span class=\"string\">\"hello\"</span>, content)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tlog.Printf(<span class=\"string\">\"go-service-b method hello has invoked, response: %s\"</span>, <span class=\"keyword\">string</span>(resp))</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttime.Sleep(time.Second * <span class=\"number\">5</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>启动命令：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dapr run --app-id go-client-a \\</span><br><span class=\"line\">         --components-<span class=\"built_in\">path</span> ./config \\</span><br><span class=\"line\">         --log-level debug \\</span><br><span class=\"line\">         go run ./<span class=\"built_in\">cmd</span>/client/a/main.go</span><br></pre></td></tr></table></figure>\n<h2>总结</h2>\n<p>client 启动后，得到返回值</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">== APP == <span class=\"number\">2020</span>/<span class=\"number\">11</span>/<span class=\"number\">06</span> <span class=\"number\">11</span>:<span class=\"number\">26</span>:<span class=\"number\">41</span> go-service-b method hello has invoked, response: &#123;\"Message\":\"This message is from Service C.\"&#125;</span><br></pre></td></tr></table></figure>\n<p>go-service-b 打印内容为：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">== APP == <span class=\"number\">2020</span>/<span class=\"number\">11</span>/<span class=\"number\">06</span> <span class=\"number\">11</span>:<span class=\"number\">31</span>:<span class=\"number\">51</span> The go-service-b service has been invoked,recieve message is This is client A.</span><br></pre></td></tr></table></figure>\n<p>go-service-c 打印内容为：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">== APP == <span class=\"number\">2020</span>/<span class=\"number\">11</span>/<span class=\"number\">06</span> <span class=\"number\">11</span>:<span class=\"number\">33</span>:<span class=\"number\">31</span> The go-service-c service method hello has been invoked,recieve message is This is golang Service B.</span><br></pre></td></tr></table></figure>\n<p>在命令行界面中输入 <code>dapr dashboard</code> 得到输出 <code>Dapr Dashboard running on http://localhost:8080</code>，访问 <code>http://localhost:8080</code></p>\n<p><img src=\"/img/golang/2.png\" alt=\"dashboard\"></p>\n<p>源码地址：<a href=\"https://github.com/ZhangX-Byte/dapr-golang\" target=\"_blank\" rel=\"noopener\">https://github.com/ZhangX-Byte/dapr-golang</a></p>\n"},{"title":"Dapr 概述","catalog":true,"toc_nav_num":true,"date":"2020-09-11T05:47:55.000Z","subtitle":"docs/overview","header-img":"/img/dapr/dapr.svg","catagories":["Dapr"],"_content":"\n## Dapr 概述\n\n---\n\n[Dapr overview](https://github.com/dapr/docs/tree/master/overview)\n\nDapr 是一个可移植的（portable）、事件驱动（event-driven）的运行时框架。企业开发者使用 Dapr 可以轻松构建弹性、无状态和有状态运行在云上和边缘的微服务。并且拥抱开发语言和开发框架的多样性。\n\n### 任何开发语言、任何开发框架、运行在任何地方\n\n---\n\n![](/img/dapr/overview.png)\n\n我们正处于云应用浪潮中。开发者使用 Web + Database 架构（例如经典3层设计）会比较轻松，但当面对天生具备分布式属性的微服务应用架构来说可能就比较吃力了。要成为一个分布式系统专家是有难度的事情，你也没必要成为一个分布式系统专家。开发者应该专注于业务逻辑，同时依赖各种云平台以使应用程序拥有可伸缩性（scale）、容错性（resiliency）、可维护性（maintainability）、弹性（elasticity） 以及云原生架构的其它属性。\n\n这就是 Dapr 切入点。Dapr 将构建微服务的最佳实践整理为开放、独立的构建块。因此，你可以选择开发语言和框架构建可移植的应用程序。每个构建块都是独立的，你可以在你的应用程序中使用它们中的一个、几个或者所有。\n\n### 云和边缘微服务构建块\n\n---\n\n![](/img/dapr/building_blocks.png)\n\n当架构微服务应用程序时有很多东西需要考虑。而当构建微服务应用程序时 Dapr 提供常用功能的最佳实践。开发者可以按标准在微服务中使用 Dapr 提供的常用功能并且部署到任何环境。Dapr 通过提供分布式系统构建块以支撑这种能力。\n\n这些构建块中每一个块都是独立的，意味着你可以在你的应用程序中使用一个、几个或者全部构建块。在 Dapr 的首次发布中，提供以下构建块：\n\n构建块|描述\n--|--\n{% post_link service-invocation 服务调用（Service Invocation） %}| 容错 service-to-service invocation 使方法调用（包括重试调用）远程服务，无论这些服务位于任何被支持的托管环境。\n状态管理（State Management）| 通过状态管理存储键/值对，可以同时在你的应用程序中实现长时间运行、高可用、有状态服务和无状态服务。状态存储是可插拔的并且可以使用 Azure CosmosDB， Azure SQL Server， PostgreSQL， AWS DynamoDB 或者 Redis。\n发布和订阅消息（Publish and Subscribe Messaging）| 发布事件和订阅主题。\n资源绑定（Resource Bindings）| 带有触发器的资源绑定进一步构建在事件驱动的架构之上，通过从任何外部源(如数据库、队列、文件系统等)接收和发送事件来实现伸缩性和容错性。\nActor 模式（Actors）| 有状态和无状态对象的模式，通过方法和状态封装使并发变得简单。Dapr 在它的 actor 运行时中提供很多能力，包括并发、状态、actor 激活/停用生命周期管理、定时器和唤醒 actor 的提醒。\n可观察性（Observability）| Dapr 发出指标、日志和根据以调试和监控 Dapr 和用户应用程序。Dapr支持分布式跟踪，以使用 W3C 跟踪上下文标准和 Open Telemetry 发送到不同的监视工具轻松地诊断和服务生产中的服务间调用。\n信息安全（Secrets）| Dapr 提供信息安全管理并且集成到公共云和本地，以供应用程序代码检索使用。\n\n### 边车架构\n\n---\n\nDapr 通过边车架构以暴露它的 APIs （要么通过程序要么通过一个进程），不需要应用程序代码嵌入任何 Dapr 运行时代码。这使得其它运行时集成 Dapr 变得简单，就像提供隔离的应用程序逻辑以改善可支持性。\n\n### 托管环境\n\n---\n\nDapr 可以在多个环境上托管，包括为本地开发环境自托管，或者部署到一组虚拟机、K8S和边缘（如Azure IoT edge）。\n\n#### 自托管\n\n自托管模式下，Dapr 作为一个隔离的边车进程运行，你的服务可以通过 HTTP 或者 gRPC 调用。自托管模式下，你也可以把 Dapr 部署到一组虚拟机下。\n\n![](/img/dapr/overview-sidecar.png)\n\n#### K8S 托管\n\n在容器托管环境比如 K8s，Dapr 以一个边车容器的方式和应用程序容器运行在同一个 pod 中。\n\n![](/img/dapr/overview-sidecar-kubernetes.png)\n\n### 开发语言 SDKs 和框架\n\n为了使 Dapr 在不同的语言中运用更加自然，Dapr 对 Go、Java、JavaScript、.NET 和 Python 提供特定的 SDK。Dapr 构建块中的功能通过这些 SDKs 暴露，比如：通过一个类型化的语言而不是调用 http/gRPC 接口以保存状态、发布一个事件或者创建一个 actor。这使你能够使用自己选择的语言编写无状态和有状态函数以及 actor 的组合。并且由于这些 SDKs 共享 Dapr 运行时，你可以获得跨语言的 actor 和函数支持。\n\n#### SDKs\n\n- C++ SDK\n- Go SDK\n- Java SDK\n- JavaScript SDK\n- Python SDK\n- .NET SDK\n\n> 注意： Dapr 是语言无关的提供 REST HTTTP API 除了 protobuf 客户端外。\n\n#### 开发框架\n\nDapr 可以用于任何开发框架。这里有一些已经集成到 Dapr 的。\n\n##### Web\n\n在 Dapr .NET SDK 中集成了 `ASP.NET Core`，`ASP.NET Core` 带来了状态路由控制器，该控制器响应来自其他服务的发布/订阅事件。\n\n在 Dapr Java SDK 你可以找到 Spring Boot 集成。\n\nDapr 很容易与 Python Flask 和 node Express 集成，您可以在入门示例中找到它们。\n\n##### Actors\n\nDapr SKDs 支持虚拟 actors ，虚拟 actors 是使并发简单的有状态对象，具有方法和状态封装，并且是为可扩展的分布式应用程序设计的。\n\n##### Azure Functions\n\nDapr 通过扩展与 Azure 函数运行时集成，扩展允许函数与 Dapr 无缝交互。Azual 函数提供一个事件驱动编程模式并且 Dapr 提供云原生构建块。通过这个扩展，你可以同时提供 serverless 和事件驱动应用。更多信息请阅读[用于 Dapr 的Azure 函数扩展](https://cloudblogs.microsoft.com/opensource/2020/07/01/announcing-azure-functions-extension-for-dapr/) 和访问[Azure 函数扩展](https://github.com/dapr/azure-functions-extension)以试用示例。\n\n##### Dapr 工作流\n\n为了使开发人员能够轻松构建使用 Dapr 功能（包括诊断和多语言支持）的工作流应用程序，可以使用Dapr工作流。Dapr 集成了工作流引擎比如 Logic Apps，更多信息阅读[使用 Dapr 和 Logic Apps 的云原生工作流](https://cloudblogs.microsoft.com/opensource/2020/05/26/announcing-cloud-native-workflows-dapr-logic-apps/)和访问[Dapr 工作流](https://github.com/dapr/workflows)试用示例。\n\n### 为运维而设计\n\n---\n\nDapr 是为运维而设计的。[Dapr 仪表板](https://github.com/dapr/dashboard)（通过 Dapr CLI 安装），提供一个以网页为基础的 UI 使你能看信息、看日志和 Dapr 边车更多的信息。\n\n监视仪表板提供了对 Dapr 系统服务和边车的更深层次的可见性，而 Dapr 的可观察性功能提供了对应用程序的深入了解，如跟踪和指标。\n\n### 运行与任何地方\n\n---\n\n#### 本地开发机器以自托管模式运行 Dapr\n\nDapr 可以配置为自托管模式以运行在你本地机器上。每一个运行的服务有一个 Dapr 运行时进程（或者边车），这个进程（或边车）通过配置以使用状态存储、发布/订阅、绑定组件和其它构建块。\n\n你可以使用 Dapr CLI 在你本地机器上运行 Dapr 启用应用程序。通过入门示例试用。\n\n![](/img/dapr/overview_standalone.png)\n\n#### 以 K8S 模式运行 Dapr\n\nDapr 可以配置以运行在任何 K8S 集群上。在 K8S 上 `dapr-sidecar-injector` 和 `dapr-operator` 服务提供了一流的集成，以将 Dapr 作为 sidecar 容器启动与服务容器在同一 pod 中，并提供了已配置到集群中的 Dapr 组件更新的通知。\n\n`dapr-sentry` 服务是一个证书颁发机构，可启用 Dapr 边车实例之间的相互 TLS 进行安全数据加密。有关Sentry服务的更多信息，请阅读[安全概述](https://github.com/dapr/docs/blob/master/concepts/security/README.md#dapr-to-dapr-communication)。\n\n![](/img/dapr/overview_kubernetes.png)\n\n在 Kubernetes 集群中部署并运行启用了 Dapr 的应用程序非常简单，只需在部署方案中添加一些注释即可。您可以在Kubernetes入门示例中看到一些示例。使用 Kubernetes [入门示例](https://github.com/dapr/quickstarts/tree/master/hello-kubernetes)进行尝试。\n\n---\n\n## 参考\n\n- [1] [Implement resilient applications](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/)\n\n    > Resiliency is the ability to recover from failures and continue to function. It isn't about avoiding failures but accepting the fact that failures will happen and responding to them in a way that avoids downtime or data loss. The goal of resiliency is to return the application to a fully functioning state after a failure.\n    > 翻译：Resiliency 是一种从故障中恢复并且继续工作的能力。并不是避开故障而是接受可能会故障的事实并且以某种方式回应它们以避免停机或者数据丢失。Resiliency 的目标是在发生故障后将应用程序返回到完全正常的状态。\n","source":"_posts/doc-overview.md","raw":"---\ntitle: Dapr 概述\ncatalog: true\ntoc_nav_num: true\ndate: 2020-09-11 13:47:55\nsubtitle: docs/overview\nheader-img: /img/dapr/dapr.svg\ntags: \n- Dapr\n- 原文翻译\ncatagories:\n- Dapr\n---\n\n## Dapr 概述\n\n---\n\n[Dapr overview](https://github.com/dapr/docs/tree/master/overview)\n\nDapr 是一个可移植的（portable）、事件驱动（event-driven）的运行时框架。企业开发者使用 Dapr 可以轻松构建弹性、无状态和有状态运行在云上和边缘的微服务。并且拥抱开发语言和开发框架的多样性。\n\n### 任何开发语言、任何开发框架、运行在任何地方\n\n---\n\n![](/img/dapr/overview.png)\n\n我们正处于云应用浪潮中。开发者使用 Web + Database 架构（例如经典3层设计）会比较轻松，但当面对天生具备分布式属性的微服务应用架构来说可能就比较吃力了。要成为一个分布式系统专家是有难度的事情，你也没必要成为一个分布式系统专家。开发者应该专注于业务逻辑，同时依赖各种云平台以使应用程序拥有可伸缩性（scale）、容错性（resiliency）、可维护性（maintainability）、弹性（elasticity） 以及云原生架构的其它属性。\n\n这就是 Dapr 切入点。Dapr 将构建微服务的最佳实践整理为开放、独立的构建块。因此，你可以选择开发语言和框架构建可移植的应用程序。每个构建块都是独立的，你可以在你的应用程序中使用它们中的一个、几个或者所有。\n\n### 云和边缘微服务构建块\n\n---\n\n![](/img/dapr/building_blocks.png)\n\n当架构微服务应用程序时有很多东西需要考虑。而当构建微服务应用程序时 Dapr 提供常用功能的最佳实践。开发者可以按标准在微服务中使用 Dapr 提供的常用功能并且部署到任何环境。Dapr 通过提供分布式系统构建块以支撑这种能力。\n\n这些构建块中每一个块都是独立的，意味着你可以在你的应用程序中使用一个、几个或者全部构建块。在 Dapr 的首次发布中，提供以下构建块：\n\n构建块|描述\n--|--\n{% post_link service-invocation 服务调用（Service Invocation） %}| 容错 service-to-service invocation 使方法调用（包括重试调用）远程服务，无论这些服务位于任何被支持的托管环境。\n状态管理（State Management）| 通过状态管理存储键/值对，可以同时在你的应用程序中实现长时间运行、高可用、有状态服务和无状态服务。状态存储是可插拔的并且可以使用 Azure CosmosDB， Azure SQL Server， PostgreSQL， AWS DynamoDB 或者 Redis。\n发布和订阅消息（Publish and Subscribe Messaging）| 发布事件和订阅主题。\n资源绑定（Resource Bindings）| 带有触发器的资源绑定进一步构建在事件驱动的架构之上，通过从任何外部源(如数据库、队列、文件系统等)接收和发送事件来实现伸缩性和容错性。\nActor 模式（Actors）| 有状态和无状态对象的模式，通过方法和状态封装使并发变得简单。Dapr 在它的 actor 运行时中提供很多能力，包括并发、状态、actor 激活/停用生命周期管理、定时器和唤醒 actor 的提醒。\n可观察性（Observability）| Dapr 发出指标、日志和根据以调试和监控 Dapr 和用户应用程序。Dapr支持分布式跟踪，以使用 W3C 跟踪上下文标准和 Open Telemetry 发送到不同的监视工具轻松地诊断和服务生产中的服务间调用。\n信息安全（Secrets）| Dapr 提供信息安全管理并且集成到公共云和本地，以供应用程序代码检索使用。\n\n### 边车架构\n\n---\n\nDapr 通过边车架构以暴露它的 APIs （要么通过程序要么通过一个进程），不需要应用程序代码嵌入任何 Dapr 运行时代码。这使得其它运行时集成 Dapr 变得简单，就像提供隔离的应用程序逻辑以改善可支持性。\n\n### 托管环境\n\n---\n\nDapr 可以在多个环境上托管，包括为本地开发环境自托管，或者部署到一组虚拟机、K8S和边缘（如Azure IoT edge）。\n\n#### 自托管\n\n自托管模式下，Dapr 作为一个隔离的边车进程运行，你的服务可以通过 HTTP 或者 gRPC 调用。自托管模式下，你也可以把 Dapr 部署到一组虚拟机下。\n\n![](/img/dapr/overview-sidecar.png)\n\n#### K8S 托管\n\n在容器托管环境比如 K8s，Dapr 以一个边车容器的方式和应用程序容器运行在同一个 pod 中。\n\n![](/img/dapr/overview-sidecar-kubernetes.png)\n\n### 开发语言 SDKs 和框架\n\n为了使 Dapr 在不同的语言中运用更加自然，Dapr 对 Go、Java、JavaScript、.NET 和 Python 提供特定的 SDK。Dapr 构建块中的功能通过这些 SDKs 暴露，比如：通过一个类型化的语言而不是调用 http/gRPC 接口以保存状态、发布一个事件或者创建一个 actor。这使你能够使用自己选择的语言编写无状态和有状态函数以及 actor 的组合。并且由于这些 SDKs 共享 Dapr 运行时，你可以获得跨语言的 actor 和函数支持。\n\n#### SDKs\n\n- C++ SDK\n- Go SDK\n- Java SDK\n- JavaScript SDK\n- Python SDK\n- .NET SDK\n\n> 注意： Dapr 是语言无关的提供 REST HTTTP API 除了 protobuf 客户端外。\n\n#### 开发框架\n\nDapr 可以用于任何开发框架。这里有一些已经集成到 Dapr 的。\n\n##### Web\n\n在 Dapr .NET SDK 中集成了 `ASP.NET Core`，`ASP.NET Core` 带来了状态路由控制器，该控制器响应来自其他服务的发布/订阅事件。\n\n在 Dapr Java SDK 你可以找到 Spring Boot 集成。\n\nDapr 很容易与 Python Flask 和 node Express 集成，您可以在入门示例中找到它们。\n\n##### Actors\n\nDapr SKDs 支持虚拟 actors ，虚拟 actors 是使并发简单的有状态对象，具有方法和状态封装，并且是为可扩展的分布式应用程序设计的。\n\n##### Azure Functions\n\nDapr 通过扩展与 Azure 函数运行时集成，扩展允许函数与 Dapr 无缝交互。Azual 函数提供一个事件驱动编程模式并且 Dapr 提供云原生构建块。通过这个扩展，你可以同时提供 serverless 和事件驱动应用。更多信息请阅读[用于 Dapr 的Azure 函数扩展](https://cloudblogs.microsoft.com/opensource/2020/07/01/announcing-azure-functions-extension-for-dapr/) 和访问[Azure 函数扩展](https://github.com/dapr/azure-functions-extension)以试用示例。\n\n##### Dapr 工作流\n\n为了使开发人员能够轻松构建使用 Dapr 功能（包括诊断和多语言支持）的工作流应用程序，可以使用Dapr工作流。Dapr 集成了工作流引擎比如 Logic Apps，更多信息阅读[使用 Dapr 和 Logic Apps 的云原生工作流](https://cloudblogs.microsoft.com/opensource/2020/05/26/announcing-cloud-native-workflows-dapr-logic-apps/)和访问[Dapr 工作流](https://github.com/dapr/workflows)试用示例。\n\n### 为运维而设计\n\n---\n\nDapr 是为运维而设计的。[Dapr 仪表板](https://github.com/dapr/dashboard)（通过 Dapr CLI 安装），提供一个以网页为基础的 UI 使你能看信息、看日志和 Dapr 边车更多的信息。\n\n监视仪表板提供了对 Dapr 系统服务和边车的更深层次的可见性，而 Dapr 的可观察性功能提供了对应用程序的深入了解，如跟踪和指标。\n\n### 运行与任何地方\n\n---\n\n#### 本地开发机器以自托管模式运行 Dapr\n\nDapr 可以配置为自托管模式以运行在你本地机器上。每一个运行的服务有一个 Dapr 运行时进程（或者边车），这个进程（或边车）通过配置以使用状态存储、发布/订阅、绑定组件和其它构建块。\n\n你可以使用 Dapr CLI 在你本地机器上运行 Dapr 启用应用程序。通过入门示例试用。\n\n![](/img/dapr/overview_standalone.png)\n\n#### 以 K8S 模式运行 Dapr\n\nDapr 可以配置以运行在任何 K8S 集群上。在 K8S 上 `dapr-sidecar-injector` 和 `dapr-operator` 服务提供了一流的集成，以将 Dapr 作为 sidecar 容器启动与服务容器在同一 pod 中，并提供了已配置到集群中的 Dapr 组件更新的通知。\n\n`dapr-sentry` 服务是一个证书颁发机构，可启用 Dapr 边车实例之间的相互 TLS 进行安全数据加密。有关Sentry服务的更多信息，请阅读[安全概述](https://github.com/dapr/docs/blob/master/concepts/security/README.md#dapr-to-dapr-communication)。\n\n![](/img/dapr/overview_kubernetes.png)\n\n在 Kubernetes 集群中部署并运行启用了 Dapr 的应用程序非常简单，只需在部署方案中添加一些注释即可。您可以在Kubernetes入门示例中看到一些示例。使用 Kubernetes [入门示例](https://github.com/dapr/quickstarts/tree/master/hello-kubernetes)进行尝试。\n\n---\n\n## 参考\n\n- [1] [Implement resilient applications](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/)\n\n    > Resiliency is the ability to recover from failures and continue to function. It isn't about avoiding failures but accepting the fact that failures will happen and responding to them in a way that avoids downtime or data loss. The goal of resiliency is to return the application to a fully functioning state after a failure.\n    > 翻译：Resiliency 是一种从故障中恢复并且继续工作的能力。并不是避开故障而是接受可能会故障的事实并且以某种方式回应它们以避免停机或者数据丢失。Resiliency 的目标是在发生故障后将应用程序返回到完全正常的状态。\n","slug":"doc-overview","published":1,"updated":"2020-09-16T02:58:13.890Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh8qmyhs000a4x6yyl0f6f2i","content":"<h2 id=\"dapr-概述\">Dapr 概述</h2>\n<hr>\n<p><a href=\"https://github.com/dapr/docs/tree/master/overview\" target=\"_blank\" rel=\"noopener\">Dapr overview</a></p>\n<p>Dapr 是一个可移植的（portable）、事件驱动（event-driven）的运行时框架。企业开发者使用 Dapr 可以轻松构建弹性、无状态和有状态运行在云上和边缘的微服务。并且拥抱开发语言和开发框架的多样性。</p>\n<h3 id=\"任何开发语言-任何开发框架-运行在任何地方\">任何开发语言、任何开发框架、运行在任何地方</h3>\n<hr>\n<p><img src=\"/img/dapr/overview.png\" alt=\"\"></p>\n<p>我们正处于云应用浪潮中。开发者使用 Web + Database 架构（例如经典3层设计）会比较轻松，但当面对天生具备分布式属性的微服务应用架构来说可能就比较吃力了。要成为一个分布式系统专家是有难度的事情，你也没必要成为一个分布式系统专家。开发者应该专注于业务逻辑，同时依赖各种云平台以使应用程序拥有可伸缩性（scale）、容错性（resiliency）、可维护性（maintainability）、弹性（elasticity） 以及云原生架构的其它属性。</p>\n<p>这就是 Dapr 切入点。Dapr 将构建微服务的最佳实践整理为开放、独立的构建块。因此，你可以选择开发语言和框架构建可移植的应用程序。每个构建块都是独立的，你可以在你的应用程序中使用它们中的一个、几个或者所有。</p>\n<h3 id=\"云和边缘微服务构建块\">云和边缘微服务构建块</h3>\n<hr>\n<p><img src=\"/img/dapr/building_blocks.png\" alt=\"\"></p>\n<p>当架构微服务应用程序时有很多东西需要考虑。而当构建微服务应用程序时 Dapr 提供常用功能的最佳实践。开发者可以按标准在微服务中使用 Dapr 提供的常用功能并且部署到任何环境。Dapr 通过提供分布式系统构建块以支撑这种能力。</p>\n<p>这些构建块中每一个块都是独立的，意味着你可以在你的应用程序中使用一个、几个或者全部构建块。在 Dapr 的首次发布中，提供以下构建块：</p>\n<table>\n<thead>\n<tr>\n<th>构建块</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"/article/service-invocation/\" title=\"服务调用（Service Invocation）\">服务调用（Service Invocation）</a></td>\n<td>容错 service-to-service invocation 使方法调用（包括重试调用）远程服务，无论这些服务位于任何被支持的托管环境。</td>\n</tr>\n<tr>\n<td>状态管理（State Management）</td>\n<td>通过状态管理存储键/值对，可以同时在你的应用程序中实现长时间运行、高可用、有状态服务和无状态服务。状态存储是可插拔的并且可以使用 Azure CosmosDB， Azure SQL Server， PostgreSQL， AWS DynamoDB 或者 Redis。</td>\n</tr>\n<tr>\n<td>发布和订阅消息（Publish and Subscribe Messaging）</td>\n<td>发布事件和订阅主题。</td>\n</tr>\n<tr>\n<td>资源绑定（Resource Bindings）</td>\n<td>带有触发器的资源绑定进一步构建在事件驱动的架构之上，通过从任何外部源(如数据库、队列、文件系统等)接收和发送事件来实现伸缩性和容错性。</td>\n</tr>\n<tr>\n<td>Actor 模式（Actors）</td>\n<td>有状态和无状态对象的模式，通过方法和状态封装使并发变得简单。Dapr 在它的 actor 运行时中提供很多能力，包括并发、状态、actor 激活/停用生命周期管理、定时器和唤醒 actor 的提醒。</td>\n</tr>\n<tr>\n<td>可观察性（Observability）</td>\n<td>Dapr 发出指标、日志和根据以调试和监控 Dapr 和用户应用程序。Dapr支持分布式跟踪，以使用 W3C 跟踪上下文标准和 Open Telemetry 发送到不同的监视工具轻松地诊断和服务生产中的服务间调用。</td>\n</tr>\n<tr>\n<td>信息安全（Secrets）</td>\n<td>Dapr 提供信息安全管理并且集成到公共云和本地，以供应用程序代码检索使用。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"边车架构\">边车架构</h3>\n<hr>\n<p>Dapr 通过边车架构以暴露它的 APIs （要么通过程序要么通过一个进程），不需要应用程序代码嵌入任何 Dapr 运行时代码。这使得其它运行时集成 Dapr 变得简单，就像提供隔离的应用程序逻辑以改善可支持性。</p>\n<h3 id=\"托管环境\">托管环境</h3>\n<hr>\n<p>Dapr 可以在多个环境上托管，包括为本地开发环境自托管，或者部署到一组虚拟机、K8S和边缘（如Azure IoT edge）。</p>\n<h4 id=\"自托管\">自托管</h4>\n<p>自托管模式下，Dapr 作为一个隔离的边车进程运行，你的服务可以通过 HTTP 或者 gRPC 调用。自托管模式下，你也可以把 Dapr 部署到一组虚拟机下。</p>\n<p><img src=\"/img/dapr/overview-sidecar.png\" alt=\"\"></p>\n<h4 id=\"k8s-托管\">K8S 托管</h4>\n<p>在容器托管环境比如 K8s，Dapr 以一个边车容器的方式和应用程序容器运行在同一个 pod 中。</p>\n<p><img src=\"/img/dapr/overview-sidecar-kubernetes.png\" alt=\"\"></p>\n<h3 id=\"开发语言-sdks-和框架\">开发语言 SDKs 和框架</h3>\n<p>为了使 Dapr 在不同的语言中运用更加自然，Dapr 对 Go、Java、JavaScript、.NET 和 Python 提供特定的 SDK。Dapr 构建块中的功能通过这些 SDKs 暴露，比如：通过一个类型化的语言而不是调用 http/gRPC 接口以保存状态、发布一个事件或者创建一个 actor。这使你能够使用自己选择的语言编写无状态和有状态函数以及 actor 的组合。并且由于这些 SDKs 共享 Dapr 运行时，你可以获得跨语言的 actor 和函数支持。</p>\n<h4 id=\"sdks\">SDKs</h4>\n<ul>\n<li>C++ SDK</li>\n<li>Go SDK</li>\n<li>Java SDK</li>\n<li>JavaScript SDK</li>\n<li>Python SDK</li>\n<li>.NET SDK</li>\n</ul>\n<blockquote>\n<p>注意： Dapr 是语言无关的提供 REST HTTTP API 除了 protobuf 客户端外。</p>\n</blockquote>\n<h4 id=\"开发框架\">开发框架</h4>\n<p>Dapr 可以用于任何开发框架。这里有一些已经集成到 Dapr 的。</p>\n<h5 id=\"web\">Web</h5>\n<p>在 Dapr .NET SDK 中集成了 <code>ASP.NET Core</code>，<code>ASP.NET Core</code> 带来了状态路由控制器，该控制器响应来自其他服务的发布/订阅事件。</p>\n<p>在 Dapr Java SDK 你可以找到 Spring Boot 集成。</p>\n<p>Dapr 很容易与 Python Flask 和 node Express 集成，您可以在入门示例中找到它们。</p>\n<h5 id=\"actors\">Actors</h5>\n<p>Dapr SKDs 支持虚拟 actors ，虚拟 actors 是使并发简单的有状态对象，具有方法和状态封装，并且是为可扩展的分布式应用程序设计的。</p>\n<h5 id=\"azure-functions\">Azure Functions</h5>\n<p>Dapr 通过扩展与 Azure 函数运行时集成，扩展允许函数与 Dapr 无缝交互。Azual 函数提供一个事件驱动编程模式并且 Dapr 提供云原生构建块。通过这个扩展，你可以同时提供 serverless 和事件驱动应用。更多信息请阅读<a href=\"https://cloudblogs.microsoft.com/opensource/2020/07/01/announcing-azure-functions-extension-for-dapr/\" target=\"_blank\" rel=\"noopener\">用于 Dapr 的Azure 函数扩展</a> 和访问<a href=\"https://github.com/dapr/azure-functions-extension\" target=\"_blank\" rel=\"noopener\">Azure 函数扩展</a>以试用示例。</p>\n<h5 id=\"dapr-工作流\">Dapr 工作流</h5>\n<p>为了使开发人员能够轻松构建使用 Dapr 功能（包括诊断和多语言支持）的工作流应用程序，可以使用Dapr工作流。Dapr 集成了工作流引擎比如 Logic Apps，更多信息阅读<a href=\"https://cloudblogs.microsoft.com/opensource/2020/05/26/announcing-cloud-native-workflows-dapr-logic-apps/\" target=\"_blank\" rel=\"noopener\">使用 Dapr 和 Logic Apps 的云原生工作流</a>和访问<a href=\"https://github.com/dapr/workflows\" target=\"_blank\" rel=\"noopener\">Dapr 工作流</a>试用示例。</p>\n<h3 id=\"为运维而设计\">为运维而设计</h3>\n<hr>\n<p>Dapr 是为运维而设计的。<a href=\"https://github.com/dapr/dashboard\" target=\"_blank\" rel=\"noopener\">Dapr 仪表板</a>（通过 Dapr CLI 安装），提供一个以网页为基础的 UI 使你能看信息、看日志和 Dapr 边车更多的信息。</p>\n<p>监视仪表板提供了对 Dapr 系统服务和边车的更深层次的可见性，而 Dapr 的可观察性功能提供了对应用程序的深入了解，如跟踪和指标。</p>\n<h3 id=\"运行与任何地方\">运行与任何地方</h3>\n<hr>\n<h4 id=\"本地开发机器以自托管模式运行-dapr\">本地开发机器以自托管模式运行 Dapr</h4>\n<p>Dapr 可以配置为自托管模式以运行在你本地机器上。每一个运行的服务有一个 Dapr 运行时进程（或者边车），这个进程（或边车）通过配置以使用状态存储、发布/订阅、绑定组件和其它构建块。</p>\n<p>你可以使用 Dapr CLI 在你本地机器上运行 Dapr 启用应用程序。通过入门示例试用。</p>\n<p><img src=\"/img/dapr/overview_standalone.png\" alt=\"\"></p>\n<h4 id=\"以-k8s-模式运行-dapr\">以 K8S 模式运行 Dapr</h4>\n<p>Dapr 可以配置以运行在任何 K8S 集群上。在 K8S 上 <code>dapr-sidecar-injector</code> 和 <code>dapr-operator</code> 服务提供了一流的集成，以将 Dapr 作为 sidecar 容器启动与服务容器在同一 pod 中，并提供了已配置到集群中的 Dapr 组件更新的通知。</p>\n<p><code>dapr-sentry</code> 服务是一个证书颁发机构，可启用 Dapr 边车实例之间的相互 TLS 进行安全数据加密。有关Sentry服务的更多信息，请阅读<a href=\"https://github.com/dapr/docs/blob/master/concepts/security/README.md#dapr-to-dapr-communication\" target=\"_blank\" rel=\"noopener\">安全概述</a>。</p>\n<p><img src=\"/img/dapr/overview_kubernetes.png\" alt=\"\"></p>\n<p>在 Kubernetes 集群中部署并运行启用了 Dapr 的应用程序非常简单，只需在部署方案中添加一些注释即可。您可以在Kubernetes入门示例中看到一些示例。使用 Kubernetes <a href=\"https://github.com/dapr/quickstarts/tree/master/hello-kubernetes\" target=\"_blank\" rel=\"noopener\">入门示例</a>进行尝试。</p>\n<hr>\n<h2 id=\"参考\">参考</h2>\n<ul>\n<li>\n<p>[1] <a href=\"https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/\" target=\"_blank\" rel=\"noopener\">Implement resilient applications</a></p>\n<blockquote>\n<p>Resiliency is the ability to recover from failures and continue to function. It isn’t about avoiding failures but accepting the fact that failures will happen and responding to them in a way that avoids downtime or data loss. The goal of resiliency is to return the application to a fully functioning state after a failure.<br>\n翻译：Resiliency 是一种从故障中恢复并且继续工作的能力。并不是避开故障而是接受可能会故障的事实并且以某种方式回应它们以避免停机或者数据丢失。Resiliency 的目标是在发生故障后将应用程序返回到完全正常的状态。</p>\n</blockquote>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2>Dapr 概述</h2>\n<hr>\n<p><a href=\"https://github.com/dapr/docs/tree/master/overview\" target=\"_blank\" rel=\"noopener\">Dapr overview</a></p>\n<p>Dapr 是一个可移植的（portable）、事件驱动（event-driven）的运行时框架。企业开发者使用 Dapr 可以轻松构建弹性、无状态和有状态运行在云上和边缘的微服务。并且拥抱开发语言和开发框架的多样性。</p>\n<h3>任何开发语言、任何开发框架、运行在任何地方</h3>\n<hr>\n<p><img src=\"/img/dapr/overview.png\" alt=\"\"></p>\n<p>我们正处于云应用浪潮中。开发者使用 Web + Database 架构（例如经典3层设计）会比较轻松，但当面对天生具备分布式属性的微服务应用架构来说可能就比较吃力了。要成为一个分布式系统专家是有难度的事情，你也没必要成为一个分布式系统专家。开发者应该专注于业务逻辑，同时依赖各种云平台以使应用程序拥有可伸缩性（scale）、容错性（resiliency）、可维护性（maintainability）、弹性（elasticity） 以及云原生架构的其它属性。</p>\n<p>这就是 Dapr 切入点。Dapr 将构建微服务的最佳实践整理为开放、独立的构建块。因此，你可以选择开发语言和框架构建可移植的应用程序。每个构建块都是独立的，你可以在你的应用程序中使用它们中的一个、几个或者所有。</p>\n<h3>云和边缘微服务构建块</h3>\n<hr>\n<p><img src=\"/img/dapr/building_blocks.png\" alt=\"\"></p>\n<p>当架构微服务应用程序时有很多东西需要考虑。而当构建微服务应用程序时 Dapr 提供常用功能的最佳实践。开发者可以按标准在微服务中使用 Dapr 提供的常用功能并且部署到任何环境。Dapr 通过提供分布式系统构建块以支撑这种能力。</p>\n<p>这些构建块中每一个块都是独立的，意味着你可以在你的应用程序中使用一个、几个或者全部构建块。在 Dapr 的首次发布中，提供以下构建块：</p>\n<table>\n<thead>\n<tr>\n<th>构建块</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"/article/service-invocation/\" title=\"服务调用（Service Invocation）\">服务调用（Service Invocation）</a></td>\n<td>容错 service-to-service invocation 使方法调用（包括重试调用）远程服务，无论这些服务位于任何被支持的托管环境。</td>\n</tr>\n<tr>\n<td>状态管理（State Management）</td>\n<td>通过状态管理存储键/值对，可以同时在你的应用程序中实现长时间运行、高可用、有状态服务和无状态服务。状态存储是可插拔的并且可以使用 Azure CosmosDB， Azure SQL Server， PostgreSQL， AWS DynamoDB 或者 Redis。</td>\n</tr>\n<tr>\n<td>发布和订阅消息（Publish and Subscribe Messaging）</td>\n<td>发布事件和订阅主题。</td>\n</tr>\n<tr>\n<td>资源绑定（Resource Bindings）</td>\n<td>带有触发器的资源绑定进一步构建在事件驱动的架构之上，通过从任何外部源(如数据库、队列、文件系统等)接收和发送事件来实现伸缩性和容错性。</td>\n</tr>\n<tr>\n<td>Actor 模式（Actors）</td>\n<td>有状态和无状态对象的模式，通过方法和状态封装使并发变得简单。Dapr 在它的 actor 运行时中提供很多能力，包括并发、状态、actor 激活/停用生命周期管理、定时器和唤醒 actor 的提醒。</td>\n</tr>\n<tr>\n<td>可观察性（Observability）</td>\n<td>Dapr 发出指标、日志和根据以调试和监控 Dapr 和用户应用程序。Dapr支持分布式跟踪，以使用 W3C 跟踪上下文标准和 Open Telemetry 发送到不同的监视工具轻松地诊断和服务生产中的服务间调用。</td>\n</tr>\n<tr>\n<td>信息安全（Secrets）</td>\n<td>Dapr 提供信息安全管理并且集成到公共云和本地，以供应用程序代码检索使用。</td>\n</tr>\n</tbody>\n</table>\n<h3>边车架构</h3>\n<hr>\n<p>Dapr 通过边车架构以暴露它的 APIs （要么通过程序要么通过一个进程），不需要应用程序代码嵌入任何 Dapr 运行时代码。这使得其它运行时集成 Dapr 变得简单，就像提供隔离的应用程序逻辑以改善可支持性。</p>\n<h3>托管环境</h3>\n<hr>\n<p>Dapr 可以在多个环境上托管，包括为本地开发环境自托管，或者部署到一组虚拟机、K8S和边缘（如Azure IoT edge）。</p>\n<h4>自托管</h4>\n<p>自托管模式下，Dapr 作为一个隔离的边车进程运行，你的服务可以通过 HTTP 或者 gRPC 调用。自托管模式下，你也可以把 Dapr 部署到一组虚拟机下。</p>\n<p><img src=\"/img/dapr/overview-sidecar.png\" alt=\"\"></p>\n<h4>K8S 托管</h4>\n<p>在容器托管环境比如 K8s，Dapr 以一个边车容器的方式和应用程序容器运行在同一个 pod 中。</p>\n<p><img src=\"/img/dapr/overview-sidecar-kubernetes.png\" alt=\"\"></p>\n<h3>开发语言 SDKs 和框架</h3>\n<p>为了使 Dapr 在不同的语言中运用更加自然，Dapr 对 Go、Java、JavaScript、.NET 和 Python 提供特定的 SDK。Dapr 构建块中的功能通过这些 SDKs 暴露，比如：通过一个类型化的语言而不是调用 http/gRPC 接口以保存状态、发布一个事件或者创建一个 actor。这使你能够使用自己选择的语言编写无状态和有状态函数以及 actor 的组合。并且由于这些 SDKs 共享 Dapr 运行时，你可以获得跨语言的 actor 和函数支持。</p>\n<h4>SDKs</h4>\n<ul>\n<li>C++ SDK</li>\n<li>Go SDK</li>\n<li>Java SDK</li>\n<li>JavaScript SDK</li>\n<li>Python SDK</li>\n<li>.NET SDK</li>\n</ul>\n<blockquote>\n<p>注意： Dapr 是语言无关的提供 REST HTTTP API 除了 protobuf 客户端外。</p>\n</blockquote>\n<h4>开发框架</h4>\n<p>Dapr 可以用于任何开发框架。这里有一些已经集成到 Dapr 的。</p>\n<h5>Web</h5>\n<p>在 Dapr .NET SDK 中集成了 <code>ASP.NET Core</code>，<code>ASP.NET Core</code> 带来了状态路由控制器，该控制器响应来自其他服务的发布/订阅事件。</p>\n<p>在 Dapr Java SDK 你可以找到 Spring Boot 集成。</p>\n<p>Dapr 很容易与 Python Flask 和 node Express 集成，您可以在入门示例中找到它们。</p>\n<h5>Actors</h5>\n<p>Dapr SKDs 支持虚拟 actors ，虚拟 actors 是使并发简单的有状态对象，具有方法和状态封装，并且是为可扩展的分布式应用程序设计的。</p>\n<h5>Azure Functions</h5>\n<p>Dapr 通过扩展与 Azure 函数运行时集成，扩展允许函数与 Dapr 无缝交互。Azual 函数提供一个事件驱动编程模式并且 Dapr 提供云原生构建块。通过这个扩展，你可以同时提供 serverless 和事件驱动应用。更多信息请阅读<a href=\"https://cloudblogs.microsoft.com/opensource/2020/07/01/announcing-azure-functions-extension-for-dapr/\" target=\"_blank\" rel=\"noopener\">用于 Dapr 的Azure 函数扩展</a> 和访问<a href=\"https://github.com/dapr/azure-functions-extension\" target=\"_blank\" rel=\"noopener\">Azure 函数扩展</a>以试用示例。</p>\n<h5>Dapr 工作流</h5>\n<p>为了使开发人员能够轻松构建使用 Dapr 功能（包括诊断和多语言支持）的工作流应用程序，可以使用Dapr工作流。Dapr 集成了工作流引擎比如 Logic Apps，更多信息阅读<a href=\"https://cloudblogs.microsoft.com/opensource/2020/05/26/announcing-cloud-native-workflows-dapr-logic-apps/\" target=\"_blank\" rel=\"noopener\">使用 Dapr 和 Logic Apps 的云原生工作流</a>和访问<a href=\"https://github.com/dapr/workflows\" target=\"_blank\" rel=\"noopener\">Dapr 工作流</a>试用示例。</p>\n<h3>为运维而设计</h3>\n<hr>\n<p>Dapr 是为运维而设计的。<a href=\"https://github.com/dapr/dashboard\" target=\"_blank\" rel=\"noopener\">Dapr 仪表板</a>（通过 Dapr CLI 安装），提供一个以网页为基础的 UI 使你能看信息、看日志和 Dapr 边车更多的信息。</p>\n<p>监视仪表板提供了对 Dapr 系统服务和边车的更深层次的可见性，而 Dapr 的可观察性功能提供了对应用程序的深入了解，如跟踪和指标。</p>\n<h3>运行与任何地方</h3>\n<hr>\n<h4>本地开发机器以自托管模式运行 Dapr</h4>\n<p>Dapr 可以配置为自托管模式以运行在你本地机器上。每一个运行的服务有一个 Dapr 运行时进程（或者边车），这个进程（或边车）通过配置以使用状态存储、发布/订阅、绑定组件和其它构建块。</p>\n<p>你可以使用 Dapr CLI 在你本地机器上运行 Dapr 启用应用程序。通过入门示例试用。</p>\n<p><img src=\"/img/dapr/overview_standalone.png\" alt=\"\"></p>\n<h4>以 K8S 模式运行 Dapr</h4>\n<p>Dapr 可以配置以运行在任何 K8S 集群上。在 K8S 上 <code>dapr-sidecar-injector</code> 和 <code>dapr-operator</code> 服务提供了一流的集成，以将 Dapr 作为 sidecar 容器启动与服务容器在同一 pod 中，并提供了已配置到集群中的 Dapr 组件更新的通知。</p>\n<p><code>dapr-sentry</code> 服务是一个证书颁发机构，可启用 Dapr 边车实例之间的相互 TLS 进行安全数据加密。有关Sentry服务的更多信息，请阅读<a href=\"https://github.com/dapr/docs/blob/master/concepts/security/README.md#dapr-to-dapr-communication\" target=\"_blank\" rel=\"noopener\">安全概述</a>。</p>\n<p><img src=\"/img/dapr/overview_kubernetes.png\" alt=\"\"></p>\n<p>在 Kubernetes 集群中部署并运行启用了 Dapr 的应用程序非常简单，只需在部署方案中添加一些注释即可。您可以在Kubernetes入门示例中看到一些示例。使用 Kubernetes <a href=\"https://github.com/dapr/quickstarts/tree/master/hello-kubernetes\" target=\"_blank\" rel=\"noopener\">入门示例</a>进行尝试。</p>\n<hr>\n<h2>参考</h2>\n<ul>\n<li>\n<p>[1] <a href=\"https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/\" target=\"_blank\" rel=\"noopener\">Implement resilient applications</a></p>\n<blockquote>\n<p>Resiliency is the ability to recover from failures and continue to function. It isn’t about avoiding failures but accepting the fact that failures will happen and responding to them in a way that avoids downtime or data loss. The goal of resiliency is to return the application to a fully functioning state after a failure.<br>\n翻译：Resiliency 是一种从故障中恢复并且继续工作的能力。并不是避开故障而是接受可能会故障的事实并且以某种方式回应它们以避免停机或者数据丢失。Resiliency 的目标是在发生故障后将应用程序返回到完全正常的状态。</p>\n</blockquote>\n</li>\n</ul>\n"},{"title":"Dapr Java HTTP 调用","catalog":true,"toc_nav_num":true,"date":"2020-11-04T01:37:41.000Z","subtitle":"java_invoke_http","header-img":"/img/java/java.jpeg","catajavaries":["Java"],"_content":"\n## 版本介绍\n\n- Java 版本：8\n- Dapr Java SKD 版本：0.9.2\n\nDapr Java-SDK [HTTP 调用文档](https://github.com/dapr/java-sdk/tree/master/examples/src/main/java/io/dapr/examples/invoke/http) 有个先决条件，内容如下：\n\n- Dapr and Dapr CLI.\n- Java JDK 11 (or greater): Oracle JDK or OpenJDK.\n- Apache Maven version 3.x.\n\n大家看到 Java JDK 版本最低要求是 11，但是本文显示使用的 JDK 8，这么做的原因是什么呢，可以[参考](https://github.com/dapr/java-sdk/issues/279) Java-SDK Issues，Issues 中回答如下：\n\n>We want to validate that the SDK is built with Java 8 and apps can use it with Java 11.\n\n意思是他们想通过 Java 11 写的应用程序验证 Java 8 写的 SDK 是否能正常使用。本文不需要验证 Java 11 能否使用 Java-SDK ，因此本文将使用 Java 8 构建应用程序。\n\n## 工程结构\n\n![项目结构](/img/java/java-http-structure.png)\n\n3 个子工程，一个 client，两个 service。新建两个 service 的意义在于展示 http 链路调用使用 dapr 如何实现。3 个工程项目都集成了 Spring Boot。Spring Boot 启动后会自动注册 Controller、Config 之类的 bean。\n\n```mermaid\ngraph LR;\n    java-client-a--1-->java-service-b;\n    java-service-b--2-->java-service-c;\n    java-service-c--3-->java-service-b;\n    java-service-b--4-->java-client-a;\n```\n\n1. java-client-a 做为客户端调用 java-service-b；\n2. java-service-b 接收请求，并调用 java-service-c；\n3. java-service-c 接收请求，并响应；\n4. java-service-b 收到 java-service-c 应答，并响应 java-client-a 请求。\n\n## java-service-c\n\njava-service-c 做为 http 调用链路末端，只需监听 http 请求即可。\n\n``` java\npackage com.dapr.service;\n\nimport org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.CommandLineParser;\nimport org.apache.commons.cli.DefaultParser;\nimport org.apache.commons.cli.Options;\n\n/**\n * @author Zhang_Xiang\n * @since 2020/11/7 10:51:22\n */\npublic class ServiceC {\n\n    /**\n     * Starts the service.\n     *\n     * @param args Expects the port: -p PORT\n     * @throws Exception If cannot start service.\n     */\n    public static void main(String[] args) throws Exception {\n        Options options = new Options();\n        options.addRequiredOption(\"p\", \"port\", true, \"Port to listen to.\");\n\n        CommandLineParser parser = new DefaultParser();\n        CommandLine cmd = parser.parse(options, args);\n\n        // If port string is not valid, it will throw an exception.\n        int port = Integer.parseInt(cmd.getOptionValue(\"port\"));\n\n        DaprApplication.start(port);\n    }\n}\n```\n\n`DaprApplication.start(port);` 集成 SpringBoot 启动。\n\n``` java\npackage com.dapr.service;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n/**\n * Dapr's HTTP callback implementation via SpringBoot.\n * Scanning package io.dapr.springboot is required.\n *\n * @author zhangxiang\n */\n@SpringBootApplication(scanBasePackages = {\"com.dapr.service\"})\npublic class DaprApplication {\n\n    /**\n     * Starts Dapr's callback in a given port.\n     *\n     * @param port Port to listen to.\n     */\n    public static void start(int port) {\n        SpringApplication app = new SpringApplication(DaprApplication.class);\n        app.run(String.format(\"--server.port=%d\", port));\n    }\n\n}\n```\n\n启动命令：\n\n``` cmd\ndapr run --app-id java-service-c --app-port 9100 --dapr-http-port 3510 -- java -jar target/dapr-java-service-exec.jar com.dapr.service.ServiceC -p 9100\n```\n\n## java-service-b\n\njava-service-b 需要配置一个 DaprClient Bean，以在需要使用 Http 客户端的地方注入。\n\n``` java\npackage com.dapr.service.config;\n\nimport io.dapr.client.DaprClient;\nimport io.dapr.client.DaprClientBuilder;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * @author Zhang_Xiang\n * @since 2020/11/8 08:46:49\n */\n@Configuration\npublic class Client {\n\n    @Bean\n    public DaprClient getClient(){\n        return (new DaprClientBuilder()).build();\n    }\n}\n```\n\n接下来在需要调用的 Controller 中添加构造器注入。\n\n``` java\n\n/**\n * SpringBoot Controller to handle input binding.\n *\n * @author zhangxiang\n */\n@RestController\npublic class HelloController {\n\n    private final DaprClient client;\n    ...\n\n    public HelloController(DaprClient client) {\n        this.client = client;\n    }\n    ...\n}\n```\n\n发起 http 请求。\n\n``` java\n...\n\nbyte[] response = client.invokeService(SERVICE_APP_ID, \"say\", message, HttpExtension.POST, null,\n                        byte[].class).block();\n                if (response != null) {\n                    ...\n                }\n...\n```\n\n启动命令：\n\n``` cmd\ndapr run --app-id java-service-b --app-port 9101 --dapr-http-port 3511 -- java -jar target/dapr-java-service-exec.jar com.dapr.service.ServiceB -p 9101\n```\n\n## java-client-a\n\n对于 java-client-a 来说，集成 Springboot 是可选项，此处构造一个每隔 5 秒发起一次请求的客户端。\n\n``` java\npackage com.dapr.client;\n\nimport com.alibaba.fastjson.JSON;\nimport com.common.ResponseResult;\nimport io.dapr.client.DaprClient;\nimport io.dapr.client.DaprClientBuilder;\nimport io.dapr.client.domain.HttpExtension;\n\nimport java.io.IOException;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.TimeZone;\n\n/**\n * @author Zhang_Xiang\n * @since 2020/11/7 17:30:26\n */\npublic class ClientA {\n    /**\n     * Identifier in Dapr for the service this client will invoke.\n     */\n    private static final String SERVICE_APP_ID = \"java-service-b\";\n\n    /**\n     * Format to output date and time.\n     */\n    private static final DateFormat DATE_FORMAT = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\");\n\n    /**\n     * Starts the invoke client.\n     *\n     * @param args Messages to be sent as request for the invoke API.\n     */\n    public static void main(String[] args) throws IOException {\n        try (DaprClient client = (new DaprClientBuilder()).build()) {\n            while (true) {\n                Calendar utcNow = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n                String utcNowAsString = DATE_FORMAT.format(utcNow.getTime());\n                String msg = String.format(\"%s:this this java client A\", utcNowAsString);\n                byte[] response = client.invokeService(SERVICE_APP_ID, \"say\", msg.getBytes(), HttpExtension.POST, null,\n                        byte[].class).block();\n                if (response != null) {\n                    String responseResultStr = new String(response);\n                    ResponseResult responseResult = JSON.parseObject(responseResultStr, ResponseResult.class);\n                    System.out.println(responseResult.getMessage());\n                }\n                try {\n                    Thread.sleep(5000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n启动命令：\n\n``` cmd\ndapr run --app-id java-client-a  --dapr-http-port 3006 -- java -jar target/dapr-java-client-exec.jar com.dapr.client.ClientA\n```\n\n## 总结\n\n各个模块的启动顺序应为：\n\n``` mermaid\ngraph LR;\n    java-service-c-->java-service-b;\n    java-service-b-->java-client-a;\n```\n\n这里限定顺序的原因是，如果先启动 java-client-a ，java-client-a 会立刻通过 dapr 开始发起请求到 java-service-b ,而这时 java-service-b 并未启动。这将触发 dapr 的重试机制。\n\n### 重试\n\n![重试](/img/java/retries.png)\n\n>服务调用在事件调用失败和瞬态错误时，将执行带避退时间间隔（backoff time periods）的自动重试。\n引起重试的错误：\n>\n> - 网络错误，包括终端不可用和拒绝连接。\n> - 身份认证错误，由于在调用方/被调用方的 dapr 边车证书更新导致。\n\n每次重试都以 1 秒的时间避退时间为间隔，最大重试次数为 3 次。和目的地边车通过 gRPC 建立连接 5 秒超时。\n\njava-client-a 打印：\n\n``` cmd\n== APP == This is java-service-b,receive the message:2020-11-08 14:21:14.336:this this java client A,and request java-service-c get the response:{\"message\":\"This is java-service-c,receive the message:\\\"2020-11-08 14:21:14.336:this this java client A\\\"\"}\n```\n\njava-service-b 打印:\n\n``` cmd\n== APP == This is java-service-b,receive the message:2020-11-08 14:21:44.454:this this java client A\n```\n\njava-service-c 打印：\n\n``` cmd\n== APP == This is java-service-c,receive the message:\"2020-11-08 14:22:19.571:this this java client A\"\n```\n\n打开新的命令行窗口，输入 `dapr list`\n\n![dapr-list](../img/java/dapr-http-list.png)\n\n## 启动示例\n\n源码地址：https://github.com/ZhangX-Byte/dapr-java\n\n克隆仓库\n\n``` cmd\ngit clone https://github.com/ZhangX-Byte/dapr-java.git\ncd dapr-java\n```\n\n构建 dapr-java 项目\n\n``` cmd\nmvn install\n```\n\n然后各个项目各自 install 就能正常启动了。\n","source":"_posts/java-invoke-http.md","raw":"---\ntitle: Dapr Java HTTP 调用\ncatalog: true\ntoc_nav_num: true\ndate: 2020-11-04 09:37:41\nsubtitle: java_invoke_http\nheader-img: /img/java/java.jpeg\ntags: \n- Dapr\n- Java\ncatajavaries:\n- Java\n---\n\n## 版本介绍\n\n- Java 版本：8\n- Dapr Java SKD 版本：0.9.2\n\nDapr Java-SDK [HTTP 调用文档](https://github.com/dapr/java-sdk/tree/master/examples/src/main/java/io/dapr/examples/invoke/http) 有个先决条件，内容如下：\n\n- Dapr and Dapr CLI.\n- Java JDK 11 (or greater): Oracle JDK or OpenJDK.\n- Apache Maven version 3.x.\n\n大家看到 Java JDK 版本最低要求是 11，但是本文显示使用的 JDK 8，这么做的原因是什么呢，可以[参考](https://github.com/dapr/java-sdk/issues/279) Java-SDK Issues，Issues 中回答如下：\n\n>We want to validate that the SDK is built with Java 8 and apps can use it with Java 11.\n\n意思是他们想通过 Java 11 写的应用程序验证 Java 8 写的 SDK 是否能正常使用。本文不需要验证 Java 11 能否使用 Java-SDK ，因此本文将使用 Java 8 构建应用程序。\n\n## 工程结构\n\n![项目结构](/img/java/java-http-structure.png)\n\n3 个子工程，一个 client，两个 service。新建两个 service 的意义在于展示 http 链路调用使用 dapr 如何实现。3 个工程项目都集成了 Spring Boot。Spring Boot 启动后会自动注册 Controller、Config 之类的 bean。\n\n```mermaid\ngraph LR;\n    java-client-a--1-->java-service-b;\n    java-service-b--2-->java-service-c;\n    java-service-c--3-->java-service-b;\n    java-service-b--4-->java-client-a;\n```\n\n1. java-client-a 做为客户端调用 java-service-b；\n2. java-service-b 接收请求，并调用 java-service-c；\n3. java-service-c 接收请求，并响应；\n4. java-service-b 收到 java-service-c 应答，并响应 java-client-a 请求。\n\n## java-service-c\n\njava-service-c 做为 http 调用链路末端，只需监听 http 请求即可。\n\n``` java\npackage com.dapr.service;\n\nimport org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.CommandLineParser;\nimport org.apache.commons.cli.DefaultParser;\nimport org.apache.commons.cli.Options;\n\n/**\n * @author Zhang_Xiang\n * @since 2020/11/7 10:51:22\n */\npublic class ServiceC {\n\n    /**\n     * Starts the service.\n     *\n     * @param args Expects the port: -p PORT\n     * @throws Exception If cannot start service.\n     */\n    public static void main(String[] args) throws Exception {\n        Options options = new Options();\n        options.addRequiredOption(\"p\", \"port\", true, \"Port to listen to.\");\n\n        CommandLineParser parser = new DefaultParser();\n        CommandLine cmd = parser.parse(options, args);\n\n        // If port string is not valid, it will throw an exception.\n        int port = Integer.parseInt(cmd.getOptionValue(\"port\"));\n\n        DaprApplication.start(port);\n    }\n}\n```\n\n`DaprApplication.start(port);` 集成 SpringBoot 启动。\n\n``` java\npackage com.dapr.service;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n/**\n * Dapr's HTTP callback implementation via SpringBoot.\n * Scanning package io.dapr.springboot is required.\n *\n * @author zhangxiang\n */\n@SpringBootApplication(scanBasePackages = {\"com.dapr.service\"})\npublic class DaprApplication {\n\n    /**\n     * Starts Dapr's callback in a given port.\n     *\n     * @param port Port to listen to.\n     */\n    public static void start(int port) {\n        SpringApplication app = new SpringApplication(DaprApplication.class);\n        app.run(String.format(\"--server.port=%d\", port));\n    }\n\n}\n```\n\n启动命令：\n\n``` cmd\ndapr run --app-id java-service-c --app-port 9100 --dapr-http-port 3510 -- java -jar target/dapr-java-service-exec.jar com.dapr.service.ServiceC -p 9100\n```\n\n## java-service-b\n\njava-service-b 需要配置一个 DaprClient Bean，以在需要使用 Http 客户端的地方注入。\n\n``` java\npackage com.dapr.service.config;\n\nimport io.dapr.client.DaprClient;\nimport io.dapr.client.DaprClientBuilder;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * @author Zhang_Xiang\n * @since 2020/11/8 08:46:49\n */\n@Configuration\npublic class Client {\n\n    @Bean\n    public DaprClient getClient(){\n        return (new DaprClientBuilder()).build();\n    }\n}\n```\n\n接下来在需要调用的 Controller 中添加构造器注入。\n\n``` java\n\n/**\n * SpringBoot Controller to handle input binding.\n *\n * @author zhangxiang\n */\n@RestController\npublic class HelloController {\n\n    private final DaprClient client;\n    ...\n\n    public HelloController(DaprClient client) {\n        this.client = client;\n    }\n    ...\n}\n```\n\n发起 http 请求。\n\n``` java\n...\n\nbyte[] response = client.invokeService(SERVICE_APP_ID, \"say\", message, HttpExtension.POST, null,\n                        byte[].class).block();\n                if (response != null) {\n                    ...\n                }\n...\n```\n\n启动命令：\n\n``` cmd\ndapr run --app-id java-service-b --app-port 9101 --dapr-http-port 3511 -- java -jar target/dapr-java-service-exec.jar com.dapr.service.ServiceB -p 9101\n```\n\n## java-client-a\n\n对于 java-client-a 来说，集成 Springboot 是可选项，此处构造一个每隔 5 秒发起一次请求的客户端。\n\n``` java\npackage com.dapr.client;\n\nimport com.alibaba.fastjson.JSON;\nimport com.common.ResponseResult;\nimport io.dapr.client.DaprClient;\nimport io.dapr.client.DaprClientBuilder;\nimport io.dapr.client.domain.HttpExtension;\n\nimport java.io.IOException;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.TimeZone;\n\n/**\n * @author Zhang_Xiang\n * @since 2020/11/7 17:30:26\n */\npublic class ClientA {\n    /**\n     * Identifier in Dapr for the service this client will invoke.\n     */\n    private static final String SERVICE_APP_ID = \"java-service-b\";\n\n    /**\n     * Format to output date and time.\n     */\n    private static final DateFormat DATE_FORMAT = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\");\n\n    /**\n     * Starts the invoke client.\n     *\n     * @param args Messages to be sent as request for the invoke API.\n     */\n    public static void main(String[] args) throws IOException {\n        try (DaprClient client = (new DaprClientBuilder()).build()) {\n            while (true) {\n                Calendar utcNow = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n                String utcNowAsString = DATE_FORMAT.format(utcNow.getTime());\n                String msg = String.format(\"%s:this this java client A\", utcNowAsString);\n                byte[] response = client.invokeService(SERVICE_APP_ID, \"say\", msg.getBytes(), HttpExtension.POST, null,\n                        byte[].class).block();\n                if (response != null) {\n                    String responseResultStr = new String(response);\n                    ResponseResult responseResult = JSON.parseObject(responseResultStr, ResponseResult.class);\n                    System.out.println(responseResult.getMessage());\n                }\n                try {\n                    Thread.sleep(5000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n启动命令：\n\n``` cmd\ndapr run --app-id java-client-a  --dapr-http-port 3006 -- java -jar target/dapr-java-client-exec.jar com.dapr.client.ClientA\n```\n\n## 总结\n\n各个模块的启动顺序应为：\n\n``` mermaid\ngraph LR;\n    java-service-c-->java-service-b;\n    java-service-b-->java-client-a;\n```\n\n这里限定顺序的原因是，如果先启动 java-client-a ，java-client-a 会立刻通过 dapr 开始发起请求到 java-service-b ,而这时 java-service-b 并未启动。这将触发 dapr 的重试机制。\n\n### 重试\n\n![重试](/img/java/retries.png)\n\n>服务调用在事件调用失败和瞬态错误时，将执行带避退时间间隔（backoff time periods）的自动重试。\n引起重试的错误：\n>\n> - 网络错误，包括终端不可用和拒绝连接。\n> - 身份认证错误，由于在调用方/被调用方的 dapr 边车证书更新导致。\n\n每次重试都以 1 秒的时间避退时间为间隔，最大重试次数为 3 次。和目的地边车通过 gRPC 建立连接 5 秒超时。\n\njava-client-a 打印：\n\n``` cmd\n== APP == This is java-service-b,receive the message:2020-11-08 14:21:14.336:this this java client A,and request java-service-c get the response:{\"message\":\"This is java-service-c,receive the message:\\\"2020-11-08 14:21:14.336:this this java client A\\\"\"}\n```\n\njava-service-b 打印:\n\n``` cmd\n== APP == This is java-service-b,receive the message:2020-11-08 14:21:44.454:this this java client A\n```\n\njava-service-c 打印：\n\n``` cmd\n== APP == This is java-service-c,receive the message:\"2020-11-08 14:22:19.571:this this java client A\"\n```\n\n打开新的命令行窗口，输入 `dapr list`\n\n![dapr-list](../img/java/dapr-http-list.png)\n\n## 启动示例\n\n源码地址：https://github.com/ZhangX-Byte/dapr-java\n\n克隆仓库\n\n``` cmd\ngit clone https://github.com/ZhangX-Byte/dapr-java.git\ncd dapr-java\n```\n\n构建 dapr-java 项目\n\n``` cmd\nmvn install\n```\n\n然后各个项目各自 install 就能正常启动了。\n","slug":"java-invoke-http","published":1,"updated":"2020-11-08T06:30:33.008Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh8qmyhv000b4x6yfsv14nih","content":"<h2 id=\"版本介绍\">版本介绍</h2>\n<ul>\n<li>Java 版本：8</li>\n<li>Dapr Java SKD 版本：0.9.2</li>\n</ul>\n<p>Dapr Java-SDK <a href=\"https://github.com/dapr/java-sdk/tree/master/examples/src/main/java/io/dapr/examples/invoke/http\" target=\"_blank\" rel=\"noopener\">HTTP 调用文档</a> 有个先决条件，内容如下：</p>\n<ul>\n<li>Dapr and Dapr CLI.</li>\n<li>Java JDK 11 (or greater): Oracle JDK or OpenJDK.</li>\n<li>Apache Maven version 3.x.</li>\n</ul>\n<p>大家看到 Java JDK 版本最低要求是 11，但是本文显示使用的 JDK 8，这么做的原因是什么呢，可以<a href=\"https://github.com/dapr/java-sdk/issues/279\" target=\"_blank\" rel=\"noopener\">参考</a> Java-SDK Issues，Issues 中回答如下：</p>\n<blockquote>\n<p>We want to validate that the SDK is built with Java 8 and apps can use it with Java 11.</p>\n</blockquote>\n<p>意思是他们想通过 Java 11 写的应用程序验证 Java 8 写的 SDK 是否能正常使用。本文不需要验证 Java 11 能否使用 Java-SDK ，因此本文将使用 Java 8 构建应用程序。</p>\n<h2 id=\"工程结构\">工程结构</h2>\n<p><img src=\"/img/java/java-http-structure.png\" alt=\"项目结构\"></p>\n<p>3 个子工程，一个 client，两个 service。新建两个 service 的意义在于展示 http 链路调用使用 dapr 如何实现。3 个工程项目都集成了 Spring Boot。Spring Boot 启动后会自动注册 Controller、Config 之类的 bean。</p>\n<pre class=\"mermaid\">graph LR;\n    java-client-a--1-->java-service-b;\n    java-service-b--2-->java-service-c;\n    java-service-c--3-->java-service-b;\n    java-service-b--4-->java-client-a;</pre>\n<ol>\n<li>java-client-a 做为客户端调用 java-service-b；</li>\n<li>java-service-b 接收请求，并调用 java-service-c；</li>\n<li>java-service-c 接收请求，并响应；</li>\n<li>java-service-b 收到 java-service-c 应答，并响应 java-client-a 请求。</li>\n</ol>\n<h2 id=\"java-service-c\">java-service-c</h2>\n<p>java-service-c 做为 http 调用链路末端，只需监听 http 请求即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.dapr.service;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.commons.cli.CommandLine;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.commons.cli.CommandLineParser;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.commons.cli.DefaultParser;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.commons.cli.Options;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Zhang_Xiang</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 2020/11/7 10:51:22</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServiceC</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Starts the service.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args Expects the port: -p PORT</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Exception If cannot start service.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Options options = <span class=\"keyword\">new</span> Options();</span><br><span class=\"line\">        options.addRequiredOption(<span class=\"string\">\"p\"</span>, <span class=\"string\">\"port\"</span>, <span class=\"keyword\">true</span>, <span class=\"string\">\"Port to listen to.\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        CommandLineParser parser = <span class=\"keyword\">new</span> DefaultParser();</span><br><span class=\"line\">        CommandLine cmd = parser.parse(options, args);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// If port string is not valid, it will throw an exception.</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> port = Integer.parseInt(cmd.getOptionValue(<span class=\"string\">\"port\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        DaprApplication.start(port);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>DaprApplication.start(port);</code> 集成 SpringBoot 启动。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.dapr.service;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.SpringApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Dapr's HTTP callback implementation via SpringBoot.</span></span><br><span class=\"line\"><span class=\"comment\"> * Scanning package io.dapr.springboot is required.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> zhangxiang</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span>(scanBasePackages = &#123;<span class=\"string\">\"com.dapr.service\"</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DaprApplication</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Starts Dapr's callback in a given port.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> port Port to listen to.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">(<span class=\"keyword\">int</span> port)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication app = <span class=\"keyword\">new</span> SpringApplication(DaprApplication.class);</span><br><span class=\"line\">        app.run(String.format(<span class=\"string\">\"--server.port=%d\"</span>, port));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>启动命令：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dapr run --app-id java-service-c --app-port <span class=\"number\">9100</span> --dapr-http-port <span class=\"number\">3510</span> -- java -jar target/dapr-java-service-exec.jar com.dapr.service.ServiceC -p <span class=\"number\">9100</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"java-service-b\">java-service-b</h2>\n<p>java-service-b 需要配置一个 DaprClient Bean，以在需要使用 Http 客户端的地方注入。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.dapr.service.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> io.dapr.client.DaprClient;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.dapr.client.DaprClientBuilder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Zhang_Xiang</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 2020/11/8 08:46:49</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DaprClient <span class=\"title\">getClient</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">new</span> DaprClientBuilder()).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来在需要调用的 Controller 中添加构造器注入。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * SpringBoot Controller to handle input binding.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> zhangxiang</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> DaprClient client;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HelloController</span><span class=\"params\">(DaprClient client)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.client = client;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>发起 http 请求。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] response = client.invokeService(SERVICE_APP_ID, <span class=\"string\">\"say\"</span>, message, HttpExtension.POST, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                        <span class=\"keyword\">byte</span>[].class).block();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (response != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    ...</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>启动命令：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dapr run --app-id java-service-b --app-port <span class=\"number\">9101</span> --dapr-http-port <span class=\"number\">3511</span> -- java -jar target/dapr-java-service-exec.jar com.dapr.service.ServiceB -p <span class=\"number\">9101</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"java-client-a\">java-client-a</h2>\n<p>对于 java-client-a 来说，集成 Springboot 是可选项，此处构造一个每隔 5 秒发起一次请求的客户端。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.dapr.client;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.fastjson.JSON;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.common.ResponseResult;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.dapr.client.DaprClient;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.dapr.client.DaprClientBuilder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.dapr.client.domain.HttpExtension;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.text.DateFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.text.SimpleDateFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Calendar;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.TimeZone;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Zhang_Xiang</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 2020/11/7 17:30:26</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientA</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Identifier in Dapr for the service this client will invoke.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String SERVICE_APP_ID = <span class=\"string\">\"java-service-b\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Format to output date and time.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> DateFormat DATE_FORMAT = <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">\"yyyy-MM-dd HH:mm:ss.SSS\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Starts the invoke client.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args Messages to be sent as request for the invoke API.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (DaprClient client = (<span class=\"keyword\">new</span> DaprClientBuilder()).build()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                Calendar utcNow = Calendar.getInstance(TimeZone.getTimeZone(<span class=\"string\">\"GMT\"</span>));</span><br><span class=\"line\">                String utcNowAsString = DATE_FORMAT.format(utcNow.getTime());</span><br><span class=\"line\">                String msg = String.format(<span class=\"string\">\"%s:this this java client A\"</span>, utcNowAsString);</span><br><span class=\"line\">                <span class=\"keyword\">byte</span>[] response = client.invokeService(SERVICE_APP_ID, <span class=\"string\">\"say\"</span>, msg.getBytes(), HttpExtension.POST, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                        <span class=\"keyword\">byte</span>[].class).block();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (response != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    String responseResultStr = <span class=\"keyword\">new</span> String(response);</span><br><span class=\"line\">                    ResponseResult responseResult = JSON.parseObject(responseResultStr, ResponseResult.class);</span><br><span class=\"line\">                    System.out.println(responseResult.getMessage());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>启动命令：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dapr run --app-id java-client-a  --dapr-http-port <span class=\"number\">3006</span> -- java -jar target/dapr-java-client-exec.jar com.dapr.client.ClientA</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\">总结</h2>\n<p>各个模块的启动顺序应为：</p>\n<pre class=\"mermaid\">graph LR;\n    java-service-c-->java-service-b;\n    java-service-b-->java-client-a;</pre>\n<p>这里限定顺序的原因是，如果先启动 java-client-a ，java-client-a 会立刻通过 dapr 开始发起请求到 java-service-b ,而这时 java-service-b 并未启动。这将触发 dapr 的重试机制。</p>\n<h3 id=\"重试\">重试</h3>\n<p><img src=\"/img/java/retries.png\" alt=\"重试\"></p>\n<blockquote>\n<p>服务调用在事件调用失败和瞬态错误时，将执行带避退时间间隔（backoff time periods）的自动重试。<br>\n引起重试的错误：</p>\n<ul>\n<li>网络错误，包括终端不可用和拒绝连接。</li>\n<li>身份认证错误，由于在调用方/被调用方的 dapr 边车证书更新导致。</li>\n</ul>\n</blockquote>\n<p>每次重试都以 1 秒的时间避退时间为间隔，最大重试次数为 3 次。和目的地边车通过 gRPC 建立连接 5 秒超时。</p>\n<p>java-client-a 打印：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">== APP == This is java-service-b,receive the message:<span class=\"number\">2020</span>-<span class=\"number\">11</span>-<span class=\"number\">08</span> <span class=\"number\">14</span>:<span class=\"number\">21</span>:<span class=\"number\">14</span>.<span class=\"number\">336</span>:this this java client A,and request java-service-c get the response:&#123;\"message\":\"This is java-service-c,receive the message:\\\"<span class=\"number\">2020</span>-<span class=\"number\">11</span>-<span class=\"number\">08</span> <span class=\"number\">14</span>:<span class=\"number\">21</span>:<span class=\"number\">14</span>.<span class=\"number\">336</span>:this this java client A\\\"\"&#125;</span><br></pre></td></tr></table></figure>\n<p>java-service-b 打印:</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">== APP == This is java-service-b,receive the message:<span class=\"number\">2020</span>-<span class=\"number\">11</span>-<span class=\"number\">08</span> <span class=\"number\">14</span>:<span class=\"number\">21</span>:<span class=\"number\">44</span>.<span class=\"number\">454</span>:this this java client A</span><br></pre></td></tr></table></figure>\n<p>java-service-c 打印：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">== APP == This is java-service-c,receive the message:\"<span class=\"number\">2020</span>-<span class=\"number\">11</span>-<span class=\"number\">08</span> <span class=\"number\">14</span>:<span class=\"number\">22</span>:<span class=\"number\">19</span>.<span class=\"number\">571</span>:this this java client A\"</span><br></pre></td></tr></table></figure>\n<p>打开新的命令行窗口，输入 <code>dapr list</code></p>\n<p><img src=\"../img/java/dapr-http-list.png\" alt=\"dapr-list\"></p>\n<h2 id=\"启动示例\">启动示例</h2>\n<p>源码地址：<a href=\"https://github.com/ZhangX-Byte/dapr-java\" target=\"_blank\" rel=\"noopener\">https://github.com/ZhangX-Byte/dapr-java</a></p>\n<p>克隆仓库</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/ZhangX-Byte/dapr-java.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> dapr-java</span><br></pre></td></tr></table></figure>\n<p>构建 dapr-java 项目</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn install</span><br></pre></td></tr></table></figure>\n<p>然后各个项目各自 install 就能正常启动了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>版本介绍</h2>\n<ul>\n<li>Java 版本：8</li>\n<li>Dapr Java SKD 版本：0.9.2</li>\n</ul>\n<p>Dapr Java-SDK <a href=\"https://github.com/dapr/java-sdk/tree/master/examples/src/main/java/io/dapr/examples/invoke/http\" target=\"_blank\" rel=\"noopener\">HTTP 调用文档</a> 有个先决条件，内容如下：</p>\n<ul>\n<li>Dapr and Dapr CLI.</li>\n<li>Java JDK 11 (or greater): Oracle JDK or OpenJDK.</li>\n<li>Apache Maven version 3.x.</li>\n</ul>\n<p>大家看到 Java JDK 版本最低要求是 11，但是本文显示使用的 JDK 8，这么做的原因是什么呢，可以<a href=\"https://github.com/dapr/java-sdk/issues/279\" target=\"_blank\" rel=\"noopener\">参考</a> Java-SDK Issues，Issues 中回答如下：</p>\n<blockquote>\n<p>We want to validate that the SDK is built with Java 8 and apps can use it with Java 11.</p>\n</blockquote>\n<p>意思是他们想通过 Java 11 写的应用程序验证 Java 8 写的 SDK 是否能正常使用。本文不需要验证 Java 11 能否使用 Java-SDK ，因此本文将使用 Java 8 构建应用程序。</p>\n<h2>工程结构</h2>\n<p><img src=\"/img/java/java-http-structure.png\" alt=\"项目结构\"></p>\n<p>3 个子工程，一个 client，两个 service。新建两个 service 的意义在于展示 http 链路调用使用 dapr 如何实现。3 个工程项目都集成了 Spring Boot。Spring Boot 启动后会自动注册 Controller、Config 之类的 bean。</p>\n<pre class=\"mermaid\">graph LR;\n    java-client-a--1-->java-service-b;\n    java-service-b--2-->java-service-c;\n    java-service-c--3-->java-service-b;\n    java-service-b--4-->java-client-a;</pre>\n<ol>\n<li>java-client-a 做为客户端调用 java-service-b；</li>\n<li>java-service-b 接收请求，并调用 java-service-c；</li>\n<li>java-service-c 接收请求，并响应；</li>\n<li>java-service-b 收到 java-service-c 应答，并响应 java-client-a 请求。</li>\n</ol>\n<h2>java-service-c</h2>\n<p>java-service-c 做为 http 调用链路末端，只需监听 http 请求即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.dapr.service;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.commons.cli.CommandLine;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.commons.cli.CommandLineParser;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.commons.cli.DefaultParser;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.commons.cli.Options;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Zhang_Xiang</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 2020/11/7 10:51:22</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServiceC</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Starts the service.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args Expects the port: -p PORT</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Exception If cannot start service.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Options options = <span class=\"keyword\">new</span> Options();</span><br><span class=\"line\">        options.addRequiredOption(<span class=\"string\">\"p\"</span>, <span class=\"string\">\"port\"</span>, <span class=\"keyword\">true</span>, <span class=\"string\">\"Port to listen to.\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        CommandLineParser parser = <span class=\"keyword\">new</span> DefaultParser();</span><br><span class=\"line\">        CommandLine cmd = parser.parse(options, args);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// If port string is not valid, it will throw an exception.</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> port = Integer.parseInt(cmd.getOptionValue(<span class=\"string\">\"port\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        DaprApplication.start(port);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>DaprApplication.start(port);</code> 集成 SpringBoot 启动。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.dapr.service;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.SpringApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Dapr's HTTP callback implementation via SpringBoot.</span></span><br><span class=\"line\"><span class=\"comment\"> * Scanning package io.dapr.springboot is required.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> zhangxiang</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span>(scanBasePackages = &#123;<span class=\"string\">\"com.dapr.service\"</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DaprApplication</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Starts Dapr's callback in a given port.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> port Port to listen to.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">(<span class=\"keyword\">int</span> port)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication app = <span class=\"keyword\">new</span> SpringApplication(DaprApplication.class);</span><br><span class=\"line\">        app.run(String.format(<span class=\"string\">\"--server.port=%d\"</span>, port));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>启动命令：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dapr run --app-id java-service-c --app-port <span class=\"number\">9100</span> --dapr-http-port <span class=\"number\">3510</span> -- java -jar target/dapr-java-service-exec.jar com.dapr.service.ServiceC -p <span class=\"number\">9100</span></span><br></pre></td></tr></table></figure>\n<h2>java-service-b</h2>\n<p>java-service-b 需要配置一个 DaprClient Bean，以在需要使用 Http 客户端的地方注入。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.dapr.service.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> io.dapr.client.DaprClient;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.dapr.client.DaprClientBuilder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Zhang_Xiang</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 2020/11/8 08:46:49</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DaprClient <span class=\"title\">getClient</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">new</span> DaprClientBuilder()).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来在需要调用的 Controller 中添加构造器注入。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * SpringBoot Controller to handle input binding.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> zhangxiang</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> DaprClient client;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HelloController</span><span class=\"params\">(DaprClient client)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.client = client;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>发起 http 请求。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] response = client.invokeService(SERVICE_APP_ID, <span class=\"string\">\"say\"</span>, message, HttpExtension.POST, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                        <span class=\"keyword\">byte</span>[].class).block();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (response != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    ...</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>启动命令：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dapr run --app-id java-service-b --app-port <span class=\"number\">9101</span> --dapr-http-port <span class=\"number\">3511</span> -- java -jar target/dapr-java-service-exec.jar com.dapr.service.ServiceB -p <span class=\"number\">9101</span></span><br></pre></td></tr></table></figure>\n<h2>java-client-a</h2>\n<p>对于 java-client-a 来说，集成 Springboot 是可选项，此处构造一个每隔 5 秒发起一次请求的客户端。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.dapr.client;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.fastjson.JSON;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.common.ResponseResult;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.dapr.client.DaprClient;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.dapr.client.DaprClientBuilder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.dapr.client.domain.HttpExtension;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.text.DateFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.text.SimpleDateFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Calendar;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.TimeZone;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Zhang_Xiang</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 2020/11/7 17:30:26</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientA</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Identifier in Dapr for the service this client will invoke.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String SERVICE_APP_ID = <span class=\"string\">\"java-service-b\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Format to output date and time.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> DateFormat DATE_FORMAT = <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">\"yyyy-MM-dd HH:mm:ss.SSS\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Starts the invoke client.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args Messages to be sent as request for the invoke API.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (DaprClient client = (<span class=\"keyword\">new</span> DaprClientBuilder()).build()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                Calendar utcNow = Calendar.getInstance(TimeZone.getTimeZone(<span class=\"string\">\"GMT\"</span>));</span><br><span class=\"line\">                String utcNowAsString = DATE_FORMAT.format(utcNow.getTime());</span><br><span class=\"line\">                String msg = String.format(<span class=\"string\">\"%s:this this java client A\"</span>, utcNowAsString);</span><br><span class=\"line\">                <span class=\"keyword\">byte</span>[] response = client.invokeService(SERVICE_APP_ID, <span class=\"string\">\"say\"</span>, msg.getBytes(), HttpExtension.POST, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                        <span class=\"keyword\">byte</span>[].class).block();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (response != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    String responseResultStr = <span class=\"keyword\">new</span> String(response);</span><br><span class=\"line\">                    ResponseResult responseResult = JSON.parseObject(responseResultStr, ResponseResult.class);</span><br><span class=\"line\">                    System.out.println(responseResult.getMessage());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>启动命令：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dapr run --app-id java-client-a  --dapr-http-port <span class=\"number\">3006</span> -- java -jar target/dapr-java-client-exec.jar com.dapr.client.ClientA</span><br></pre></td></tr></table></figure>\n<h2>总结</h2>\n<p>各个模块的启动顺序应为：</p>\n<pre class=\"mermaid\">graph LR;\n    java-service-c-->java-service-b;\n    java-service-b-->java-client-a;</pre>\n<p>这里限定顺序的原因是，如果先启动 java-client-a ，java-client-a 会立刻通过 dapr 开始发起请求到 java-service-b ,而这时 java-service-b 并未启动。这将触发 dapr 的重试机制。</p>\n<h3>重试</h3>\n<p><img src=\"/img/java/retries.png\" alt=\"重试\"></p>\n<blockquote>\n<p>服务调用在事件调用失败和瞬态错误时，将执行带避退时间间隔（backoff time periods）的自动重试。<br>\n引起重试的错误：</p>\n<ul>\n<li>网络错误，包括终端不可用和拒绝连接。</li>\n<li>身份认证错误，由于在调用方/被调用方的 dapr 边车证书更新导致。</li>\n</ul>\n</blockquote>\n<p>每次重试都以 1 秒的时间避退时间为间隔，最大重试次数为 3 次。和目的地边车通过 gRPC 建立连接 5 秒超时。</p>\n<p>java-client-a 打印：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">== APP == This is java-service-b,receive the message:<span class=\"number\">2020</span>-<span class=\"number\">11</span>-<span class=\"number\">08</span> <span class=\"number\">14</span>:<span class=\"number\">21</span>:<span class=\"number\">14</span>.<span class=\"number\">336</span>:this this java client A,and request java-service-c get the response:&#123;\"message\":\"This is java-service-c,receive the message:\\\"<span class=\"number\">2020</span>-<span class=\"number\">11</span>-<span class=\"number\">08</span> <span class=\"number\">14</span>:<span class=\"number\">21</span>:<span class=\"number\">14</span>.<span class=\"number\">336</span>:this this java client A\\\"\"&#125;</span><br></pre></td></tr></table></figure>\n<p>java-service-b 打印:</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">== APP == This is java-service-b,receive the message:<span class=\"number\">2020</span>-<span class=\"number\">11</span>-<span class=\"number\">08</span> <span class=\"number\">14</span>:<span class=\"number\">21</span>:<span class=\"number\">44</span>.<span class=\"number\">454</span>:this this java client A</span><br></pre></td></tr></table></figure>\n<p>java-service-c 打印：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">== APP == This is java-service-c,receive the message:\"<span class=\"number\">2020</span>-<span class=\"number\">11</span>-<span class=\"number\">08</span> <span class=\"number\">14</span>:<span class=\"number\">22</span>:<span class=\"number\">19</span>.<span class=\"number\">571</span>:this this java client A\"</span><br></pre></td></tr></table></figure>\n<p>打开新的命令行窗口，输入 <code>dapr list</code></p>\n<p><img src=\"../img/java/dapr-http-list.png\" alt=\"dapr-list\"></p>\n<h2>启动示例</h2>\n<p>源码地址：<a href=\"https://github.com/ZhangX-Byte/dapr-java\" target=\"_blank\" rel=\"noopener\">https://github.com/ZhangX-Byte/dapr-java</a></p>\n<p>克隆仓库</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/ZhangX-Byte/dapr-java.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> dapr-java</span><br></pre></td></tr></table></figure>\n<p>构建 dapr-java 项目</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn install</span><br></pre></td></tr></table></figure>\n<p>然后各个项目各自 install 就能正常启动了。</p>\n"},{"title":"服务调用 API 规范","catalog":true,"toc_nav_num":true,"date":"2020-09-15T14:21:27.000Z","subtitle":"docs/reference/api/","header-img":"/img/dapr/dapr.svg","catagories":["Dapr"],"_content":"\n## 服务调用 API 规范\n\n---\n\nDapr 给用户提供使用唯一 ID 调用其它应用程序的能力。这个功能允许应用程序通过名称标识符和其它应用程序交互，把服务发现的重担交给 Dapr 运行时。\n\n### 内容\n\n- 在远程 Dapr 应用程序上调用一个方法\n\n### 在远程 Dapr 应用程序上调用一个方法\n\n---\n\n这个终端使你能够调用另一个 Dapr 应用程序启用的方法。\n\n#### HTTP 请求\n\n``` cmd\nPOST/GET/PUT/DELETE http://localhost:<daprPort>/v1.0/invoke/<appId>/method/<method-name>\n```\n\n#### HTTP 应答编码\n\n当一个服务通过 Dapr 调用另一个服务时，被调用的服务状态码会返回给调用方。如果有网络错误或者其它瞬态错误， Dapr 将会返回 `500` 错误并带着详细错误信息。\n\n如果用户通过HTTP调用Dapr来与启用了gRPC的服务对话，被调用的 gRPC 服务错误返回 `500` ，成功返回 `200OK`。\n\n代码|描述\n--|--\n500|请求失败\n\n#### URL 参数\n\n参数|描述\n--|--\ndaprPort｜Dapr 端口\nappId｜远程应用程序 ID\nmethod-name｜调用远程应用程序的方法名称或者 url\n\n#### 请求内容\n\n在请求中，你可以传递请求头：\n\n``` json\n{\n  \"Content-Type\": \"application/json\"\n}\n```\n\n在请求消息体中放置你想发送到服务的数据：\n\n``` json\n{\n  \"arg1\": 10,\n  \"arg2\": 23,\n  \"operator\": \"+\"\n}\n```\n\n#### 通过调用服务接收请求\n\n一旦你的服务代码通过 Dapr 调用另一个服务启用的方法，Dapr 将会发送请求（伴随着请求头和消息体）到应用的 `<method-name>` 终端。\n\n被调用的 Dapr 应用程序监听并且在那个终端应答请求。\n\n#### 跨命名空间调用\n\n在支持命名空间的托管平台，Dapr 应用程序 ID 遵循有效的 FQDN（Fully Qualified Domain Name，全限定域名）转换，包含目标命名空间。例如，以下字符串包含应用程序 ID（myApp），此外应用程序运行的命名空间（production）。\n\n``` cmd\nmyApp.production\n```\n\n支持命名空间平台\n\n- K8S\n\n#### 示例\n\n调用 `mathService` 中的 `add` 方法：\n\n``` curl\ncurl http://localhost:3500/v1.0/invoke/mathService/method/add \\\n  -H \"Content-Type: application/json\"\n  -d '{ \"arg1\": 10, \"arg2\": 23}'\n```\n\n`mathService` 服务需要监听 `/add` 终端以接收和处理请求。\n\nNode 应用程序像这样：\n\n``` nodejs\napp.post('/add', (req, res) => {\n  let args = req.body;\n  const [operandOne, operandTwo] = [Number(args['arg1']), Number(args['arg2'])];\n  \n  let result = operandOne + operandTwo;\n  res.send(result.toString());\n});\n\napp.listen(port, () => console.log(`Listening on port ${port}!`));\n```\n\n> 远程终端应答将在应答消息体中返回。\n\n如果你的服务监听路径嵌套较多（比如：`/api/v1/add`），Dapr 实现了完整的反向代理，所以你可以追加所有需要的路径分段到你的请求 URL 里，例如：\n\n``` url\nhttp://localhost:3500/v1.0/invoke/mathService/method/api/v1/add\n```\n\n如果你调用的 `mathService` 在不同的命名空间中，你可以使用下列 URL：\n\n``` url\nhttp://localhost:3500/v1.0/invoke/mathService.testing/method/api/v1/add\n```\n\n在这个 URL 中，`testing` 是 `mathService` 运行的命名空间。\n","source":"_posts/service-invocation-api.md","raw":"---\ntitle: 服务调用 API 规范\ncatalog: true\ntoc_nav_num: true\ndate: 2020-09-15 22:21:27\nsubtitle: docs/reference/api/\nheader-img: /img/dapr/dapr.svg\ntags:\n- Dapr\n- 原文翻译\ncatagories:\n- Dapr\n---\n\n## 服务调用 API 规范\n\n---\n\nDapr 给用户提供使用唯一 ID 调用其它应用程序的能力。这个功能允许应用程序通过名称标识符和其它应用程序交互，把服务发现的重担交给 Dapr 运行时。\n\n### 内容\n\n- 在远程 Dapr 应用程序上调用一个方法\n\n### 在远程 Dapr 应用程序上调用一个方法\n\n---\n\n这个终端使你能够调用另一个 Dapr 应用程序启用的方法。\n\n#### HTTP 请求\n\n``` cmd\nPOST/GET/PUT/DELETE http://localhost:<daprPort>/v1.0/invoke/<appId>/method/<method-name>\n```\n\n#### HTTP 应答编码\n\n当一个服务通过 Dapr 调用另一个服务时，被调用的服务状态码会返回给调用方。如果有网络错误或者其它瞬态错误， Dapr 将会返回 `500` 错误并带着详细错误信息。\n\n如果用户通过HTTP调用Dapr来与启用了gRPC的服务对话，被调用的 gRPC 服务错误返回 `500` ，成功返回 `200OK`。\n\n代码|描述\n--|--\n500|请求失败\n\n#### URL 参数\n\n参数|描述\n--|--\ndaprPort｜Dapr 端口\nappId｜远程应用程序 ID\nmethod-name｜调用远程应用程序的方法名称或者 url\n\n#### 请求内容\n\n在请求中，你可以传递请求头：\n\n``` json\n{\n  \"Content-Type\": \"application/json\"\n}\n```\n\n在请求消息体中放置你想发送到服务的数据：\n\n``` json\n{\n  \"arg1\": 10,\n  \"arg2\": 23,\n  \"operator\": \"+\"\n}\n```\n\n#### 通过调用服务接收请求\n\n一旦你的服务代码通过 Dapr 调用另一个服务启用的方法，Dapr 将会发送请求（伴随着请求头和消息体）到应用的 `<method-name>` 终端。\n\n被调用的 Dapr 应用程序监听并且在那个终端应答请求。\n\n#### 跨命名空间调用\n\n在支持命名空间的托管平台，Dapr 应用程序 ID 遵循有效的 FQDN（Fully Qualified Domain Name，全限定域名）转换，包含目标命名空间。例如，以下字符串包含应用程序 ID（myApp），此外应用程序运行的命名空间（production）。\n\n``` cmd\nmyApp.production\n```\n\n支持命名空间平台\n\n- K8S\n\n#### 示例\n\n调用 `mathService` 中的 `add` 方法：\n\n``` curl\ncurl http://localhost:3500/v1.0/invoke/mathService/method/add \\\n  -H \"Content-Type: application/json\"\n  -d '{ \"arg1\": 10, \"arg2\": 23}'\n```\n\n`mathService` 服务需要监听 `/add` 终端以接收和处理请求。\n\nNode 应用程序像这样：\n\n``` nodejs\napp.post('/add', (req, res) => {\n  let args = req.body;\n  const [operandOne, operandTwo] = [Number(args['arg1']), Number(args['arg2'])];\n  \n  let result = operandOne + operandTwo;\n  res.send(result.toString());\n});\n\napp.listen(port, () => console.log(`Listening on port ${port}!`));\n```\n\n> 远程终端应答将在应答消息体中返回。\n\n如果你的服务监听路径嵌套较多（比如：`/api/v1/add`），Dapr 实现了完整的反向代理，所以你可以追加所有需要的路径分段到你的请求 URL 里，例如：\n\n``` url\nhttp://localhost:3500/v1.0/invoke/mathService/method/api/v1/add\n```\n\n如果你调用的 `mathService` 在不同的命名空间中，你可以使用下列 URL：\n\n``` url\nhttp://localhost:3500/v1.0/invoke/mathService.testing/method/api/v1/add\n```\n\n在这个 URL 中，`testing` 是 `mathService` 运行的命名空间。\n","slug":"service-invocation-api","published":1,"updated":"2020-09-16T02:26:43.050Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh8qmyhy000e4x6yamno71z6","content":"<h2 id=\"服务调用-api-规范\">服务调用 API 规范</h2>\n<hr>\n<p>Dapr 给用户提供使用唯一 ID 调用其它应用程序的能力。这个功能允许应用程序通过名称标识符和其它应用程序交互，把服务发现的重担交给 Dapr 运行时。</p>\n<h3 id=\"内容\">内容</h3>\n<ul>\n<li>在远程 Dapr 应用程序上调用一个方法</li>\n</ul>\n<h3 id=\"在远程-dapr-应用程序上调用一个方法\">在远程 Dapr 应用程序上调用一个方法</h3>\n<hr>\n<p>这个终端使你能够调用另一个 Dapr 应用程序启用的方法。</p>\n<h4 id=\"http-请求\">HTTP 请求</h4>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST/GET/PUT/DELETE http://localhost:&lt;daprPort&gt;/v1.<span class=\"number\">0</span>/invoke/&lt;appId&gt;/method/&lt;method-name&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"http-应答编码\">HTTP 应答编码</h4>\n<p>当一个服务通过 Dapr 调用另一个服务时，被调用的服务状态码会返回给调用方。如果有网络错误或者其它瞬态错误， Dapr 将会返回 <code>500</code> 错误并带着详细错误信息。</p>\n<p>如果用户通过HTTP调用Dapr来与启用了gRPC的服务对话，被调用的 gRPC 服务错误返回 <code>500</code> ，成功返回 <code>200OK</code>。</p>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>500</td>\n<td>请求失败</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"url-参数\">URL 参数</h4>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody></tbody>\n</table>\n<p>daprPort｜Dapr 端口<br>\nappId｜远程应用程序 ID<br>\nmethod-name｜调用远程应用程序的方法名称或者 url</p>\n<h4 id=\"请求内容\">请求内容</h4>\n<p>在请求中，你可以传递请求头：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"Content-Type\"</span>: <span class=\"string\">\"application/json\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在请求消息体中放置你想发送到服务的数据：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"arg1\"</span>: <span class=\"number\">10</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"arg2\"</span>: <span class=\"number\">23</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"operator\"</span>: <span class=\"string\">\"+\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"通过调用服务接收请求\">通过调用服务接收请求</h4>\n<p>一旦你的服务代码通过 Dapr 调用另一个服务启用的方法，Dapr 将会发送请求（伴随着请求头和消息体）到应用的 <code>&lt;method-name&gt;</code> 终端。</p>\n<p>被调用的 Dapr 应用程序监听并且在那个终端应答请求。</p>\n<h4 id=\"跨命名空间调用\">跨命名空间调用</h4>\n<p>在支持命名空间的托管平台，Dapr 应用程序 ID 遵循有效的 FQDN（Fully Qualified Domain Name，全限定域名）转换，包含目标命名空间。例如，以下字符串包含应用程序 ID（myApp），此外应用程序运行的命名空间（production）。</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myApp.production</span><br></pre></td></tr></table></figure>\n<p>支持命名空间平台</p>\n<ul>\n<li>K8S</li>\n</ul>\n<h4 id=\"示例\">示例</h4>\n<p>调用 <code>mathService</code> 中的 <code>add</code> 方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http://localhost:3500/v1.0/invoke/mathService/method/add \\</span><br><span class=\"line\">  -H &quot;Content-Type: application/json&quot;</span><br><span class=\"line\">  -d &apos;&#123; &quot;arg1&quot;: 10, &quot;arg2&quot;: 23&#125;&apos;</span><br></pre></td></tr></table></figure>\n<p><code>mathService</code> 服务需要监听 <code>/add</code> 终端以接收和处理请求。</p>\n<p>Node 应用程序像这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.post(&apos;/add&apos;, (req, res) =&gt; &#123;</span><br><span class=\"line\">  let args = req.body;</span><br><span class=\"line\">  const [operandOne, operandTwo] = [Number(args[&apos;arg1&apos;]), Number(args[&apos;arg2&apos;])];</span><br><span class=\"line\">  </span><br><span class=\"line\">  let result = operandOne + operandTwo;</span><br><span class=\"line\">  res.send(result.toString());</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(port, () =&gt; console.log(`Listening on port $&#123;port&#125;!`));</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>远程终端应答将在应答消息体中返回。</p>\n</blockquote>\n<p>如果你的服务监听路径嵌套较多（比如：<code>/api/v1/add</code>），Dapr 实现了完整的反向代理，所以你可以追加所有需要的路径分段到你的请求 URL 里，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost:3500/v1.0/invoke/mathService/method/api/v1/add</span><br></pre></td></tr></table></figure>\n<p>如果你调用的 <code>mathService</code> 在不同的命名空间中，你可以使用下列 URL：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost:3500/v1.0/invoke/mathService.testing/method/api/v1/add</span><br></pre></td></tr></table></figure>\n<p>在这个 URL 中，<code>testing</code> 是 <code>mathService</code> 运行的命名空间。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>服务调用 API 规范</h2>\n<hr>\n<p>Dapr 给用户提供使用唯一 ID 调用其它应用程序的能力。这个功能允许应用程序通过名称标识符和其它应用程序交互，把服务发现的重担交给 Dapr 运行时。</p>\n<h3>内容</h3>\n<ul>\n<li>在远程 Dapr 应用程序上调用一个方法</li>\n</ul>\n<h3>在远程 Dapr 应用程序上调用一个方法</h3>\n<hr>\n<p>这个终端使你能够调用另一个 Dapr 应用程序启用的方法。</p>\n<h4>HTTP 请求</h4>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST/GET/PUT/DELETE http://localhost:&lt;daprPort&gt;/v1.<span class=\"number\">0</span>/invoke/&lt;appId&gt;/method/&lt;method-name&gt;</span><br></pre></td></tr></table></figure>\n<h4>HTTP 应答编码</h4>\n<p>当一个服务通过 Dapr 调用另一个服务时，被调用的服务状态码会返回给调用方。如果有网络错误或者其它瞬态错误， Dapr 将会返回 <code>500</code> 错误并带着详细错误信息。</p>\n<p>如果用户通过HTTP调用Dapr来与启用了gRPC的服务对话，被调用的 gRPC 服务错误返回 <code>500</code> ，成功返回 <code>200OK</code>。</p>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>500</td>\n<td>请求失败</td>\n</tr>\n</tbody>\n</table>\n<h4>URL 参数</h4>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody></tbody>\n</table>\n<p>daprPort｜Dapr 端口<br>\nappId｜远程应用程序 ID<br>\nmethod-name｜调用远程应用程序的方法名称或者 url</p>\n<h4>请求内容</h4>\n<p>在请求中，你可以传递请求头：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"Content-Type\"</span>: <span class=\"string\">\"application/json\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在请求消息体中放置你想发送到服务的数据：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"arg1\"</span>: <span class=\"number\">10</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"arg2\"</span>: <span class=\"number\">23</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"operator\"</span>: <span class=\"string\">\"+\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4>通过调用服务接收请求</h4>\n<p>一旦你的服务代码通过 Dapr 调用另一个服务启用的方法，Dapr 将会发送请求（伴随着请求头和消息体）到应用的 <code>&lt;method-name&gt;</code> 终端。</p>\n<p>被调用的 Dapr 应用程序监听并且在那个终端应答请求。</p>\n<h4>跨命名空间调用</h4>\n<p>在支持命名空间的托管平台，Dapr 应用程序 ID 遵循有效的 FQDN（Fully Qualified Domain Name，全限定域名）转换，包含目标命名空间。例如，以下字符串包含应用程序 ID（myApp），此外应用程序运行的命名空间（production）。</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myApp.production</span><br></pre></td></tr></table></figure>\n<p>支持命名空间平台</p>\n<ul>\n<li>K8S</li>\n</ul>\n<h4>示例</h4>\n<p>调用 <code>mathService</code> 中的 <code>add</code> 方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http://localhost:3500/v1.0/invoke/mathService/method/add \\</span><br><span class=\"line\">  -H &quot;Content-Type: application/json&quot;</span><br><span class=\"line\">  -d &apos;&#123; &quot;arg1&quot;: 10, &quot;arg2&quot;: 23&#125;&apos;</span><br></pre></td></tr></table></figure>\n<p><code>mathService</code> 服务需要监听 <code>/add</code> 终端以接收和处理请求。</p>\n<p>Node 应用程序像这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.post(&apos;/add&apos;, (req, res) =&gt; &#123;</span><br><span class=\"line\">  let args = req.body;</span><br><span class=\"line\">  const [operandOne, operandTwo] = [Number(args[&apos;arg1&apos;]), Number(args[&apos;arg2&apos;])];</span><br><span class=\"line\">  </span><br><span class=\"line\">  let result = operandOne + operandTwo;</span><br><span class=\"line\">  res.send(result.toString());</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(port, () =&gt; console.log(`Listening on port $&#123;port&#125;!`));</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>远程终端应答将在应答消息体中返回。</p>\n</blockquote>\n<p>如果你的服务监听路径嵌套较多（比如：<code>/api/v1/add</code>），Dapr 实现了完整的反向代理，所以你可以追加所有需要的路径分段到你的请求 URL 里，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost:3500/v1.0/invoke/mathService/method/api/v1/add</span><br></pre></td></tr></table></figure>\n<p>如果你调用的 <code>mathService</code> 在不同的命名空间中，你可以使用下列 URL：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost:3500/v1.0/invoke/mathService.testing/method/api/v1/add</span><br></pre></td></tr></table></figure>\n<p>在这个 URL 中，<code>testing</code> 是 <code>mathService</code> 运行的命名空间。</p>\n"},{"title":"调用远程服务","catalog":true,"toc_nav_num":true,"date":"2020-09-15T12:57:09.000Z","subtitle":"docs/howto/invoke-and-discover-services/","header-img":"/img/dapr/dapr.svg","catagories":["Dapr"],"_content":"\n## 调用远程服务\n\n---\n\n在很多环境中，多个服务需要互相通讯，开发者常常会问自己以下问题：\n\n- 如何发现和调用不同的服务？\n- 如何处理重试和瞬态错误？\n- 如何正确使用分布式跟踪来查看调用图？\n\nDapr 通过提供一个端点，将反向代理与内置服务发现结合起来，同时利用内置分布式跟踪和错误处理，可以使开发人员克服这些挑战。\n\n更多关于服务调用的信息，阅读{% post_link service-invocation 概念文档 %}\n\n### 为你的服务选择 ID\n\nDapr 允许你为应用程序分配一个全局、唯一的 ID。\n\n这个 ID 封装你的应用程序状态，不管有多少个实例。\n\n#### 使用 Dapr 命令行界面设置 ID\n\n在标准模式下，设置 --app-id 标记：\n\n``` CMD\ndapr run --app-id cart --app-port 5000 python app.py\n```\n\n#### 使用 K8S 设置 ID\n\n在 K8S 中，在 pod 中设置 dapr.io/app-id ：\n\n``` yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: python-app\n  namespace: default\n  labels:\n    app: python-app\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: python-app\n  template:\n    metadata:\n      labels:\n        app: python-app\n      annotations:\n        dapr.io/enabled: \"true\"\n        dapr.io/app-id: \"cart\"\n        dapr.io/app-port: \"5000\"\n...\n\n```\n\n#### 在代码中调用服务\n\nDapr 使用边车、去中心化架构。使用 Dapr 调用应用程序，你可以在你的集群/环境使用 `invoke` 端点。\n\n边车编程模式鼓励每个应用程序和它自己的 Dapr 实例沟通。Dapr 实例相互发现并通讯。\n\n*注意：以下是一个 Python cart 应用程序实例。它可以使用任何编程语言实现*\n\n``` python\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.route('/add', methods=['POST'])\ndef add():\n    return \"Added!\"\n\nif __name__ == '__main__':\n    app.run()\n```\n\n这个 Python 应用程序通过 `/add` 终端暴露了一个 `add()` 方法。\n\n#### 使用 curl 调用\n\n``` curl\ncurl http://localhost:3500/v1.0/invoke/cart/method/add -X POST\n```\n\n由于 add 端点是一个 'POST' 方法，我们在 curl 命令中使用 `-X POST` 。\n\n调用 'GET' 端点：\n\n``` curl\ncurl http://localhost:3500/v1.0/invoke/cart/method/add\n```\n\n调用 'DELETE' 端点：\n\n``` curl\ncurl http://localhost:3500/v1.0/invoke/cart/method/add -X DELETE\n```\n\nDapr 在调用的服务 HTTP 应答消息体中放任何负载。\n\n#### 命名空间\n\n当运行在[支持命名空间的平台]上时，你应该把目标应用程序的命名空间包含在应用程序 ID 中：\n\n``` cmd\nmyApp.production\n```\n\n查看[跨命名空间 API 规范]了解更多关于命名空间的信息。\n\n## 概述\n\n---\n\n上面的示例为你展示了如何直接调用不同的服务（运行在本地或者 K8S），Dapr 输出指标和追踪信息允许你可视化服务间的调用图、错误日志和可选地记录有效负载主体。\n\n## 相关主题\n\n- {% post_link service-invocation 服务调用概念 %}\n- {% post_link service-invocation-api 服务调用-API-规范 %}\n","source":"_posts/invoke-and-discover-services.md","raw":"---\ntitle: 调用远程服务\ncatalog: true\ntoc_nav_num: true\ndate: 2020-09-15 20:57:09\nsubtitle: docs/howto/invoke-and-discover-services/\nheader-img: /img/dapr/dapr.svg\ntags:\n- Dapr\n- 原文翻译\ncatagories:\n- Dapr\n---\n\n## 调用远程服务\n\n---\n\n在很多环境中，多个服务需要互相通讯，开发者常常会问自己以下问题：\n\n- 如何发现和调用不同的服务？\n- 如何处理重试和瞬态错误？\n- 如何正确使用分布式跟踪来查看调用图？\n\nDapr 通过提供一个端点，将反向代理与内置服务发现结合起来，同时利用内置分布式跟踪和错误处理，可以使开发人员克服这些挑战。\n\n更多关于服务调用的信息，阅读{% post_link service-invocation 概念文档 %}\n\n### 为你的服务选择 ID\n\nDapr 允许你为应用程序分配一个全局、唯一的 ID。\n\n这个 ID 封装你的应用程序状态，不管有多少个实例。\n\n#### 使用 Dapr 命令行界面设置 ID\n\n在标准模式下，设置 --app-id 标记：\n\n``` CMD\ndapr run --app-id cart --app-port 5000 python app.py\n```\n\n#### 使用 K8S 设置 ID\n\n在 K8S 中，在 pod 中设置 dapr.io/app-id ：\n\n``` yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: python-app\n  namespace: default\n  labels:\n    app: python-app\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: python-app\n  template:\n    metadata:\n      labels:\n        app: python-app\n      annotations:\n        dapr.io/enabled: \"true\"\n        dapr.io/app-id: \"cart\"\n        dapr.io/app-port: \"5000\"\n...\n\n```\n\n#### 在代码中调用服务\n\nDapr 使用边车、去中心化架构。使用 Dapr 调用应用程序，你可以在你的集群/环境使用 `invoke` 端点。\n\n边车编程模式鼓励每个应用程序和它自己的 Dapr 实例沟通。Dapr 实例相互发现并通讯。\n\n*注意：以下是一个 Python cart 应用程序实例。它可以使用任何编程语言实现*\n\n``` python\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.route('/add', methods=['POST'])\ndef add():\n    return \"Added!\"\n\nif __name__ == '__main__':\n    app.run()\n```\n\n这个 Python 应用程序通过 `/add` 终端暴露了一个 `add()` 方法。\n\n#### 使用 curl 调用\n\n``` curl\ncurl http://localhost:3500/v1.0/invoke/cart/method/add -X POST\n```\n\n由于 add 端点是一个 'POST' 方法，我们在 curl 命令中使用 `-X POST` 。\n\n调用 'GET' 端点：\n\n``` curl\ncurl http://localhost:3500/v1.0/invoke/cart/method/add\n```\n\n调用 'DELETE' 端点：\n\n``` curl\ncurl http://localhost:3500/v1.0/invoke/cart/method/add -X DELETE\n```\n\nDapr 在调用的服务 HTTP 应答消息体中放任何负载。\n\n#### 命名空间\n\n当运行在[支持命名空间的平台]上时，你应该把目标应用程序的命名空间包含在应用程序 ID 中：\n\n``` cmd\nmyApp.production\n```\n\n查看[跨命名空间 API 规范]了解更多关于命名空间的信息。\n\n## 概述\n\n---\n\n上面的示例为你展示了如何直接调用不同的服务（运行在本地或者 K8S），Dapr 输出指标和追踪信息允许你可视化服务间的调用图、错误日志和可选地记录有效负载主体。\n\n## 相关主题\n\n- {% post_link service-invocation 服务调用概念 %}\n- {% post_link service-invocation-api 服务调用-API-规范 %}\n","slug":"invoke-and-discover-services","published":1,"updated":"2020-09-16T02:28:10.314Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh8qmyhz000g4x6yculwj85f","content":"<h2 id=\"调用远程服务\">调用远程服务</h2>\n<hr>\n<p>在很多环境中，多个服务需要互相通讯，开发者常常会问自己以下问题：</p>\n<ul>\n<li>如何发现和调用不同的服务？</li>\n<li>如何处理重试和瞬态错误？</li>\n<li>如何正确使用分布式跟踪来查看调用图？</li>\n</ul>\n<p>Dapr 通过提供一个端点，将反向代理与内置服务发现结合起来，同时利用内置分布式跟踪和错误处理，可以使开发人员克服这些挑战。</p>\n<p>更多关于服务调用的信息，阅读<a href=\"/article/service-invocation/\" title=\"概念文档\">概念文档</a></p>\n<h3 id=\"为你的服务选择-id\">为你的服务选择 ID</h3>\n<p>Dapr 允许你为应用程序分配一个全局、唯一的 ID。</p>\n<p>这个 ID 封装你的应用程序状态，不管有多少个实例。</p>\n<h4 id=\"使用-dapr-命令行界面设置-id\">使用 Dapr 命令行界面设置 ID</h4>\n<p>在标准模式下，设置 --app-id 标记：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dapr run --app-id cart --app-port <span class=\"number\">5000</span> python app.py</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用-k8s-设置-id\">使用 K8S 设置 ID</h4>\n<p>在 K8S 中，在 pod 中设置 <a href=\"http://dapr.io/app-id\" target=\"_blank\" rel=\"noopener\">dapr.io/app-id</a> ：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">python-app</span></span><br><span class=\"line\"><span class=\"attr\">  namespace:</span> <span class=\"string\">default</span></span><br><span class=\"line\"><span class=\"attr\">  labels:</span></span><br><span class=\"line\"><span class=\"attr\">    app:</span> <span class=\"string\">python-app</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\"><span class=\"attr\">  replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">  selector:</span></span><br><span class=\"line\"><span class=\"attr\">    matchLabels:</span></span><br><span class=\"line\"><span class=\"attr\">      app:</span> <span class=\"string\">python-app</span></span><br><span class=\"line\"><span class=\"attr\">  template:</span></span><br><span class=\"line\"><span class=\"attr\">    metadata:</span></span><br><span class=\"line\"><span class=\"attr\">      labels:</span></span><br><span class=\"line\"><span class=\"attr\">        app:</span> <span class=\"string\">python-app</span></span><br><span class=\"line\"><span class=\"attr\">      annotations:</span></span><br><span class=\"line\">        <span class=\"string\">dapr.io/enabled:</span> <span class=\"string\">\"true\"</span></span><br><span class=\"line\">        <span class=\"string\">dapr.io/app-id:</span> <span class=\"string\">\"cart\"</span></span><br><span class=\"line\">        <span class=\"string\">dapr.io/app-port:</span> <span class=\"string\">\"5000\"</span></span><br><span class=\"line\"><span class=\"string\">...</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在代码中调用服务\">在代码中调用服务</h4>\n<p>Dapr 使用边车、去中心化架构。使用 Dapr 调用应用程序，你可以在你的集群/环境使用 <code>invoke</code> 端点。</p>\n<p>边车编程模式鼓励每个应用程序和它自己的 Dapr 实例沟通。Dapr 实例相互发现并通讯。</p>\n<p><em>注意：以下是一个 Python cart 应用程序实例。它可以使用任何编程语言实现</em></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route('/add', methods=['POST'])</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Added!\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    app.run()</span><br></pre></td></tr></table></figure>\n<p>这个 Python 应用程序通过 <code>/add</code> 终端暴露了一个 <code>add()</code> 方法。</p>\n<h4 id=\"使用-curl-调用\">使用 curl 调用</h4>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http://localhost:3500/v1.0/invoke/cart/method/add -X POST</span><br></pre></td></tr></table></figure>\n<p>由于 add 端点是一个 ‘POST’ 方法，我们在 curl 命令中使用 <code>-X POST</code> 。</p>\n<p>调用 ‘GET’ 端点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http://localhost:3500/v1.0/invoke/cart/method/add</span><br></pre></td></tr></table></figure>\n<p>调用 ‘DELETE’ 端点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http://localhost:3500/v1.0/invoke/cart/method/add -X DELETE</span><br></pre></td></tr></table></figure>\n<p>Dapr 在调用的服务 HTTP 应答消息体中放任何负载。</p>\n<h4 id=\"命名空间\">命名空间</h4>\n<p>当运行在[支持命名空间的平台]上时，你应该把目标应用程序的命名空间包含在应用程序 ID 中：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myApp.production</span><br></pre></td></tr></table></figure>\n<p>查看[跨命名空间 API 规范]了解更多关于命名空间的信息。</p>\n<h2 id=\"概述\">概述</h2>\n<hr>\n<p>上面的示例为你展示了如何直接调用不同的服务（运行在本地或者 K8S），Dapr 输出指标和追踪信息允许你可视化服务间的调用图、错误日志和可选地记录有效负载主体。</p>\n<h2 id=\"相关主题\">相关主题</h2>\n<ul>\n<li>\n<a href=\"/article/service-invocation/\" title=\"服务调用概念\">服务调用概念</a>\n</li>\n<li>\n<a href=\"/article/service-invocation-api/\" title=\"服务调用-API-规范\">服务调用-API-规范</a>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2>调用远程服务</h2>\n<hr>\n<p>在很多环境中，多个服务需要互相通讯，开发者常常会问自己以下问题：</p>\n<ul>\n<li>如何发现和调用不同的服务？</li>\n<li>如何处理重试和瞬态错误？</li>\n<li>如何正确使用分布式跟踪来查看调用图？</li>\n</ul>\n<p>Dapr 通过提供一个端点，将反向代理与内置服务发现结合起来，同时利用内置分布式跟踪和错误处理，可以使开发人员克服这些挑战。</p>\n<p>更多关于服务调用的信息，阅读<a href=\"/article/service-invocation/\" title=\"概念文档\">概念文档</a></p>\n<h3>为你的服务选择 ID</h3>\n<p>Dapr 允许你为应用程序分配一个全局、唯一的 ID。</p>\n<p>这个 ID 封装你的应用程序状态，不管有多少个实例。</p>\n<h4>使用 Dapr 命令行界面设置 ID</h4>\n<p>在标准模式下，设置 --app-id 标记：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dapr run --app-id cart --app-port <span class=\"number\">5000</span> python app.py</span><br></pre></td></tr></table></figure>\n<h4>使用 K8S 设置 ID</h4>\n<p>在 K8S 中，在 pod 中设置 <a href=\"http://dapr.io/app-id\" target=\"_blank\" rel=\"noopener\">dapr.io/app-id</a> ：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">python-app</span></span><br><span class=\"line\"><span class=\"attr\">  namespace:</span> <span class=\"string\">default</span></span><br><span class=\"line\"><span class=\"attr\">  labels:</span></span><br><span class=\"line\"><span class=\"attr\">    app:</span> <span class=\"string\">python-app</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\"><span class=\"attr\">  replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">  selector:</span></span><br><span class=\"line\"><span class=\"attr\">    matchLabels:</span></span><br><span class=\"line\"><span class=\"attr\">      app:</span> <span class=\"string\">python-app</span></span><br><span class=\"line\"><span class=\"attr\">  template:</span></span><br><span class=\"line\"><span class=\"attr\">    metadata:</span></span><br><span class=\"line\"><span class=\"attr\">      labels:</span></span><br><span class=\"line\"><span class=\"attr\">        app:</span> <span class=\"string\">python-app</span></span><br><span class=\"line\"><span class=\"attr\">      annotations:</span></span><br><span class=\"line\">        <span class=\"string\">dapr.io/enabled:</span> <span class=\"string\">\"true\"</span></span><br><span class=\"line\">        <span class=\"string\">dapr.io/app-id:</span> <span class=\"string\">\"cart\"</span></span><br><span class=\"line\">        <span class=\"string\">dapr.io/app-port:</span> <span class=\"string\">\"5000\"</span></span><br><span class=\"line\"><span class=\"string\">...</span></span><br></pre></td></tr></table></figure>\n<h4>在代码中调用服务</h4>\n<p>Dapr 使用边车、去中心化架构。使用 Dapr 调用应用程序，你可以在你的集群/环境使用 <code>invoke</code> 端点。</p>\n<p>边车编程模式鼓励每个应用程序和它自己的 Dapr 实例沟通。Dapr 实例相互发现并通讯。</p>\n<p><em>注意：以下是一个 Python cart 应用程序实例。它可以使用任何编程语言实现</em></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route('/add', methods=['POST'])</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Added!\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    app.run()</span><br></pre></td></tr></table></figure>\n<p>这个 Python 应用程序通过 <code>/add</code> 终端暴露了一个 <code>add()</code> 方法。</p>\n<h4>使用 curl 调用</h4>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http://localhost:3500/v1.0/invoke/cart/method/add -X POST</span><br></pre></td></tr></table></figure>\n<p>由于 add 端点是一个 ‘POST’ 方法，我们在 curl 命令中使用 <code>-X POST</code> 。</p>\n<p>调用 ‘GET’ 端点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http://localhost:3500/v1.0/invoke/cart/method/add</span><br></pre></td></tr></table></figure>\n<p>调用 ‘DELETE’ 端点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http://localhost:3500/v1.0/invoke/cart/method/add -X DELETE</span><br></pre></td></tr></table></figure>\n<p>Dapr 在调用的服务 HTTP 应答消息体中放任何负载。</p>\n<h4>命名空间</h4>\n<p>当运行在[支持命名空间的平台]上时，你应该把目标应用程序的命名空间包含在应用程序 ID 中：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myApp.production</span><br></pre></td></tr></table></figure>\n<p>查看[跨命名空间 API 规范]了解更多关于命名空间的信息。</p>\n<h2>概述</h2>\n<hr>\n<p>上面的示例为你展示了如何直接调用不同的服务（运行在本地或者 K8S），Dapr 输出指标和追踪信息允许你可视化服务间的调用图、错误日志和可选地记录有效负载主体。</p>\n<h2>相关主题</h2>\n<ul>\n<li>\n<a href=\"/article/service-invocation/\" title=\"服务调用概念\">服务调用概念</a>\n</li>\n<li>\n<a href=\"/article/service-invocation-api/\" title=\"服务调用-API-规范\">服务调用-API-规范</a>\n</li>\n</ul>\n"},{"title":"服务调用","catalog":true,"toc_nav_num":true,"date":"2020-09-15T11:49:52.000Z","subtitle":"docs/concepts/service-invocation/","header-img":"/img/dapr/dapr.svg","catagories":["Dapr"],"_content":"\n## 服务调用\n\n[Service Invocation](https://github.com/dapr/docs/tree/master/concepts/service-invocation)\n\n---\n\n使用服务调用 API,你的微服务可以找到其它微服务，并且在你的系统中使用标准协议（当前支持 gRPC 或者 HTTP）进行可靠通讯。\n\n以下是一个 Dapr 服务调用如何工作的高度概括。\n\n![](/img/dapr/service-invocation.png)\n\n1. 服务 A 对服务 B 发起一个 http/gRPC 请求。请求进入到本地 Dapr 边车。\n2. Dapr 发现服务 B 的位置并且转发消息到服务 B 的 Dapr 边车。\n3. 服务 B 的 Dapr 边车转发请求到服务 B 。服务 B 执行它的业务逻辑响应。\n4. 服务 B 发送一个响应到服务 A 。这个响应进入到服务 B 的边车。\n5. Dapr 转发响应到服务 A 的 Dapr 边车。\n6. 服务 A 接收响应。\n\n作为上面的内容描述的例子，假设我们有以下示例描述的应用程序集合，一个 python 应用程序调用一个 Noed.js 应用程序：https://github.com/dapr/quickstarts/blob/master/hello-kubernetes/README.md\n\n在这样的情景下，python 应用程序作为上面提到的“Service A”，Node.js 应用程序作为\"Service B\"。\n\n在例子的上下文中，以下1-6项再一次描述：\n\n1. 假设 Node.js 应用程序有一个 Dapr 应用程序 id “nodeapp”，如示例所示。python 应用程序通过 http://localhost:3500/v1.0/invoke/nodeapp/method/neworder 调用 Node.js 应用程序的 neworder 方法，它首先进入 python 应用程序的本地 Dapr 边车。\n2. Dapr 发现 Node.js 应用程序的位置并且转发请求到 Node.js 应用程序的边车。\n3. Node.js 应用程序的边车转发请求到 Node.js 应用程序。Node.js 应用程序执行它的业务逻辑（就像在示例中描述的一样）记录进入的消息然后持久化订单 ID 到 Redis 中（上面的图中未显示）。\n\n第 4-5 步和上面列表一样。\n\n## 下一步\n\n---\n\n如果你已经准备好开始了，跟着这个指引概述[如何开始一个服务调用]()\n\n如果你想要知道更多关于服务调用如何工作的技术细节，异步到[API 规范]()\n","source":"_posts/service-invocation.md","raw":"---\ntitle: 服务调用\ncatalog: true\ntoc_nav_num: true\ndate: 2020-09-15 19:49:52\nsubtitle: docs/concepts/service-invocation/\nheader-img: /img/dapr/dapr.svg\ntags:\n- Dapr\n- 原文翻译\ncatagories:\n- Dapr\n---\n\n## 服务调用\n\n[Service Invocation](https://github.com/dapr/docs/tree/master/concepts/service-invocation)\n\n---\n\n使用服务调用 API,你的微服务可以找到其它微服务，并且在你的系统中使用标准协议（当前支持 gRPC 或者 HTTP）进行可靠通讯。\n\n以下是一个 Dapr 服务调用如何工作的高度概括。\n\n![](/img/dapr/service-invocation.png)\n\n1. 服务 A 对服务 B 发起一个 http/gRPC 请求。请求进入到本地 Dapr 边车。\n2. Dapr 发现服务 B 的位置并且转发消息到服务 B 的 Dapr 边车。\n3. 服务 B 的 Dapr 边车转发请求到服务 B 。服务 B 执行它的业务逻辑响应。\n4. 服务 B 发送一个响应到服务 A 。这个响应进入到服务 B 的边车。\n5. Dapr 转发响应到服务 A 的 Dapr 边车。\n6. 服务 A 接收响应。\n\n作为上面的内容描述的例子，假设我们有以下示例描述的应用程序集合，一个 python 应用程序调用一个 Noed.js 应用程序：https://github.com/dapr/quickstarts/blob/master/hello-kubernetes/README.md\n\n在这样的情景下，python 应用程序作为上面提到的“Service A”，Node.js 应用程序作为\"Service B\"。\n\n在例子的上下文中，以下1-6项再一次描述：\n\n1. 假设 Node.js 应用程序有一个 Dapr 应用程序 id “nodeapp”，如示例所示。python 应用程序通过 http://localhost:3500/v1.0/invoke/nodeapp/method/neworder 调用 Node.js 应用程序的 neworder 方法，它首先进入 python 应用程序的本地 Dapr 边车。\n2. Dapr 发现 Node.js 应用程序的位置并且转发请求到 Node.js 应用程序的边车。\n3. Node.js 应用程序的边车转发请求到 Node.js 应用程序。Node.js 应用程序执行它的业务逻辑（就像在示例中描述的一样）记录进入的消息然后持久化订单 ID 到 Redis 中（上面的图中未显示）。\n\n第 4-5 步和上面列表一样。\n\n## 下一步\n\n---\n\n如果你已经准备好开始了，跟着这个指引概述[如何开始一个服务调用]()\n\n如果你想要知道更多关于服务调用如何工作的技术细节，异步到[API 规范]()\n","slug":"service-invocation","published":1,"updated":"2020-11-05T07:47:48.864Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh8qmyi1000j4x6y09eqd3t8","content":"<h2 id=\"服务调用\">服务调用</h2>\n<p><a href=\"https://github.com/dapr/docs/tree/master/concepts/service-invocation\" target=\"_blank\" rel=\"noopener\">Service Invocation</a></p>\n<hr>\n<p>使用服务调用 API,你的微服务可以找到其它微服务，并且在你的系统中使用标准协议（当前支持 gRPC 或者 HTTP）进行可靠通讯。</p>\n<p>以下是一个 Dapr 服务调用如何工作的高度概括。</p>\n<p><img src=\"/img/dapr/service-invocation.png\" alt=\"\"></p>\n<ol>\n<li>服务 A 对服务 B 发起一个 http/gRPC 请求。请求进入到本地 Dapr 边车。</li>\n<li>Dapr 发现服务 B 的位置并且转发消息到服务 B 的 Dapr 边车。</li>\n<li>服务 B 的 Dapr 边车转发请求到服务 B 。服务 B 执行它的业务逻辑响应。</li>\n<li>服务 B 发送一个响应到服务 A 。这个响应进入到服务 B 的边车。</li>\n<li>Dapr 转发响应到服务 A 的 Dapr 边车。</li>\n<li>服务 A 接收响应。</li>\n</ol>\n<p>作为上面的内容描述的例子，假设我们有以下示例描述的应用程序集合，一个 python 应用程序调用一个 Noed.js 应用程序：<a href=\"https://github.com/dapr/quickstarts/blob/master/hello-kubernetes/README.md\" target=\"_blank\" rel=\"noopener\">https://github.com/dapr/quickstarts/blob/master/hello-kubernetes/README.md</a></p>\n<p>在这样的情景下，python 应用程序作为上面提到的“Service A”，Node.js 应用程序作为&quot;Service B&quot;。</p>\n<p>在例子的上下文中，以下1-6项再一次描述：</p>\n<ol>\n<li>假设 Node.js 应用程序有一个 Dapr 应用程序 id “nodeapp”，如示例所示。python 应用程序通过 <a href=\"http://localhost:3500/v1.0/invoke/nodeapp/method/neworder\" target=\"_blank\" rel=\"noopener\">http://localhost:3500/v1.0/invoke/nodeapp/method/neworder</a> 调用 Node.js 应用程序的 neworder 方法，它首先进入 python 应用程序的本地 Dapr 边车。</li>\n<li>Dapr 发现 Node.js 应用程序的位置并且转发请求到 Node.js 应用程序的边车。</li>\n<li>Node.js 应用程序的边车转发请求到 Node.js 应用程序。Node.js 应用程序执行它的业务逻辑（就像在示例中描述的一样）记录进入的消息然后持久化订单 ID 到 Redis 中（上面的图中未显示）。</li>\n</ol>\n<p>第 4-5 步和上面列表一样。</p>\n<h2 id=\"下一步\">下一步</h2>\n<hr>\n<p>如果你已经准备好开始了，跟着这个指引概述<a href=\"\">如何开始一个服务调用</a></p>\n<p>如果你想要知道更多关于服务调用如何工作的技术细节，异步到<a href=\"\">API 规范</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2>服务调用</h2>\n<p><a href=\"https://github.com/dapr/docs/tree/master/concepts/service-invocation\" target=\"_blank\" rel=\"noopener\">Service Invocation</a></p>\n<hr>\n<p>使用服务调用 API,你的微服务可以找到其它微服务，并且在你的系统中使用标准协议（当前支持 gRPC 或者 HTTP）进行可靠通讯。</p>\n<p>以下是一个 Dapr 服务调用如何工作的高度概括。</p>\n<p><img src=\"/img/dapr/service-invocation.png\" alt=\"\"></p>\n<ol>\n<li>服务 A 对服务 B 发起一个 http/gRPC 请求。请求进入到本地 Dapr 边车。</li>\n<li>Dapr 发现服务 B 的位置并且转发消息到服务 B 的 Dapr 边车。</li>\n<li>服务 B 的 Dapr 边车转发请求到服务 B 。服务 B 执行它的业务逻辑响应。</li>\n<li>服务 B 发送一个响应到服务 A 。这个响应进入到服务 B 的边车。</li>\n<li>Dapr 转发响应到服务 A 的 Dapr 边车。</li>\n<li>服务 A 接收响应。</li>\n</ol>\n<p>作为上面的内容描述的例子，假设我们有以下示例描述的应用程序集合，一个 python 应用程序调用一个 Noed.js 应用程序：<a href=\"https://github.com/dapr/quickstarts/blob/master/hello-kubernetes/README.md\" target=\"_blank\" rel=\"noopener\">https://github.com/dapr/quickstarts/blob/master/hello-kubernetes/README.md</a></p>\n<p>在这样的情景下，python 应用程序作为上面提到的“Service A”，Node.js 应用程序作为&quot;Service B&quot;。</p>\n<p>在例子的上下文中，以下1-6项再一次描述：</p>\n<ol>\n<li>假设 Node.js 应用程序有一个 Dapr 应用程序 id “nodeapp”，如示例所示。python 应用程序通过 <a href=\"http://localhost:3500/v1.0/invoke/nodeapp/method/neworder\" target=\"_blank\" rel=\"noopener\">http://localhost:3500/v1.0/invoke/nodeapp/method/neworder</a> 调用 Node.js 应用程序的 neworder 方法，它首先进入 python 应用程序的本地 Dapr 边车。</li>\n<li>Dapr 发现 Node.js 应用程序的位置并且转发请求到 Node.js 应用程序的边车。</li>\n<li>Node.js 应用程序的边车转发请求到 Node.js 应用程序。Node.js 应用程序执行它的业务逻辑（就像在示例中描述的一样）记录进入的消息然后持久化订单 ID 到 Redis 中（上面的图中未显示）。</li>\n</ol>\n<p>第 4-5 步和上面列表一样。</p>\n<h2>下一步</h2>\n<hr>\n<p>如果你已经准备好开始了，跟着这个指引概述<a href=\"\">如何开始一个服务调用</a></p>\n<p>如果你想要知道更多关于服务调用如何工作的技术细节，异步到<a href=\"\">API 规范</a></p>\n"},{"title":"设置 Minikube 集群","catalog":true,"toc_nav_num":true,"date":"2020-09-27T13:47:14.000Z","subtitle":"docs/getting-started/cluster/setup-minikube.md","header-img":"/img/dapr/dapr.svg","catagories":["Dapr"],"_content":"\n## 设置 Minikube 集群\n\n---\n\n### 前置条件\n\n---\n\n- Docker\n- kubectl\n- Minikube\n\n> 注意：对于 Windows ，在 BIOS 中启用 Virtualization 并且安装 [Hyper-V](https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/quick-start/enable-hyper-v)\n\n### 开始 Minikube 集群\n\n1. （可选）设置默认 VM 驱动\n\n``` cmd\nminikube config set vm-driver [driver_name]\n```\n\n2. 通过 `--kubernetes-version` 指定 K8S 版本（使用 1.13.x 或者更新的版本）开始集群。\n\n``` cmd\nminikube start --cpus=4 --memory=4096 --kubernetes-version=1.16.2 --extra-config=apiserver.authorization-mode=RBAC\n```\n\n3. 启用仪表盘和入口插件\n\n``` cmd\n# Enable dashboard\nminikube addons enable dashboard\n\n# Enable ingress\nminikube addons enable ingress\n```\n\n### (可选)安装 Helm v3\n\n---\n\n1. [安装 Helm v3 客户端](https://helm.sh/docs/intro/install/)\n\n> 注意： 最新的 Dapr helm 图表不在支持 Helm v2。请从 heml v2 迁移至 heml v3，[迁移指南](https://helm.sh/blog/migrate-from-helm-v2-to-helm-v3/)\n\n#### 疑难解答\n\n1. 负载均衡器的外部 IP 地址不从 `kubectl get svc` 中显示\n\n在 Minikube 中，你的服务 EXTERNAL-IP 在 `kubectl get svc` 中显示 `<pending>` 状态。在这种情况下，你可以运行 `minikube service [service_name]` 以打开你的服务并且不显示外部 IP 地址。\n\n``` cmd\n$ kubectl get svc\nNAME                        TYPE           CLUSTER-IP       EXTERNAL-IP   PORT(S)            AGE\n...\ncalculator-front-end        LoadBalancer   10.103.98.37     <pending>     80:30534/TCP       25h\ncalculator-front-end-dapr   ClusterIP      10.107.128.226   <none>        80/TCP,50001/TCP   25h\n...\n\n$ minikube service calculator-front-end\n|-----------|----------------------|-------------|---------------------------|\n| NAMESPACE |         NAME         | TARGET PORT |            URL            |\n|-----------|----------------------|-------------|---------------------------|\n| default   | calculator-front-end |             | http://192.168.64.7:30534 |\n|-----------|----------------------|-------------|---------------------------|\n🎉  Opening kubernetes service  default/calculator-front-end in default browser...\n```\n","source":"_posts/setup-minikube.md","raw":"---\ntitle: 设置 Minikube 集群\ncatalog: true\ntoc_nav_num: true\ndate: 2020-09-27 21:47:14\nsubtitle: docs/getting-started/cluster/setup-minikube.md\nheader-img: /img/dapr/dapr.svg\ntags: \n- Dapr\n- 原文翻译\ncatagories:\n- Dapr\n---\n\n## 设置 Minikube 集群\n\n---\n\n### 前置条件\n\n---\n\n- Docker\n- kubectl\n- Minikube\n\n> 注意：对于 Windows ，在 BIOS 中启用 Virtualization 并且安装 [Hyper-V](https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/quick-start/enable-hyper-v)\n\n### 开始 Minikube 集群\n\n1. （可选）设置默认 VM 驱动\n\n``` cmd\nminikube config set vm-driver [driver_name]\n```\n\n2. 通过 `--kubernetes-version` 指定 K8S 版本（使用 1.13.x 或者更新的版本）开始集群。\n\n``` cmd\nminikube start --cpus=4 --memory=4096 --kubernetes-version=1.16.2 --extra-config=apiserver.authorization-mode=RBAC\n```\n\n3. 启用仪表盘和入口插件\n\n``` cmd\n# Enable dashboard\nminikube addons enable dashboard\n\n# Enable ingress\nminikube addons enable ingress\n```\n\n### (可选)安装 Helm v3\n\n---\n\n1. [安装 Helm v3 客户端](https://helm.sh/docs/intro/install/)\n\n> 注意： 最新的 Dapr helm 图表不在支持 Helm v2。请从 heml v2 迁移至 heml v3，[迁移指南](https://helm.sh/blog/migrate-from-helm-v2-to-helm-v3/)\n\n#### 疑难解答\n\n1. 负载均衡器的外部 IP 地址不从 `kubectl get svc` 中显示\n\n在 Minikube 中，你的服务 EXTERNAL-IP 在 `kubectl get svc` 中显示 `<pending>` 状态。在这种情况下，你可以运行 `minikube service [service_name]` 以打开你的服务并且不显示外部 IP 地址。\n\n``` cmd\n$ kubectl get svc\nNAME                        TYPE           CLUSTER-IP       EXTERNAL-IP   PORT(S)            AGE\n...\ncalculator-front-end        LoadBalancer   10.103.98.37     <pending>     80:30534/TCP       25h\ncalculator-front-end-dapr   ClusterIP      10.107.128.226   <none>        80/TCP,50001/TCP   25h\n...\n\n$ minikube service calculator-front-end\n|-----------|----------------------|-------------|---------------------------|\n| NAMESPACE |         NAME         | TARGET PORT |            URL            |\n|-----------|----------------------|-------------|---------------------------|\n| default   | calculator-front-end |             | http://192.168.64.7:30534 |\n|-----------|----------------------|-------------|---------------------------|\n🎉  Opening kubernetes service  default/calculator-front-end in default browser...\n```\n","slug":"setup-minikube","published":1,"updated":"2020-11-06T03:53:15.318Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh8qmyi3000l4x6yt3ebagzl","content":"<h2 id=\"设置-minikube-集群\">设置 Minikube 集群</h2>\n<hr>\n<h3 id=\"前置条件\">前置条件</h3>\n<hr>\n<ul>\n<li>Docker</li>\n<li>kubectl</li>\n<li>Minikube</li>\n</ul>\n<blockquote>\n<p>注意：对于 Windows ，在 BIOS 中启用 Virtualization 并且安装 <a href=\"https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/quick-start/enable-hyper-v\" target=\"_blank\" rel=\"noopener\">Hyper-V</a></p>\n</blockquote>\n<h3 id=\"开始-minikube-集群\">开始 Minikube 集群</h3>\n<ol>\n<li>（可选）设置默认 VM 驱动</li>\n</ol>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">minikube config <span class=\"built_in\">set</span> vm-driver [driver_name]</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>通过 <code>--kubernetes-version</code> 指定 K8S 版本（使用 1.13.x 或者更新的版本）开始集群。</li>\n</ol>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">minikube <span class=\"built_in\">start</span> --cpus=<span class=\"number\">4</span> --memory=<span class=\"number\">4096</span> --kubernetes-version=<span class=\"number\">1</span>.<span class=\"number\">16</span>.<span class=\"number\">2</span> --extra-config=apiserver.authorization-<span class=\"built_in\">mode</span>=RBAC</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>启用仪表盘和入口插件</li>\n</ol>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Enable dashboard</span><br><span class=\"line\">minikube addons enable dashboard</span><br><span class=\"line\"></span><br><span class=\"line\"># Enable ingress</span><br><span class=\"line\">minikube addons enable ingress</span><br></pre></td></tr></table></figure>\n<h3 id=\"可选安装-helm-v3\">(可选)安装 Helm v3</h3>\n<hr>\n<ol>\n<li><a href=\"https://helm.sh/docs/intro/install/\" target=\"_blank\" rel=\"noopener\">安装 Helm v3 客户端</a></li>\n</ol>\n<blockquote>\n<p>注意： 最新的 Dapr helm 图表不在支持 Helm v2。请从 heml v2 迁移至 heml v3，<a href=\"https://helm.sh/blog/migrate-from-helm-v2-to-helm-v3/\" target=\"_blank\" rel=\"noopener\">迁移指南</a></p>\n</blockquote>\n<h4 id=\"疑难解答\">疑难解答</h4>\n<ol>\n<li>负载均衡器的外部 IP 地址不从 <code>kubectl get svc</code> 中显示</li>\n</ol>\n<p>在 Minikube 中，你的服务 EXTERNAL-IP 在 <code>kubectl get svc</code> 中显示 <code>&lt;pending&gt;</code> 状态。在这种情况下，你可以运行 <code>minikube service [service_name]</code> 以打开你的服务并且不显示外部 IP 地址。</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl get svc</span><br><span class=\"line\">NAME                        <span class=\"built_in\">TYPE</span>           CLUSTER-IP       EXTERNAL-IP   PORT(S)            AGE</span><br><span class=\"line\">...</span><br><span class=\"line\">calculator-front-end        LoadBalancer   <span class=\"number\">10</span>.<span class=\"number\">103</span>.<span class=\"number\">98</span>.<span class=\"number\">37</span>     &lt;pending&gt;     <span class=\"number\">80</span>:<span class=\"number\">30534</span>/TCP       <span class=\"number\">25</span>h</span><br><span class=\"line\">calculator-front-end-dapr   ClusterIP      <span class=\"number\">10</span>.<span class=\"number\">107</span>.<span class=\"number\">128</span>.<span class=\"number\">226</span>   &lt;none&gt;        <span class=\"number\">80</span>/TCP,<span class=\"number\">50001</span>/TCP   <span class=\"number\">25</span>h</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">$ minikube service calculator-front-end</span><br><span class=\"line\">|-----------|----------------------|-------------|---------------------------|</span><br><span class=\"line\">| NAMESPACE |         NAME         | TARGET PORT |            URL            |</span><br><span class=\"line\">|-----------|----------------------|-------------|---------------------------|</span><br><span class=\"line\">| default   | calculator-front-end |             | http://<span class=\"number\">192</span>.<span class=\"number\">168</span>.<span class=\"number\">64</span>.<span class=\"number\">7</span>:<span class=\"number\">30534</span> |</span><br><span class=\"line\">|-----------|----------------------|-------------|---------------------------|</span><br><span class=\"line\">🎉  Opening kubernetes service  default/calculator-front-end <span class=\"keyword\">in</span> default browser...</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2>设置 Minikube 集群</h2>\n<hr>\n<h3>前置条件</h3>\n<hr>\n<ul>\n<li>Docker</li>\n<li>kubectl</li>\n<li>Minikube</li>\n</ul>\n<blockquote>\n<p>注意：对于 Windows ，在 BIOS 中启用 Virtualization 并且安装 <a href=\"https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/quick-start/enable-hyper-v\" target=\"_blank\" rel=\"noopener\">Hyper-V</a></p>\n</blockquote>\n<h3>开始 Minikube 集群</h3>\n<ol>\n<li>（可选）设置默认 VM 驱动</li>\n</ol>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">minikube config <span class=\"built_in\">set</span> vm-driver [driver_name]</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>通过 <code>--kubernetes-version</code> 指定 K8S 版本（使用 1.13.x 或者更新的版本）开始集群。</li>\n</ol>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">minikube <span class=\"built_in\">start</span> --cpus=<span class=\"number\">4</span> --memory=<span class=\"number\">4096</span> --kubernetes-version=<span class=\"number\">1</span>.<span class=\"number\">16</span>.<span class=\"number\">2</span> --extra-config=apiserver.authorization-<span class=\"built_in\">mode</span>=RBAC</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>启用仪表盘和入口插件</li>\n</ol>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Enable dashboard</span><br><span class=\"line\">minikube addons enable dashboard</span><br><span class=\"line\"></span><br><span class=\"line\"># Enable ingress</span><br><span class=\"line\">minikube addons enable ingress</span><br></pre></td></tr></table></figure>\n<h3>(可选)安装 Helm v3</h3>\n<hr>\n<ol>\n<li><a href=\"https://helm.sh/docs/intro/install/\" target=\"_blank\" rel=\"noopener\">安装 Helm v3 客户端</a></li>\n</ol>\n<blockquote>\n<p>注意： 最新的 Dapr helm 图表不在支持 Helm v2。请从 heml v2 迁移至 heml v3，<a href=\"https://helm.sh/blog/migrate-from-helm-v2-to-helm-v3/\" target=\"_blank\" rel=\"noopener\">迁移指南</a></p>\n</blockquote>\n<h4>疑难解答</h4>\n<ol>\n<li>负载均衡器的外部 IP 地址不从 <code>kubectl get svc</code> 中显示</li>\n</ol>\n<p>在 Minikube 中，你的服务 EXTERNAL-IP 在 <code>kubectl get svc</code> 中显示 <code>&lt;pending&gt;</code> 状态。在这种情况下，你可以运行 <code>minikube service [service_name]</code> 以打开你的服务并且不显示外部 IP 地址。</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl get svc</span><br><span class=\"line\">NAME                        <span class=\"built_in\">TYPE</span>           CLUSTER-IP       EXTERNAL-IP   PORT(S)            AGE</span><br><span class=\"line\">...</span><br><span class=\"line\">calculator-front-end        LoadBalancer   <span class=\"number\">10</span>.<span class=\"number\">103</span>.<span class=\"number\">98</span>.<span class=\"number\">37</span>     &lt;pending&gt;     <span class=\"number\">80</span>:<span class=\"number\">30534</span>/TCP       <span class=\"number\">25</span>h</span><br><span class=\"line\">calculator-front-end-dapr   ClusterIP      <span class=\"number\">10</span>.<span class=\"number\">107</span>.<span class=\"number\">128</span>.<span class=\"number\">226</span>   &lt;none&gt;        <span class=\"number\">80</span>/TCP,<span class=\"number\">50001</span>/TCP   <span class=\"number\">25</span>h</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">$ minikube service calculator-front-end</span><br><span class=\"line\">|-----------|----------------------|-------------|---------------------------|</span><br><span class=\"line\">| NAMESPACE |         NAME         | TARGET PORT |            URL            |</span><br><span class=\"line\">|-----------|----------------------|-------------|---------------------------|</span><br><span class=\"line\">| default   | calculator-front-end |             | http://<span class=\"number\">192</span>.<span class=\"number\">168</span>.<span class=\"number\">64</span>.<span class=\"number\">7</span>:<span class=\"number\">30534</span> |</span><br><span class=\"line\">|-----------|----------------------|-------------|---------------------------|</span><br><span class=\"line\">🎉  Opening kubernetes service  default/calculator-front-end <span class=\"keyword\">in</span> default browser...</span><br></pre></td></tr></table></figure>\n"},{"title":"设置 Azure K8S 服务集群","catalog":true,"toc_nav_num":true,"date":"2020-09-29T12:54:50.000Z","subtitle":"docs/getting-started/cluster/setup-aks.md","header-img":"/img/dapr/dapr.svg","catagories":["Dapr"],"_content":"\n## 设置 Azure K8S 服务集群\n\n---\n\n### 前置条件\n\n---\n\n- [Docker](https://docs.docker.com/get-docker/)\n- [kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/)\n- [Azure CLI](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest)\n\n### 部署 Azure K8S 服务集群\n\n---\n\n这个指南向你介绍安装 Azure K8S 服务集群。如果你需要了解更多信息，参考[快速开始：使用 Azure CLI 部署 Azure K8S 服务（AKS）集群](https://docs.microsoft.com/en-us/azure/aks/kubernetes-walkthrough)\n\n1. 登录 Azure\n\n``` cmd\naz login\n```\n\n2. 设置默认订阅\n\n``` cmd\naz account set -s [your_subscription_id]\n```\n\n3. 创建资源组\n\n``` cmd\naz group create --name [your_resource_group] --location [region]\n```\n\n4. 创建一个 Azure K8S 服务集群\n\nK8S 通过 `--kubernetes-version` 使用 1.13.x 或者更新的版本\n\n``` cmd\naz aks create --resource-group [your_resource_group] --name [your_aks_cluster_name] --node-count 2 --kubernetes-version 1.14.7 --enable-addons http_application_routing --enable-rbac --generate-ssh-keys\n```\n\n5. 从 Azure K8S 集群中获取访问凭证\n\n``` cmd\naz aks get-credentials -n [your_aks_cluster_name] -g [your_resource_group]\n```\n\n### （可选）安装 Helm v3\n\n---\n\n1. [安装 Helm v3 客户端](https://helm.sh/docs/intro/install/)\n\n> 注意： 最新的 Dapr helm 图表不在支持 Helm v2。请从 heml v2 迁移至 heml v3，[迁移指南](https://helm.sh/blog/migrate-from-helm-v2-to-helm-v3/)\n\n2. 如果你需要 K8S 仪表盘权限执行此命令\n\n``` cmd\nkubectl create clusterrolebinding kubernetes-dashboard -n kube-system --clusterrole=cluster-admin --serviceaccount=kube-system:kubernetes-dashboard\n```","source":"_posts/setup-aks.md","raw":"---\ntitle: 设置 Azure K8S 服务集群\ncatalog: true\ntoc_nav_num: true\ndate: 2020-09-29 20:54:50\nsubtitle: docs/getting-started/cluster/setup-aks.md\nheader-img: /img/dapr/dapr.svg\ntags: \n- Dapr\n- 原文翻译\ncatagories:\n- Dapr\n---\n\n## 设置 Azure K8S 服务集群\n\n---\n\n### 前置条件\n\n---\n\n- [Docker](https://docs.docker.com/get-docker/)\n- [kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/)\n- [Azure CLI](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest)\n\n### 部署 Azure K8S 服务集群\n\n---\n\n这个指南向你介绍安装 Azure K8S 服务集群。如果你需要了解更多信息，参考[快速开始：使用 Azure CLI 部署 Azure K8S 服务（AKS）集群](https://docs.microsoft.com/en-us/azure/aks/kubernetes-walkthrough)\n\n1. 登录 Azure\n\n``` cmd\naz login\n```\n\n2. 设置默认订阅\n\n``` cmd\naz account set -s [your_subscription_id]\n```\n\n3. 创建资源组\n\n``` cmd\naz group create --name [your_resource_group] --location [region]\n```\n\n4. 创建一个 Azure K8S 服务集群\n\nK8S 通过 `--kubernetes-version` 使用 1.13.x 或者更新的版本\n\n``` cmd\naz aks create --resource-group [your_resource_group] --name [your_aks_cluster_name] --node-count 2 --kubernetes-version 1.14.7 --enable-addons http_application_routing --enable-rbac --generate-ssh-keys\n```\n\n5. 从 Azure K8S 集群中获取访问凭证\n\n``` cmd\naz aks get-credentials -n [your_aks_cluster_name] -g [your_resource_group]\n```\n\n### （可选）安装 Helm v3\n\n---\n\n1. [安装 Helm v3 客户端](https://helm.sh/docs/intro/install/)\n\n> 注意： 最新的 Dapr helm 图表不在支持 Helm v2。请从 heml v2 迁移至 heml v3，[迁移指南](https://helm.sh/blog/migrate-from-helm-v2-to-helm-v3/)\n\n2. 如果你需要 K8S 仪表盘权限执行此命令\n\n``` cmd\nkubectl create clusterrolebinding kubernetes-dashboard -n kube-system --clusterrole=cluster-admin --serviceaccount=kube-system:kubernetes-dashboard\n```","slug":"setup-aks","published":1,"updated":"2020-11-06T03:53:15.317Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh8qmyi4000o4x6yg7m0t2xy","content":"<h2 id=\"设置-azure-k8s-服务集群\">设置 Azure K8S 服务集群</h2>\n<hr>\n<h3 id=\"前置条件\">前置条件</h3>\n<hr>\n<ul>\n<li><a href=\"https://docs.docker.com/get-docker/\" target=\"_blank\" rel=\"noopener\">Docker</a></li>\n<li><a href=\"https://kubernetes.io/docs/tasks/tools/install-kubectl/\" target=\"_blank\" rel=\"noopener\">kubectl</a></li>\n<li><a href=\"https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest\" target=\"_blank\" rel=\"noopener\">Azure CLI</a></li>\n</ul>\n<h3 id=\"部署-azure-k8s-服务集群\">部署 Azure K8S 服务集群</h3>\n<hr>\n<p>这个指南向你介绍安装 Azure K8S 服务集群。如果你需要了解更多信息，参考<a href=\"https://docs.microsoft.com/en-us/azure/aks/kubernetes-walkthrough\" target=\"_blank\" rel=\"noopener\">快速开始：使用 Azure CLI 部署 Azure K8S 服务（AKS）集群</a></p>\n<ol>\n<li>登录 Azure</li>\n</ol>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">az login</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>设置默认订阅</li>\n</ol>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">az account <span class=\"built_in\">set</span> -s [your_subscription_id]</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>创建资源组</li>\n</ol>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">az group create --name [your_resource_group] --location [region]</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>创建一个 Azure K8S 服务集群</li>\n</ol>\n<p>K8S 通过 <code>--kubernetes-version</code> 使用 1.13.x 或者更新的版本</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">az aks create --resource-group [your_resource_group] --name [your_aks_cluster_name] --node-count <span class=\"number\">2</span> --kubernetes-version <span class=\"number\">1</span>.<span class=\"number\">14</span>.<span class=\"number\">7</span> --enable-addons http_application_routing --enable-rbac --generate-ssh-keys</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>从 Azure K8S 集群中获取访问凭证</li>\n</ol>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">az aks get-credentials -n [your_aks_cluster_name] -g [your_resource_group]</span><br></pre></td></tr></table></figure>\n<h3 id=\"可选安装-helm-v3\">（可选）安装 Helm v3</h3>\n<hr>\n<ol>\n<li><a href=\"https://helm.sh/docs/intro/install/\" target=\"_blank\" rel=\"noopener\">安装 Helm v3 客户端</a></li>\n</ol>\n<blockquote>\n<p>注意： 最新的 Dapr helm 图表不在支持 Helm v2。请从 heml v2 迁移至 heml v3，<a href=\"https://helm.sh/blog/migrate-from-helm-v2-to-helm-v3/\" target=\"_blank\" rel=\"noopener\">迁移指南</a></p>\n</blockquote>\n<ol start=\"2\">\n<li>如果你需要 K8S 仪表盘权限执行此命令</li>\n</ol>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create clusterrolebinding kubernetes-dashboard -n kube-system --clusterrole=cluster-admin --serviceaccount=kube-system:kubernetes-dashboard</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2>设置 Azure K8S 服务集群</h2>\n<hr>\n<h3>前置条件</h3>\n<hr>\n<ul>\n<li><a href=\"https://docs.docker.com/get-docker/\" target=\"_blank\" rel=\"noopener\">Docker</a></li>\n<li><a href=\"https://kubernetes.io/docs/tasks/tools/install-kubectl/\" target=\"_blank\" rel=\"noopener\">kubectl</a></li>\n<li><a href=\"https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest\" target=\"_blank\" rel=\"noopener\">Azure CLI</a></li>\n</ul>\n<h3>部署 Azure K8S 服务集群</h3>\n<hr>\n<p>这个指南向你介绍安装 Azure K8S 服务集群。如果你需要了解更多信息，参考<a href=\"https://docs.microsoft.com/en-us/azure/aks/kubernetes-walkthrough\" target=\"_blank\" rel=\"noopener\">快速开始：使用 Azure CLI 部署 Azure K8S 服务（AKS）集群</a></p>\n<ol>\n<li>登录 Azure</li>\n</ol>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">az login</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>设置默认订阅</li>\n</ol>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">az account <span class=\"built_in\">set</span> -s [your_subscription_id]</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>创建资源组</li>\n</ol>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">az group create --name [your_resource_group] --location [region]</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>创建一个 Azure K8S 服务集群</li>\n</ol>\n<p>K8S 通过 <code>--kubernetes-version</code> 使用 1.13.x 或者更新的版本</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">az aks create --resource-group [your_resource_group] --name [your_aks_cluster_name] --node-count <span class=\"number\">2</span> --kubernetes-version <span class=\"number\">1</span>.<span class=\"number\">14</span>.<span class=\"number\">7</span> --enable-addons http_application_routing --enable-rbac --generate-ssh-keys</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>从 Azure K8S 集群中获取访问凭证</li>\n</ol>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">az aks get-credentials -n [your_aks_cluster_name] -g [your_resource_group]</span><br></pre></td></tr></table></figure>\n<h3>（可选）安装 Helm v3</h3>\n<hr>\n<ol>\n<li><a href=\"https://helm.sh/docs/intro/install/\" target=\"_blank\" rel=\"noopener\">安装 Helm v3 客户端</a></li>\n</ol>\n<blockquote>\n<p>注意： 最新的 Dapr helm 图表不在支持 Helm v2。请从 heml v2 迁移至 heml v3，<a href=\"https://helm.sh/blog/migrate-from-helm-v2-to-helm-v3/\" target=\"_blank\" rel=\"noopener\">迁移指南</a></p>\n</blockquote>\n<ol start=\"2\">\n<li>如果你需要 K8S 仪表盘权限执行此命令</li>\n</ol>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create clusterrolebinding kubernetes-dashboard -n kube-system --clusterrole=cluster-admin --serviceaccount=kube-system:kubernetes-dashboard</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckh8qmyhs000a4x6yyl0f6f2i","tag_id":"ckh8qmyhm00054x6ysoojdfdc","_id":"ckh8qmyhx000d4x6ya5gkkkew"},{"post_id":"ckh8qmyhs000a4x6yyl0f6f2i","tag_id":"ckh8qmyhs00094x6y51as2a85","_id":"ckh8qmyhz000f4x6y40843h6a"},{"post_id":"ckh8qmyhf00014x6y3etn3vwk","tag_id":"ckh8qmyhm00054x6ysoojdfdc","_id":"ckh8qmyi1000i4x6ynhr57aiq"},{"post_id":"ckh8qmyhf00014x6y3etn3vwk","tag_id":"ckh8qmyhs00094x6y51as2a85","_id":"ckh8qmyi2000k4x6yahu0md50"},{"post_id":"ckh8qmyhy000e4x6yamno71z6","tag_id":"ckh8qmyhm00054x6ysoojdfdc","_id":"ckh8qmyi4000n4x6y18c7vgsg"},{"post_id":"ckh8qmyhy000e4x6yamno71z6","tag_id":"ckh8qmyhs00094x6y51as2a85","_id":"ckh8qmyi5000p4x6yf3i7gibg"},{"post_id":"ckh8qmyhz000g4x6yculwj85f","tag_id":"ckh8qmyhm00054x6ysoojdfdc","_id":"ckh8qmyi6000r4x6yvwsmzz9h"},{"post_id":"ckh8qmyhz000g4x6yculwj85f","tag_id":"ckh8qmyhs00094x6y51as2a85","_id":"ckh8qmyi6000s4x6y2uxyqiz9"},{"post_id":"ckh8qmyi1000j4x6y09eqd3t8","tag_id":"ckh8qmyhm00054x6ysoojdfdc","_id":"ckh8qmyi7000u4x6yos94wltu"},{"post_id":"ckh8qmyi1000j4x6y09eqd3t8","tag_id":"ckh8qmyhs00094x6y51as2a85","_id":"ckh8qmyi7000v4x6y5l3digrh"},{"post_id":"ckh8qmyhk00034x6y4jf1ffwh","tag_id":"ckh8qmyhm00054x6ysoojdfdc","_id":"ckh8qmyi8000x4x6ys1estjc2"},{"post_id":"ckh8qmyhk00034x6y4jf1ffwh","tag_id":"ckh8qmyhs00094x6y51as2a85","_id":"ckh8qmyi8000y4x6yf6teo81p"},{"post_id":"ckh8qmyi3000l4x6yt3ebagzl","tag_id":"ckh8qmyhm00054x6ysoojdfdc","_id":"ckh8qmyi800104x6y1gz8rk3m"},{"post_id":"ckh8qmyi3000l4x6yt3ebagzl","tag_id":"ckh8qmyhs00094x6y51as2a85","_id":"ckh8qmyi800114x6yz20hg8b6"},{"post_id":"ckh8qmyi4000o4x6yg7m0t2xy","tag_id":"ckh8qmyhm00054x6ysoojdfdc","_id":"ckh8qmyi800124x6yxgnaxwh3"},{"post_id":"ckh8qmyi4000o4x6yg7m0t2xy","tag_id":"ckh8qmyhs00094x6y51as2a85","_id":"ckh8qmyi900134x6y1ebe8omr"},{"post_id":"ckh8qmyho00064x6y2ou8jxgq","tag_id":"ckh8qmyhm00054x6ysoojdfdc","_id":"ckh8qmyi900144x6yhmrv9dgg"},{"post_id":"ckh8qmyho00064x6y2ou8jxgq","tag_id":"ckh8qmyhs00094x6y51as2a85","_id":"ckh8qmyi900154x6yjpbmemlb"},{"post_id":"ckh8qmyhp00074x6y5bps6sc6","tag_id":"ckh8qmyhm00054x6ysoojdfdc","_id":"ckh8qmyi900164x6ycz5leqfo"},{"post_id":"ckh8qmyhp00074x6y5bps6sc6","tag_id":"ckh8qmyhs00094x6y51as2a85","_id":"ckh8qmyi900174x6yclemjn1e"},{"post_id":"ckh8qmyhr00084x6yq7qpfl15","tag_id":"ckh8qmyhm00054x6ysoojdfdc","_id":"ckh8qmyi900184x6yynk2cs2c"},{"post_id":"ckh8qmyhr00084x6yq7qpfl15","tag_id":"ckh8qmyi7000w4x6yqqtyhjsn","_id":"ckh8qmyi900194x6ylnki1pra"},{"post_id":"ckh8qmyhv000b4x6yfsv14nih","tag_id":"ckh8qmyhm00054x6ysoojdfdc","_id":"ckh8qmyi9001a4x6yd6mfbelq"},{"post_id":"ckh8qmyhv000b4x6yfsv14nih","tag_id":"ckh8qmyi8000z4x6y2w2qygvj","_id":"ckh8qmyi9001b4x6y13x43pyl"}],"Tag":[{"name":"Dapr","_id":"ckh8qmyhm00054x6ysoojdfdc"},{"name":"原文翻译","_id":"ckh8qmyhs00094x6y51as2a85"},{"name":"Go","_id":"ckh8qmyi7000w4x6yqqtyhjsn"},{"name":"Java","_id":"ckh8qmyi8000z4x6y2w2qygvj"}]}}