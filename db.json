{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/img/icon_wechat.png","path":"img/icon_wechat.png","modified":1,"renderable":0},{"_id":"source/img/about/about-bg.jpg","path":"img/about/about-bg.jpg","modified":1,"renderable":0},{"_id":"source/img/avatar/home-bg.jpg","path":"img/avatar/home-bg.jpg","modified":1,"renderable":0},{"_id":"source/img/avatar/head.jpg","path":"img/avatar/head.jpg","modified":1,"renderable":0},{"_id":"source/img/dapr/dapr.svg","path":"img/dapr/dapr.svg","modified":1,"renderable":0},{"_id":"source/img/dapr/overview-sidecar.png","path":"img/dapr/overview-sidecar.png","modified":1,"renderable":0},{"_id":"source/img/dapr/overview-sidecar-kubernetes.png","path":"img/dapr/overview-sidecar-kubernetes.png","modified":1,"renderable":0},{"_id":"source/img/dapr/service-invocation.png","path":"img/dapr/service-invocation.png","modified":1,"renderable":0},{"_id":"themes/huweihuang/source/css/beantech.min.css","path":"css/beantech.min.css","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/donate.css","path":"css/donate.css","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/archive.styl","path":"css/archive.styl","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/beantech.css","path":"css/beantech.css","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/rocket.styl","path":"css/rocket.styl","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/signature.styl","path":"css/signature.styl","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/toc.styl","path":"css/toc.styl","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/widget.styl","path":"css/widget.styl","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/hux-blog.js","path":"js/hux-blog.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/toc.js","path":"js/toc.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":1,"renderable":1},{"_id":"source/img/dapr/overview.png","path":"img/dapr/overview.png","modified":1,"renderable":0},{"_id":"source/img/dapr/overview_kubernetes.png","path":"img/dapr/overview_kubernetes.png","modified":1,"renderable":0},{"_id":"source/img/dapr/overview_standalone.png","path":"img/dapr/overview_standalone.png","modified":1,"renderable":0},{"_id":"themes/huweihuang/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/bootstrap.js","path":"js/bootstrap.js","modified":1,"renderable":1},{"_id":"source/img/header_img/archives-widget.jpg","path":"img/header_img/archives-widget.jpg","modified":1,"renderable":0},{"_id":"source/img/signature/BeanTechSign-white.png","path":"img/signature/BeanTechSign-white.png","modified":1,"renderable":0},{"_id":"themes/huweihuang/source/css/images/ironman.png","path":"css/images/ironman.png","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/images/rocket.png","path":"css/images/rocket.png","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/bootstrap.css","path":"css/bootstrap.css","modified":1,"renderable":1},{"_id":"source/img/dapr/building_blocks.png","path":"img/dapr/building_blocks.png","modified":1,"renderable":0},{"_id":"source/img/header_img/archive.jpg","path":"img/header_img/archive.jpg","modified":1,"renderable":0},{"_id":"themes/huweihuang/source/js/jquery.js","path":"js/jquery.js","modified":1,"renderable":1},{"_id":"source/img/signature/BeanTechSign-black.png","path":"img/signature/BeanTechSign-black.png","modified":1,"renderable":0},{"_id":"source/img/article_header/article_bg.jpg","path":"img/article_header/article_bg.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/home.jpg","path":"img/header_img/home.jpg","modified":1,"renderable":0},{"_id":"source/img/blog.jpg","path":"img/blog.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/tag.png","path":"img/header_img/tag.png","modified":1,"renderable":0},{"_id":"source/img/article_header/article_header.png","path":"img/article_header/article_header.png","modified":1,"renderable":0},{"_id":"source/img/header_img/home-bg-o.png","path":"img/header_img/home-bg-o.png","modified":1,"renderable":0},{"_id":"source/img/header_img/home2.png","path":"img/header_img/home2.png","modified":1,"renderable":0},{"_id":"source/img/header_img/404.png","path":"img/header_img/404.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/404.md","hash":"8aa56af7bcd7cd23667cbf3eb5b5c9fa4533eb60","modified":1599794096748},{"_id":"source/.DS_Store","hash":"5922ec11b7ba4d81b7e55a152193107c9940911d","modified":1599794172851},{"_id":"source/CNAME","hash":"9e6f57443c916597fbd8257c2f90d8533eaff248","modified":1599794096748},{"_id":"themes/huweihuang/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1599794096817},{"_id":"themes/huweihuang/_config.yml","hash":"e800e32847df32dacddb5202823a004557023bcd","modified":1599794096818},{"_id":"source/_posts/dapr-doc.md","hash":"4f5d080bdc07798cccfdf3e287a65419a64c3287","modified":1600332540743},{"_id":"source/_posts/dapr-readme.md","hash":"6b398face6d7c59c7b8f821984c17b92347db815","modified":1599804733099},{"_id":"source/_posts/doc-overview.md","hash":"992d564c55b151b78a32075fc1386b75e4938649","modified":1600225093890},{"_id":"source/_posts/getting-started.md","hash":"58e0df612e22471088f4e4bbcb504bb2497bd090","modified":1600330031176},{"_id":"source/_posts/invoke-and-discover-services.md","hash":"a4f587fe4596d6276e3121960ebf780357640cf3","modified":1600223290314},{"_id":"source/_posts/service-invocation-api.md","hash":"2e6e11f7d846ba144a5920e6c9232e1968ef961a","modified":1600223203050},{"_id":"source/_posts/service-invocation.md","hash":"16ab32d2a01a180ecf4cabc9109c75977713b007","modified":1600217752635},{"_id":"source/about/index.md","hash":"74db13a6b4da4b941cc883003dbd2a2c9ad5799a","modified":1600217752635},{"_id":"source/img/.DS_Store","hash":"22360e704245517c036fd963ef80a26a837e5956","modified":1599794213435},{"_id":"themes/huweihuang/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1599794096818},{"_id":"source/tags/index.md","hash":"f6ad1039c242795de5cd7d81781148f8c5298c28","modified":1599794096817},{"_id":"themes/huweihuang/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1599794096819},{"_id":"source/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1599794096813},{"_id":"themes/huweihuang/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1599794096820},{"_id":"themes/huweihuang/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1599794096819},{"_id":"themes/huweihuang/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1599794096819},{"_id":"themes/huweihuang/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1599794096821},{"_id":"themes/huweihuang/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1599794096820},{"_id":"themes/huweihuang/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1599794096821},{"_id":"themes/huweihuang/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1599794096821},{"_id":"themes/huweihuang/layout/404.ejs","hash":"40de38bd399f6f4aef0d6c63c7b13b02d74f1c56","modified":1599794096822},{"_id":"themes/huweihuang/layout/about.ejs","hash":"edcf8fa3bf7093c974d418ffef42ac89c19af128","modified":1599794096829},{"_id":"themes/huweihuang/layout/archive.ejs","hash":"c15726ab348cbf75291b88ffe5e5e50335b5cb0b","modified":1599794096829},{"_id":"themes/huweihuang/layout/index.ejs","hash":"9e682d5d19cce88ffcae6bbcd0d644df64a6d735","modified":1599794096830},{"_id":"themes/huweihuang/layout/layout.ejs","hash":"a5af5b99ac3456ab5da1a319455904b979b91601","modified":1599794096831},{"_id":"themes/huweihuang/layout/keynote.ejs","hash":"f5689862281e34dbe8402b0e72f632902e53e88b","modified":1599794096830},{"_id":"themes/huweihuang/layout/page.ejs","hash":"5e588f200a7b7cd3ae40402b0dd3b779aac6787f","modified":1599794096831},{"_id":"themes/huweihuang/layout/tags.ejs","hash":"2c72eb2e89130658aa068d80d27b561b509c5dcd","modified":1599794096833},{"_id":"themes/huweihuang/layout/post.ejs","hash":"7088681f19dee7f2bb3d52969a912521423a6494","modified":1599794096832},{"_id":"source/img/about/about-bg.jpg","hash":"c92ad7eed5af90b07f73733ae54330d5744c8023","modified":1599794149238},{"_id":"source/img/about/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1599794201699},{"_id":"source/img/avatar/home-bg.jpg","hash":"e81513cb4806bfa0cd25a678fd3fa230ffa316bf","modified":1599794143395},{"_id":"source/img/avatar/head.jpg","hash":"29cd76dc99a7dfef64ffb8195ab75d52e8282bcb","modified":1599794136780},{"_id":"source/img/dapr/dapr.svg","hash":"fee095056405185e7401b35bf2cb0452c6ede45d","modified":1599794096789},{"_id":"source/img/dapr/overview-sidecar.png","hash":"3c48e68030f974128f19cfeebd0322412e0b3c29","modified":1600217752637},{"_id":"source/img/avatar/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1599794258619},{"_id":"source/img/dapr/overview-sidecar-kubernetes.png","hash":"0566eeedbc3ab9d00cffe43e33004bed13645050","modified":1600217752637},{"_id":"source/img/dapr/service-invocation.png","hash":"818f4068046e78f8ec9b17008be656fddcf9416a","modified":1600217752639},{"_id":"themes/huweihuang/layout/_partial/nav.ejs","hash":"4c905166c960852e9b9a3c9d5c680091e37b481f","modified":1599794096824},{"_id":"themes/huweihuang/layout/_partial/footer.ejs","hash":"3f8764398089fd3712613347c25f8a9406c633b9","modified":1599794096823},{"_id":"themes/huweihuang/layout/_partial/head.ejs","hash":"720349195a5ea7b610a82ce3ce74298fb2bc7347","modified":1599794096823},{"_id":"themes/huweihuang/layout/_partial/header.ejs","hash":"3bd09df76e0622d76d186b020393fcab361e6c97","modified":1599794096823},{"_id":"themes/huweihuang/layout/_partial/toc.ejs","hash":"40e11b303df113c64a5ca35b79dd53c824010c09","modified":1599794096826},{"_id":"themes/huweihuang/layout/_partial/sidebar.ejs","hash":"2e4e528a555917b2a267da4db2440bcc4a7a65ab","modified":1599794096825},{"_id":"themes/huweihuang/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1599794096824},{"_id":"themes/huweihuang/layout/_widget/archive.ejs","hash":"7594929d472806ca4c64d9906d9903a96de111a0","modified":1599794096826},{"_id":"themes/huweihuang/layout/_widget/category.ejs","hash":"1cf485def07dc06e870dc9613767c6c614bcf428","modified":1599794096827},{"_id":"themes/huweihuang/layout/_widget/recent-posts.ejs","hash":"e08ab8ba60e31638006acf27f066b989a0a3c433","modified":1599794096828},{"_id":"themes/huweihuang/layout/_widget/featured-tags.ejs","hash":"0c9ce1942f1943dc8891a9302a922ef1ffe300c5","modified":1599794096827},{"_id":"themes/huweihuang/layout/_widget/friends-blog.ejs","hash":"734d3775017aedac185028924baf890a71a74548","modified":1599794096827},{"_id":"themes/huweihuang/layout/_widget/short-about.ejs","hash":"315de02246f07c747c32495e107ad7b19cb3ff54","modified":1599794096828},{"_id":"themes/huweihuang/source/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1599794096834},{"_id":"themes/huweihuang/source/css/donate.css","hash":"f65ac8363d8d215adb896158e7b45165db259a47","modified":1599794096836},{"_id":"themes/huweihuang/source/css/highlight.styl","hash":"e842080e6d580f0f70a7df71fbde3c4e49463c19","modified":1599794096837},{"_id":"themes/huweihuang/source/css/archive.styl","hash":"715bcbd085eb95ec26c9805c11c374919cde971c","modified":1599794096834},{"_id":"themes/huweihuang/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1599794096837},{"_id":"themes/huweihuang/source/css/beantech.css","hash":"4c361354fd8e9851923fb21a620bc079380ebcd8","modified":1599794096834},{"_id":"themes/huweihuang/source/css/rocket.styl","hash":"e15c51c8566ecd943112e57592888dd318b6fa6a","modified":1599794096838},{"_id":"themes/huweihuang/source/css/signature.styl","hash":"88159b31c59d59c01a0b534af57242662a2a3969","modified":1599794096839},{"_id":"themes/huweihuang/source/css/toc.styl","hash":"631e97f634d30f53314e2fec8bdde267c1c49f4c","modified":1599794096839},{"_id":"themes/huweihuang/source/css/widget.styl","hash":"7a9f735f5ef323dc2950fbd9d76daa16c9a0f1a9","modified":1599794096840},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1599794096840},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1599794096842},{"_id":"themes/huweihuang/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1599794096843},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1599794096842},{"_id":"themes/huweihuang/source/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1599794096843},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1599794096842},{"_id":"themes/huweihuang/source/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1599794096843},{"_id":"themes/huweihuang/source/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1599794096846},{"_id":"themes/huweihuang/source/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1599794096846},{"_id":"themes/huweihuang/source/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1599794096846},{"_id":"themes/huweihuang/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1599794096846},{"_id":"source/img/dapr/overview.png","hash":"3ebb0e3bd00841e91969fc0aa2863d22e50d8176","modified":1600217752637},{"_id":"source/img/dapr/overview_kubernetes.png","hash":"f55d770ee0d898b1fd7fc6f14d5016d12698545b","modified":1600217752638},{"_id":"source/img/dapr/overview_standalone.png","hash":"dce33e69dbe7ba0d9f40a318716828e335a9dd18","modified":1600217752639},{"_id":"themes/huweihuang/source/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1599794096836},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1599794096841},{"_id":"themes/huweihuang/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1599794096845},{"_id":"themes/huweihuang/source/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1599794096843},{"_id":"source/img/header_img/archives-widget.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1599794096798},{"_id":"source/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1599794096816},{"_id":"themes/huweihuang/source/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1599794096837},{"_id":"themes/huweihuang/source/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1599794096838},{"_id":"themes/huweihuang/source/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1599794096835},{"_id":"source/img/dapr/building_blocks.png","hash":"bc13ae897d8ed056bd4ed7693b7a056190f1e96d","modified":1600217752636},{"_id":"source/img/header_img/archive.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1599794096796},{"_id":"themes/huweihuang/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1599794096845},{"_id":"source/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1599794096814},{"_id":"source/img/article_header/article_bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1599794096770},{"_id":"source/img/header_img/home.jpg","hash":"8f1c440427a4aa86b623503a926c027e2e10cd66","modified":1599794096804},{"_id":"source/img/blog.jpg","hash":"a76af0b98dbe92ca2d21babcef13f094e409554b","modified":1599794096788},{"_id":"source/img/header_img/tag.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1599794096812},{"_id":"source/img/article_header/article_header.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1599794096773},{"_id":"source/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1599794096801},{"_id":"source/img/header_img/home2.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1599794096808},{"_id":"source/img/header_img/404.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1599794096794},{"_id":"public/post-sitemap.xml","hash":"4532b4d5756f6e814e76f9bcdd7d5039b7f3a593","modified":1600332649810},{"_id":"public/tag-sitemap.xml","hash":"409dc95b7e34900dec455ad8209564e34eece68e","modified":1600332649846},{"_id":"public/page-sitemap.xml","hash":"67679b541cb7f9dde42b1ce5e7eaa4b8476fa361","modified":1600332649854},{"_id":"public/sitemap.xsl","hash":"0fd30cf5d1d596c10211a430bf1109b3318a6509","modified":1600332649855},{"_id":"public/sitemap.xml","hash":"8d5e163d2b95c2bbf21179373396bd56016aeb20","modified":1600332649855},{"_id":"public/404.html","hash":"ad7f12366125de06a2be746a2b92ad5557a46f7b","modified":1600332649862},{"_id":"public/about/index.html","hash":"651eaec68ce6f2cf08924e95b6f211e545eae5a6","modified":1600332649862},{"_id":"public/tags/index.html","hash":"2d6beb4e24952c46db87bdbebe93905ae06cf0e0","modified":1600332649862},{"_id":"public/article/dapr-doc/index.html","hash":"9a62226aa1551ca8f3ac3876914d0ea61f4a2844","modified":1600332649862},{"_id":"public/article/service-invocation-api/index.html","hash":"0c814be5cafbaf455f1e5e63dd180e1cc80b5513","modified":1600332649863},{"_id":"public/article/getting-started/index.html","hash":"1294e6e3185f6f6d06ca3728624679dcf23a611a","modified":1600332649863},{"_id":"public/article/invoke-and-discover-services/index.html","hash":"c4c934cb3a91336f34b29c36577984a9d7b91d57","modified":1600332649863},{"_id":"public/article/service-invocation/index.html","hash":"e3dd7d3589b7078a9b17c2b047d42edd4cbb8f31","modified":1600332649863},{"_id":"public/article/doc-overview/index.html","hash":"7298d17b6f045512c6095af704e652f1bc9d79ad","modified":1600332649863},{"_id":"public/article/dapr-readme/index.html","hash":"723d9c336b419c9b88cef0868539b75585038ed6","modified":1600332649863},{"_id":"public/index.html","hash":"b466f7260ed2696b8b73d888fcc8f9050e97eda6","modified":1600332649863},{"_id":"public/archives/index.html","hash":"99b24f1dfcd053f80031aee40c4871ee0a58d47b","modified":1600332649863},{"_id":"public/archives/2020/index.html","hash":"9d5b72038039d1de6d4943dbd4b1f3964234e81a","modified":1600332649863},{"_id":"public/archives/2020/09/index.html","hash":"18d59be4b15ab124939d26fea6506c90d77b3f43","modified":1600332649863},{"_id":"public/tags/Dapr/index.html","hash":"7e58e92f449c9c8d02ea3f2f5db19cc2fb68c890","modified":1600332649863},{"_id":"public/tags/原文翻译/index.html","hash":"8667b69a3a55df1c973bc89708900c9ea26f3534","modified":1600332649863},{"_id":"public/CNAME","hash":"9e6f57443c916597fbd8257c2f90d8533eaff248","modified":1600332649874},{"_id":"public/img/about/about-bg.jpg","hash":"c92ad7eed5af90b07f73733ae54330d5744c8023","modified":1600332649874},{"_id":"public/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1600332649874},{"_id":"public/img/avatar/home-bg.jpg","hash":"e81513cb4806bfa0cd25a678fd3fa230ffa316bf","modified":1600332649874},{"_id":"public/img/dapr/dapr.svg","hash":"fee095056405185e7401b35bf2cb0452c6ede45d","modified":1600332649874},{"_id":"public/img/avatar/head.jpg","hash":"29cd76dc99a7dfef64ffb8195ab75d52e8282bcb","modified":1600332649874},{"_id":"public/img/dapr/overview-sidecar.png","hash":"3c48e68030f974128f19cfeebd0322412e0b3c29","modified":1600332649874},{"_id":"public/img/dapr/overview-sidecar-kubernetes.png","hash":"0566eeedbc3ab9d00cffe43e33004bed13645050","modified":1600332649874},{"_id":"public/img/dapr/service-invocation.png","hash":"818f4068046e78f8ec9b17008be656fddcf9416a","modified":1600332649874},{"_id":"public/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1600332649874},{"_id":"public/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1600332649874},{"_id":"public/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1600332649875},{"_id":"public/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1600332649875},{"_id":"public/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1600332649875},{"_id":"public/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1600332649875},{"_id":"public/img/dapr/overview.png","hash":"3ebb0e3bd00841e91969fc0aa2863d22e50d8176","modified":1600332650123},{"_id":"public/img/dapr/overview_kubernetes.png","hash":"f55d770ee0d898b1fd7fc6f14d5016d12698545b","modified":1600332650124},{"_id":"public/img/dapr/overview_standalone.png","hash":"dce33e69dbe7ba0d9f40a318716828e335a9dd18","modified":1600332650126},{"_id":"public/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1600332650126},{"_id":"public/css/donate.css","hash":"f65ac8363d8d215adb896158e7b45165db259a47","modified":1600332650131},{"_id":"public/css/highlight.css","hash":"c58b4569c086e477a00dcbf5a95a166fe5fecfb0","modified":1600332650131},{"_id":"public/css/archive.css","hash":"8db895ebaeff19ac145c961abcfd5d4a8d67a8ea","modified":1600332650131},{"_id":"public/css/rocket.css","hash":"9456fd92f729e09d6de8cda70f95d78e0d789c70","modified":1600332650131},{"_id":"public/css/toc.css","hash":"f756b9e1b2208d2e5b0f3d2ac5e4fea3b7da0e10","modified":1600332650131},{"_id":"public/css/widget.css","hash":"da95ad3f1938f24d20f1fa77d7a38f0c392b5ec8","modified":1600332650132},{"_id":"public/css/signature.css","hash":"820fa4743cea34a61808cd8f7de528605c32d7e3","modified":1600332650132},{"_id":"public/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1600332650132},{"_id":"public/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1600332650132},{"_id":"public/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1600332650132},{"_id":"public/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1600332650132},{"_id":"public/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1600332650132},{"_id":"public/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1600332650132},{"_id":"public/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1600332650132},{"_id":"public/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1600332650133},{"_id":"public/css/beantech.css","hash":"4c361354fd8e9851923fb21a620bc079380ebcd8","modified":1600332650133},{"_id":"public/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1600332650133},{"_id":"public/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1600332650133},{"_id":"public/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1600332650133},{"_id":"public/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1600332650133},{"_id":"public/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1600332650134},{"_id":"public/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1600332650134},{"_id":"public/img/header_img/archives-widget.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1600332650134},{"_id":"public/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1600332650134},{"_id":"public/img/header_img/archive.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1600332650137},{"_id":"public/img/article_header/article_bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1600332650141},{"_id":"public/img/dapr/building_blocks.png","hash":"bc13ae897d8ed056bd4ed7693b7a056190f1e96d","modified":1600332650143},{"_id":"public/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1600332650145},{"_id":"public/img/header_img/home.jpg","hash":"8f1c440427a4aa86b623503a926c027e2e10cd66","modified":1600332650154},{"_id":"public/img/blog.jpg","hash":"a76af0b98dbe92ca2d21babcef13f094e409554b","modified":1600332650157},{"_id":"public/img/header_img/tag.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1600332650167},{"_id":"public/img/article_header/article_header.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1600332650176},{"_id":"public/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1600332650179},{"_id":"public/img/header_img/home2.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1600332650181},{"_id":"public/img/header_img/404.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1600332650185}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原","header-img":"/img/header_img/404.png","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原\"\nheader-img: \"/img/header_img/404.png\"\n---\n","date":"2020-09-11T03:14:56.748Z","updated":"2020-09-11T03:14:56.748Z","path":"404.html","title":"","comments":1,"_id":"ckf6kqn490000du98skkj3yci","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"ABOUT","date":"2020-09-11T00:59:25.000Z","description":null,"header-img":"/img/about/about-bg.jpg","_content":"\n# Dapr\n\nCurrent Version: 0.10.0\n\n---\n鉴于 Dapr 即将发布 1.0 版本，我将对 Dapr 在 Java8 、.Net5、Golang、Python3 的运用做成系列文章以抛砖引玉。\n\n> *注：* Dapr 将在 2020 年底或者 2021 年初发布 1.0 稳定版。.NET5 将在 11 月份发布正式版。\n\n## Dapr 概念\n\n此节将包含部分官方文档翻译以及我对 Dapr 的理解，如有必要，将对源码进行解读。\n\n### 官方文档翻译\n\n- {% post_link dapr-readme %}\n- {% post_link doc-overview %}\n\n### 通过 Java8 使用 Dapr\n\n### 通过 .Net5 使用 Dapr\n\n### 通过 Golang 使用 Dapr\n\n### 通过 Python3 使用 Dapr\n\n## 一些章节\n\n此章节是 Dapr 0.3.0 版本我发布过的一些内容。从版本号来看确实有挺大的差距。但仍具参考价值。\n\n- [Dapr 运用](https://www.cnblogs.com/Zhang-Xiang/p/12035354.html)\n  - 使用 `Asp.Net Core` 包含3个服务\n    - ProductService\n    - StorageService\n- [Dapr 运用之 Java gRPC 调用篇](https://www.cnblogs.com/Zhang-Xiang/p/12058097.html)\n  - 使用 Java 实现 gRPC 服务，并通过 Dapr 调用\n- [Dapr Pub/Sub 集成 RabbitMQ 、Golang、Java、DotNet Core](https://www.cnblogs.com/Zhang-Xiang/p/12106577.html)\n  - 通过 Dapr 完成 Go 与 Java 的调用，并完成 Pub/Sub\n","source":"about/index.md","raw":"---\ntitle: ABOUT\ndate: 2020-09-11 08:59:25\ndescription: \nheader-img: \"/img/about/about-bg.jpg\"\n---\n\n# Dapr\n\nCurrent Version: 0.10.0\n\n---\n鉴于 Dapr 即将发布 1.0 版本，我将对 Dapr 在 Java8 、.Net5、Golang、Python3 的运用做成系列文章以抛砖引玉。\n\n> *注：* Dapr 将在 2020 年底或者 2021 年初发布 1.0 稳定版。.NET5 将在 11 月份发布正式版。\n\n## Dapr 概念\n\n此节将包含部分官方文档翻译以及我对 Dapr 的理解，如有必要，将对源码进行解读。\n\n### 官方文档翻译\n\n- {% post_link dapr-readme %}\n- {% post_link doc-overview %}\n\n### 通过 Java8 使用 Dapr\n\n### 通过 .Net5 使用 Dapr\n\n### 通过 Golang 使用 Dapr\n\n### 通过 Python3 使用 Dapr\n\n## 一些章节\n\n此章节是 Dapr 0.3.0 版本我发布过的一些内容。从版本号来看确实有挺大的差距。但仍具参考价值。\n\n- [Dapr 运用](https://www.cnblogs.com/Zhang-Xiang/p/12035354.html)\n  - 使用 `Asp.Net Core` 包含3个服务\n    - ProductService\n    - StorageService\n- [Dapr 运用之 Java gRPC 调用篇](https://www.cnblogs.com/Zhang-Xiang/p/12058097.html)\n  - 使用 Java 实现 gRPC 服务，并通过 Dapr 调用\n- [Dapr Pub/Sub 集成 RabbitMQ 、Golang、Java、DotNet Core](https://www.cnblogs.com/Zhang-Xiang/p/12106577.html)\n  - 通过 Dapr 完成 Go 与 Java 的调用，并完成 Pub/Sub\n","updated":"2020-09-16T00:55:52.635Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckf6kqn5x000udu98vk9zwp43","content":"<h1 id=\"dapr\">Dapr</h1>\n<p>Current Version: 0.10.0</p>\n<hr>\n<p>鉴于 Dapr 即将发布 1.0 版本，我将对 Dapr 在 Java8 、.Net5、Golang、Python3 的运用做成系列文章以抛砖引玉。</p>\n<blockquote>\n<p><em>注：</em> Dapr 将在 2020 年底或者 2021 年初发布 1.0 稳定版。.NET5 将在 11 月份发布正式版。</p>\n</blockquote>\n<h2 id=\"dapr-概念\">Dapr 概念</h2>\n<p>此节将包含部分官方文档翻译以及我对 Dapr 的理解，如有必要，将对源码进行解读。</p>\n<h3 id=\"官方文档翻译\">官方文档翻译</h3>\n<ul>\n<li>\n<a href=\"/article/dapr-readme/\" title=\"简介\">简介</a>\n</li>\n<li>\n<a href=\"/article/doc-overview/\" title=\"Dapr 概述\">Dapr 概述</a>\n</li>\n</ul>\n<h3 id=\"通过-java8-使用-dapr\">通过 Java8 使用 Dapr</h3>\n<h3 id=\"通过-net5-使用-dapr\">通过 .Net5 使用 Dapr</h3>\n<h3 id=\"通过-golang-使用-dapr\">通过 Golang 使用 Dapr</h3>\n<h3 id=\"通过-python3-使用-dapr\">通过 Python3 使用 Dapr</h3>\n<h2 id=\"一些章节\">一些章节</h2>\n<p>此章节是 Dapr 0.3.0 版本我发布过的一些内容。从版本号来看确实有挺大的差距。但仍具参考价值。</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/Zhang-Xiang/p/12035354.html\" target=\"_blank\" rel=\"noopener\">Dapr 运用</a>\n<ul>\n<li>使用 <code>Asp.Net Core</code> 包含3个服务\n<ul>\n<li>ProductService</li>\n<li>StorageService</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://www.cnblogs.com/Zhang-Xiang/p/12058097.html\" target=\"_blank\" rel=\"noopener\">Dapr 运用之 Java gRPC 调用篇</a>\n<ul>\n<li>使用 Java 实现 gRPC 服务，并通过 Dapr 调用</li>\n</ul>\n</li>\n<li><a href=\"https://www.cnblogs.com/Zhang-Xiang/p/12106577.html\" target=\"_blank\" rel=\"noopener\">Dapr Pub/Sub 集成 RabbitMQ 、Golang、Java、DotNet Core</a>\n<ul>\n<li>通过 Dapr 完成 Go 与 Java 的调用，并完成 Pub/Sub</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1>Dapr</h1>\n<p>Current Version: 0.10.0</p>\n<hr>\n<p>鉴于 Dapr 即将发布 1.0 版本，我将对 Dapr 在 Java8 、.Net5、Golang、Python3 的运用做成系列文章以抛砖引玉。</p>\n<blockquote>\n<p><em>注：</em> Dapr 将在 2020 年底或者 2021 年初发布 1.0 稳定版。.NET5 将在 11 月份发布正式版。</p>\n</blockquote>\n<h2>Dapr 概念</h2>\n<p>此节将包含部分官方文档翻译以及我对 Dapr 的理解，如有必要，将对源码进行解读。</p>\n<h3>官方文档翻译</h3>\n<ul>\n<li>\n<a href=\"/article/dapr-readme/\" title=\"简介\">简介</a>\n</li>\n<li>\n<a href=\"/article/doc-overview/\" title=\"Dapr 概述\">Dapr 概述</a>\n</li>\n</ul>\n<h3>通过 Java8 使用 Dapr</h3>\n<h3>通过 .Net5 使用 Dapr</h3>\n<h3>通过 Golang 使用 Dapr</h3>\n<h3>通过 Python3 使用 Dapr</h3>\n<h2>一些章节</h2>\n<p>此章节是 Dapr 0.3.0 版本我发布过的一些内容。从版本号来看确实有挺大的差距。但仍具参考价值。</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/Zhang-Xiang/p/12035354.html\" target=\"_blank\" rel=\"noopener\">Dapr 运用</a>\n<ul>\n<li>使用 <code>Asp.Net Core</code> 包含3个服务\n<ul>\n<li>ProductService</li>\n<li>StorageService</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://www.cnblogs.com/Zhang-Xiang/p/12058097.html\" target=\"_blank\" rel=\"noopener\">Dapr 运用之 Java gRPC 调用篇</a>\n<ul>\n<li>使用 Java 实现 gRPC 服务，并通过 Dapr 调用</li>\n</ul>\n</li>\n<li><a href=\"https://www.cnblogs.com/Zhang-Xiang/p/12106577.html\" target=\"_blank\" rel=\"noopener\">Dapr Pub/Sub 集成 RabbitMQ 、Golang、Java、DotNet Core</a>\n<ul>\n<li>通过 Dapr 完成 Go 与 Java 的调用，并完成 Pub/Sub</li>\n</ul>\n</li>\n</ul>\n"},{"layout":"tags","title":"Tags","description":"Hey, this is Tags.","header-img":"/img/header_img/tag.png","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"/img/header_img/tag.png\"\n---\n","date":"2020-09-11T03:14:56.817Z","updated":"2020-09-11T03:14:56.817Z","path":"tags/index.html","comments":1,"_id":"ckf6kqn5z000vdu98wuhtq4rz","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Dapr 文档","catalog":true,"toc_nav_num":true,"date":"2020-09-17T08:18:58.000Z","subtitle":"dapr/docs","header-img":"/img/dapr/dapr.svg","top":1,"catagories":["Dapr"],"_content":"\n## Dapr 文档\n\n---\n\n### 内容\n\n主题|描述\n--|--\n{% post_link doc-overview 概述%}|Dapr 概述以及你如何使用它构建事件驱动、分部署应用程序\n{% post_link getting-started 快速开始 %}|设置你的开发环境\n概念|Dapr 概念解释\n如何做|指导解释如何完成指定的任务\n最佳实践|指导解释使用 Dapr 最佳实践\n引用|API 和绑定引用文档\nFAQ|常见问答\n\n### 更多文档\n","source":"_posts/dapr-doc.md","raw":"---\ntitle: Dapr 文档\ncatalog: true\ntoc_nav_num: true\ndate: 2020-09-17 16:18:58\nsubtitle: dapr/docs\nheader-img: /img/dapr/dapr.svg\ntop: 1\ntags: \n- Dapr\n- 原文翻译\ncatagories:\n- Dapr\n---\n\n## Dapr 文档\n\n---\n\n### 内容\n\n主题|描述\n--|--\n{% post_link doc-overview 概述%}|Dapr 概述以及你如何使用它构建事件驱动、分部署应用程序\n{% post_link getting-started 快速开始 %}|设置你的开发环境\n概念|Dapr 概念解释\n如何做|指导解释如何完成指定的任务\n最佳实践|指导解释使用 Dapr 最佳实践\n引用|API 和绑定引用文档\nFAQ|常见问答\n\n### 更多文档\n","slug":"dapr-doc","published":1,"updated":"2020-09-17T08:49:00.743Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckf6kqn4y0001du98s1ltkl79","content":"<h2 id=\"dapr-文档\">Dapr 文档</h2>\n<hr>\n<h3 id=\"内容\">内容</h3>\n<table>\n<thead>\n<tr>\n<th>主题</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"/article/doc-overview/\" title=\"概述\">概述</a></td>\n<td>Dapr 概述以及你如何使用它构建事件驱动、分部署应用程序</td>\n</tr>\n<tr>\n<td><a href=\"/article/getting-started/\" title=\"快速开始\">快速开始</a></td>\n<td>设置你的开发环境</td>\n</tr>\n<tr>\n<td>概念</td>\n<td>Dapr 概念解释</td>\n</tr>\n<tr>\n<td>如何做</td>\n<td>指导解释如何完成指定的任务</td>\n</tr>\n<tr>\n<td>最佳实践</td>\n<td>指导解释使用 Dapr 最佳实践</td>\n</tr>\n<tr>\n<td>引用</td>\n<td>API 和绑定引用文档</td>\n</tr>\n<tr>\n<td>FAQ</td>\n<td>常见问答</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"更多文档\">更多文档</h3>\n","site":{"data":{}},"excerpt":"","more":"<h2>Dapr 文档</h2>\n<hr>\n<h3>内容</h3>\n<table>\n<thead>\n<tr>\n<th>主题</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"/article/doc-overview/\" title=\"概述\">概述</a></td>\n<td>Dapr 概述以及你如何使用它构建事件驱动、分部署应用程序</td>\n</tr>\n<tr>\n<td><a href=\"/article/getting-started/\" title=\"快速开始\">快速开始</a></td>\n<td>设置你的开发环境</td>\n</tr>\n<tr>\n<td>概念</td>\n<td>Dapr 概念解释</td>\n</tr>\n<tr>\n<td>如何做</td>\n<td>指导解释如何完成指定的任务</td>\n</tr>\n<tr>\n<td>最佳实践</td>\n<td>指导解释使用 Dapr 最佳实践</td>\n</tr>\n<tr>\n<td>引用</td>\n<td>API 和绑定引用文档</td>\n</tr>\n<tr>\n<td>FAQ</td>\n<td>常见问答</td>\n</tr>\n</tbody>\n</table>\n<h3>更多文档</h3>\n"},{"title":"简介","catalog":true,"toc_nav_num":true,"date":"2020-09-11T00:59:25.000Z","subtitle":"Dapr 源码 readme","header-img":"/img/dapr/dapr.svg","catagories":["Dapr"],"_content":"\n## 介绍\n\n[官方文档地址](https://github.com/dapr/dapr)\n\nDapr（Distributed Application Runtime） 是一个可移植的（portable）、事件驱动（event-driven）的运行时框架。开发者通过 Dapr 可以构建弹性、无状态、有状态的运行在云上和边缘的微服务。并且拥抱开发语言和开发框架的多样性。\n\nDapr 将构建微服务的最佳实践整理为开放、独立的构建块。因此，你可以选择开发语言和框架构建可移植的应用程序。每个构建块都是独立的，你可以在你的应用程序中使用它们中的一个、几个或者所有。\n\n---\n\n### 如何工作\n\nDapr 注入一个边车(side-car)(通过容器或者进程注入)到每一个计算单元。边车通过事件触发器交互，和计算单元通过 HTTP 或者 gRPC 协议通信。这使得 Dapr 支持现有和未来的开发语言而不需要你导入框架或者库。\n\nDapr 通过标准 HTTP 动词或者 gRPC 接口提供内建状态管理、可靠消息（至少一次投递）、触发器和绑定。这表示你可以遵循相同的编程范式写无状态、有状态和类似 Actor 模型的服务。你可以自由的选择一致性模型、线程模型和消息传递模式。\n\nDapr 在 K8S 上原生运行，作为自托管二进制文件在你的机器上、物联网设备上运行，或者做为一个容器注入到云或本地的任何系统中。\n\nDapr 使用可插拔组件状态存储和消息总线，例如：Redis、gRPC 以提供一系列通信方法，包括使用 gRPC 完成 dapr 到 dapr 的直接通信，异步 Pub-sub 以保证消息传递至少一次的语义。\n\n### 为什么使用 Dapr\n\n高性能、可扩展并且可靠的分布式应用是很困难的。而 Dapr 提供已经验证过的模式和实践方式。它把事件驱动和参与者语义统一成一个简单、一致的编程模型。它支持所有编程语言并且不限定编程框架。 你不必面对底层函数比如线程、并发控制、分区和缩放。事实上，你只需要选择一个你熟悉的 Web 框架实现一个简单的 Web 服务。\n\nDapr 在线程和状态一致性模型方面很灵活。 你可以选择多个线程，并且在不同的一致性模型中选择。这种灵活性使你可以实现高级使用场景而不需要人工约束。Dapr 是独一无二的，因为你可以在平台和基础实现之间无缝过渡，而无需重写代码。\n","source":"_posts/dapr-readme.md","raw":"---\ntitle: 简介\ncatalog: true\ntoc_nav_num: true\ndate: 2020-09-11 08:59:25\nsubtitle: Dapr 源码 readme\nheader-img: /img/dapr/dapr.svg\ntags: \n- Dapr\n- 原文翻译\ncatagories:\n- Dapr\n---\n\n## 介绍\n\n[官方文档地址](https://github.com/dapr/dapr)\n\nDapr（Distributed Application Runtime） 是一个可移植的（portable）、事件驱动（event-driven）的运行时框架。开发者通过 Dapr 可以构建弹性、无状态、有状态的运行在云上和边缘的微服务。并且拥抱开发语言和开发框架的多样性。\n\nDapr 将构建微服务的最佳实践整理为开放、独立的构建块。因此，你可以选择开发语言和框架构建可移植的应用程序。每个构建块都是独立的，你可以在你的应用程序中使用它们中的一个、几个或者所有。\n\n---\n\n### 如何工作\n\nDapr 注入一个边车(side-car)(通过容器或者进程注入)到每一个计算单元。边车通过事件触发器交互，和计算单元通过 HTTP 或者 gRPC 协议通信。这使得 Dapr 支持现有和未来的开发语言而不需要你导入框架或者库。\n\nDapr 通过标准 HTTP 动词或者 gRPC 接口提供内建状态管理、可靠消息（至少一次投递）、触发器和绑定。这表示你可以遵循相同的编程范式写无状态、有状态和类似 Actor 模型的服务。你可以自由的选择一致性模型、线程模型和消息传递模式。\n\nDapr 在 K8S 上原生运行，作为自托管二进制文件在你的机器上、物联网设备上运行，或者做为一个容器注入到云或本地的任何系统中。\n\nDapr 使用可插拔组件状态存储和消息总线，例如：Redis、gRPC 以提供一系列通信方法，包括使用 gRPC 完成 dapr 到 dapr 的直接通信，异步 Pub-sub 以保证消息传递至少一次的语义。\n\n### 为什么使用 Dapr\n\n高性能、可扩展并且可靠的分布式应用是很困难的。而 Dapr 提供已经验证过的模式和实践方式。它把事件驱动和参与者语义统一成一个简单、一致的编程模型。它支持所有编程语言并且不限定编程框架。 你不必面对底层函数比如线程、并发控制、分区和缩放。事实上，你只需要选择一个你熟悉的 Web 框架实现一个简单的 Web 服务。\n\nDapr 在线程和状态一致性模型方面很灵活。 你可以选择多个线程，并且在不同的一致性模型中选择。这种灵活性使你可以实现高级使用场景而不需要人工约束。Dapr 是独一无二的，因为你可以在平台和基础实现之间无缝过渡，而无需重写代码。\n","slug":"dapr-readme","published":1,"updated":"2020-09-11T06:12:13.099Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckf6kqn510002du982l5tf5ho","content":"<h2 id=\"介绍\">介绍</h2>\n<p><a href=\"https://github.com/dapr/dapr\" target=\"_blank\" rel=\"noopener\">官方文档地址</a></p>\n<p>Dapr（Distributed Application Runtime） 是一个可移植的（portable）、事件驱动（event-driven）的运行时框架。开发者通过 Dapr 可以构建弹性、无状态、有状态的运行在云上和边缘的微服务。并且拥抱开发语言和开发框架的多样性。</p>\n<p>Dapr 将构建微服务的最佳实践整理为开放、独立的构建块。因此，你可以选择开发语言和框架构建可移植的应用程序。每个构建块都是独立的，你可以在你的应用程序中使用它们中的一个、几个或者所有。</p>\n<hr>\n<h3 id=\"如何工作\">如何工作</h3>\n<p>Dapr 注入一个边车(side-car)(通过容器或者进程注入)到每一个计算单元。边车通过事件触发器交互，和计算单元通过 HTTP 或者 gRPC 协议通信。这使得 Dapr 支持现有和未来的开发语言而不需要你导入框架或者库。</p>\n<p>Dapr 通过标准 HTTP 动词或者 gRPC 接口提供内建状态管理、可靠消息（至少一次投递）、触发器和绑定。这表示你可以遵循相同的编程范式写无状态、有状态和类似 Actor 模型的服务。你可以自由的选择一致性模型、线程模型和消息传递模式。</p>\n<p>Dapr 在 K8S 上原生运行，作为自托管二进制文件在你的机器上、物联网设备上运行，或者做为一个容器注入到云或本地的任何系统中。</p>\n<p>Dapr 使用可插拔组件状态存储和消息总线，例如：Redis、gRPC 以提供一系列通信方法，包括使用 gRPC 完成 dapr 到 dapr 的直接通信，异步 Pub-sub 以保证消息传递至少一次的语义。</p>\n<h3 id=\"为什么使用-dapr\">为什么使用 Dapr</h3>\n<p>高性能、可扩展并且可靠的分布式应用是很困难的。而 Dapr 提供已经验证过的模式和实践方式。它把事件驱动和参与者语义统一成一个简单、一致的编程模型。它支持所有编程语言并且不限定编程框架。 你不必面对底层函数比如线程、并发控制、分区和缩放。事实上，你只需要选择一个你熟悉的 Web 框架实现一个简单的 Web 服务。</p>\n<p>Dapr 在线程和状态一致性模型方面很灵活。 你可以选择多个线程，并且在不同的一致性模型中选择。这种灵活性使你可以实现高级使用场景而不需要人工约束。Dapr 是独一无二的，因为你可以在平台和基础实现之间无缝过渡，而无需重写代码。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>介绍</h2>\n<p><a href=\"https://github.com/dapr/dapr\" target=\"_blank\" rel=\"noopener\">官方文档地址</a></p>\n<p>Dapr（Distributed Application Runtime） 是一个可移植的（portable）、事件驱动（event-driven）的运行时框架。开发者通过 Dapr 可以构建弹性、无状态、有状态的运行在云上和边缘的微服务。并且拥抱开发语言和开发框架的多样性。</p>\n<p>Dapr 将构建微服务的最佳实践整理为开放、独立的构建块。因此，你可以选择开发语言和框架构建可移植的应用程序。每个构建块都是独立的，你可以在你的应用程序中使用它们中的一个、几个或者所有。</p>\n<hr>\n<h3>如何工作</h3>\n<p>Dapr 注入一个边车(side-car)(通过容器或者进程注入)到每一个计算单元。边车通过事件触发器交互，和计算单元通过 HTTP 或者 gRPC 协议通信。这使得 Dapr 支持现有和未来的开发语言而不需要你导入框架或者库。</p>\n<p>Dapr 通过标准 HTTP 动词或者 gRPC 接口提供内建状态管理、可靠消息（至少一次投递）、触发器和绑定。这表示你可以遵循相同的编程范式写无状态、有状态和类似 Actor 模型的服务。你可以自由的选择一致性模型、线程模型和消息传递模式。</p>\n<p>Dapr 在 K8S 上原生运行，作为自托管二进制文件在你的机器上、物联网设备上运行，或者做为一个容器注入到云或本地的任何系统中。</p>\n<p>Dapr 使用可插拔组件状态存储和消息总线，例如：Redis、gRPC 以提供一系列通信方法，包括使用 gRPC 完成 dapr 到 dapr 的直接通信，异步 Pub-sub 以保证消息传递至少一次的语义。</p>\n<h3>为什么使用 Dapr</h3>\n<p>高性能、可扩展并且可靠的分布式应用是很困难的。而 Dapr 提供已经验证过的模式和实践方式。它把事件驱动和参与者语义统一成一个简单、一致的编程模型。它支持所有编程语言并且不限定编程框架。 你不必面对底层函数比如线程、并发控制、分区和缩放。事实上，你只需要选择一个你熟悉的 Web 框架实现一个简单的 Web 服务。</p>\n<p>Dapr 在线程和状态一致性模型方面很灵活。 你可以选择多个线程，并且在不同的一致性模型中选择。这种灵活性使你可以实现高级使用场景而不需要人工约束。Dapr 是独一无二的，因为你可以在平台和基础实现之间无缝过渡，而无需重写代码。</p>\n"},{"title":"Dapr 概述","catalog":true,"toc_nav_num":true,"date":"2020-09-11T05:47:55.000Z","subtitle":"docs/overview","header-img":"/img/dapr/dapr.svg","catagories":["Dapr"],"_content":"\n## Dapr 概述\n\n---\n\n[Dapr overview](https://github.com/dapr/docs/tree/master/overview)\n\nDapr 是一个可移植的（portable）、事件驱动（event-driven）的运行时框架。企业开发者使用 Dapr 可以轻松构建弹性、无状态和有状态运行在云上和边缘的微服务。并且拥抱开发语言和开发框架的多样性。\n\n### 任何开发语言、任何开发框架、运行在任何地方\n\n---\n\n![](/img/dapr/overview.png)\n\n我们正处于云应用浪潮中。开发者使用 Web + Database 架构（例如经典3层设计）会比较轻松，但当面对天生具备分布式属性的微服务应用架构来说可能就比较吃力了。要成为一个分布式系统专家是有难度的事情，你也没必要成为一个分布式系统专家。开发者应该专注于业务逻辑，同时依赖各种云平台以使应用程序拥有可伸缩性（scale）、容错性（resiliency）、可维护性（maintainability）、弹性（elasticity） 以及云原生架构的其它属性。\n\n这就是 Dapr 切入点。Dapr 将构建微服务的最佳实践整理为开放、独立的构建块。因此，你可以选择开发语言和框架构建可移植的应用程序。每个构建块都是独立的，你可以在你的应用程序中使用它们中的一个、几个或者所有。\n\n### 云和边缘微服务构建块\n\n---\n\n![](/img/dapr/building_blocks.png)\n\n当架构微服务应用程序时有很多东西需要考虑。而当构建微服务应用程序时 Dapr 提供常用功能的最佳实践。开发者可以按标准在微服务中使用 Dapr 提供的常用功能并且部署到任何环境。Dapr 通过提供分布式系统构建块以支撑这种能力。\n\n这些构建块中每一个块都是独立的，意味着你可以在你的应用程序中使用一个、几个或者全部构建块。在 Dapr 的首次发布中，提供以下构建块：\n\n构建块|描述\n--|--\n{% post_link service-invocation 服务调用（Service Invocation） %}| 容错 service-to-service invocation 使方法调用（包括重试调用）远程服务，无论这些服务位于任何被支持的托管环境。\n状态管理（State Management）| 通过状态管理存储键/值对，可以同时在你的应用程序中实现长时间运行、高可用、有状态服务和无状态服务。状态存储是可插拔的并且可以使用 Azure CosmosDB， Azure SQL Server， PostgreSQL， AWS DynamoDB 或者 Redis。\n发布和订阅消息（Publish and Subscribe Messaging）| 发布事件和订阅主题。\n资源绑定（Resource Bindings）| 带有触发器的资源绑定进一步构建在事件驱动的架构之上，通过从任何外部源(如数据库、队列、文件系统等)接收和发送事件来实现伸缩性和容错性。\nActor 模式（Actors）| 有状态和无状态对象的模式，通过方法和状态封装使并发变得简单。Dapr 在它的 actor 运行时中提供很多能力，包括并发、状态、actor 激活/停用生命周期管理、定时器和唤醒 actor 的提醒。\n可观察性（Observability）| Dapr 发出指标、日志和根据以调试和监控 Dapr 和用户应用程序。Dapr支持分布式跟踪，以使用 W3C 跟踪上下文标准和 Open Telemetry 发送到不同的监视工具轻松地诊断和服务生产中的服务间调用。\n信息安全（Secrets）| Dapr 提供信息安全管理并且集成到公共云和本地，以供应用程序代码检索使用。\n\n### 边车架构\n\n---\n\nDapr 通过边车架构以暴露它的 APIs （要么通过程序要么通过一个进程），不需要应用程序代码嵌入任何 Dapr 运行时代码。这使得其它运行时集成 Dapr 变得简单，就像提供隔离的应用程序逻辑以改善可支持性。\n\n### 托管环境\n\n---\n\nDapr 可以在多个环境上托管，包括为本地开发环境自托管，或者部署到一组虚拟机、K8S和边缘（如Azure IoT edge）。\n\n#### 自托管\n\n自托管模式下，Dapr 作为一个隔离的边车进程运行，你的服务可以通过 HTTP 或者 gRPC 调用。自托管模式下，你也可以把 Dapr 部署到一组虚拟机下。\n\n![](/img/dapr/overview-sidecar.png)\n\n#### K8S 托管\n\n在容器托管环境比如 K8s，Dapr 以一个边车容器的方式和应用程序容器运行在同一个 pod 中。\n\n![](/img/dapr/overview-sidecar-kubernetes.png)\n\n### 开发语言 SDKs 和框架\n\n为了使 Dapr 在不同的语言中运用更加自然，Dapr 对 Go、Java、JavaScript、.NET 和 Python 提供特定的 SDK。Dapr 构建块中的功能通过这些 SDKs 暴露，比如：通过一个类型化的语言而不是调用 http/gRPC 接口以保存状态、发布一个事件或者创建一个 actor。这使你能够使用自己选择的语言编写无状态和有状态函数以及 actor 的组合。并且由于这些 SDKs 共享 Dapr 运行时，你可以获得跨语言的 actor 和函数支持。\n\n#### SDKs\n\n- C++ SDK\n- Go SDK\n- Java SDK\n- JavaScript SDK\n- Python SDK\n- .NET SDK\n\n> 注意： Dapr 是语言无关的提供 REST HTTTP API 除了 protobuf 客户端外。\n\n#### 开发框架\n\nDapr 可以用于任何开发框架。这里有一些已经集成到 Dapr 的。\n\n##### Web\n\n在 Dapr .NET SDK 中集成了 `ASP.NET Core`，`ASP.NET Core` 带来了状态路由控制器，该控制器响应来自其他服务的发布/订阅事件。\n\n在 Dapr Java SDK 你可以找到 Spring Boot 集成。\n\nDapr 很容易与 Python Flask 和 node Express 集成，您可以在入门示例中找到它们。\n\n##### Actors\n\nDapr SKDs 支持虚拟 actors ，虚拟 actors 是使并发简单的有状态对象，具有方法和状态封装，并且是为可扩展的分布式应用程序设计的。\n\n##### Azure Functions\n\nDapr 通过扩展与 Azure 函数运行时集成，扩展允许函数与 Dapr 无缝交互。Azual 函数提供一个事件驱动编程模式并且 Dapr 提供云原生构建块。通过这个扩展，你可以同时提供 serverless 和事件驱动应用。更多信息请阅读[用于 Dapr 的Azure 函数扩展](https://cloudblogs.microsoft.com/opensource/2020/07/01/announcing-azure-functions-extension-for-dapr/) 和访问[Azure 函数扩展](https://github.com/dapr/azure-functions-extension)以试用示例。\n\n##### Dapr 工作流\n\n为了使开发人员能够轻松构建使用 Dapr 功能（包括诊断和多语言支持）的工作流应用程序，可以使用Dapr工作流。Dapr 集成了工作流引擎比如 Logic Apps，更多信息阅读[使用 Dapr 和 Logic Apps 的云原生工作流](https://cloudblogs.microsoft.com/opensource/2020/05/26/announcing-cloud-native-workflows-dapr-logic-apps/)和访问[Dapr 工作流](https://github.com/dapr/workflows)试用示例。\n\n### 为运维而设计\n\n---\n\nDapr 是为运维而设计的。[Dapr 仪表板](https://github.com/dapr/dashboard)（通过 Dapr CLI 安装），提供一个以网页为基础的 UI 使你能看信息、看日志和 Dapr 边车更多的信息。\n\n监视仪表板提供了对 Dapr 系统服务和边车的更深层次的可见性，而 Dapr 的可观察性功能提供了对应用程序的深入了解，如跟踪和指标。\n\n### 运行与任何地方\n\n---\n\n#### 本地开发机器以自托管模式运行 Dapr\n\nDapr 可以配置为自托管模式以运行在你本地机器上。每一个运行的服务有一个 Dapr 运行时进程（或者边车），这个进程（或边车）通过配置以使用状态存储、发布/订阅、绑定组件和其它构建块。\n\n你可以使用 Dapr CLI 在你本地机器上运行 Dapr 启用应用程序。通过入门示例试用。\n\n![](/img/dapr/overview_standalone.png)\n\n#### 以 K8S 模式运行 Dapr\n\nDapr 可以配置以运行在任何 K8S 集群上。在 K8S 上 `dapr-sidecar-injector` 和 `dapr-operator` 服务提供了一流的集成，以将 Dapr 作为 sidecar 容器启动与服务容器在同一 pod 中，并提供了已配置到集群中的 Dapr 组件更新的通知。\n\n`dapr-sentry` 服务是一个证书颁发机构，可启用 Dapr 边车实例之间的相互 TLS 进行安全数据加密。有关Sentry服务的更多信息，请阅读[安全概述](https://github.com/dapr/docs/blob/master/concepts/security/README.md#dapr-to-dapr-communication)。\n\n![](/img/dapr/overview_kubernetes.png)\n\n在 Kubernetes 集群中部署并运行启用了 Dapr 的应用程序非常简单，只需在部署方案中添加一些注释即可。您可以在Kubernetes入门示例中看到一些示例。使用 Kubernetes [入门示例](https://github.com/dapr/quickstarts/tree/master/hello-kubernetes)进行尝试。\n\n---\n\n## 参考\n\n- [1] [Implement resilient applications](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/)\n\n    > Resiliency is the ability to recover from failures and continue to function. It isn't about avoiding failures but accepting the fact that failures will happen and responding to them in a way that avoids downtime or data loss. The goal of resiliency is to return the application to a fully functioning state after a failure.\n    > 翻译：Resiliency 是一种从故障中恢复并且继续工作的能力。并不是避开故障而是接受可能会故障的事实并且以某种方式回应它们以避免停机或者数据丢失。Resiliency 的目标是在发生故障后将应用程序返回到完全正常的状态。\n","source":"_posts/doc-overview.md","raw":"---\ntitle: Dapr 概述\ncatalog: true\ntoc_nav_num: true\ndate: 2020-09-11 13:47:55\nsubtitle: docs/overview\nheader-img: /img/dapr/dapr.svg\ntags: \n- Dapr\n- 原文翻译\ncatagories:\n- Dapr\n---\n\n## Dapr 概述\n\n---\n\n[Dapr overview](https://github.com/dapr/docs/tree/master/overview)\n\nDapr 是一个可移植的（portable）、事件驱动（event-driven）的运行时框架。企业开发者使用 Dapr 可以轻松构建弹性、无状态和有状态运行在云上和边缘的微服务。并且拥抱开发语言和开发框架的多样性。\n\n### 任何开发语言、任何开发框架、运行在任何地方\n\n---\n\n![](/img/dapr/overview.png)\n\n我们正处于云应用浪潮中。开发者使用 Web + Database 架构（例如经典3层设计）会比较轻松，但当面对天生具备分布式属性的微服务应用架构来说可能就比较吃力了。要成为一个分布式系统专家是有难度的事情，你也没必要成为一个分布式系统专家。开发者应该专注于业务逻辑，同时依赖各种云平台以使应用程序拥有可伸缩性（scale）、容错性（resiliency）、可维护性（maintainability）、弹性（elasticity） 以及云原生架构的其它属性。\n\n这就是 Dapr 切入点。Dapr 将构建微服务的最佳实践整理为开放、独立的构建块。因此，你可以选择开发语言和框架构建可移植的应用程序。每个构建块都是独立的，你可以在你的应用程序中使用它们中的一个、几个或者所有。\n\n### 云和边缘微服务构建块\n\n---\n\n![](/img/dapr/building_blocks.png)\n\n当架构微服务应用程序时有很多东西需要考虑。而当构建微服务应用程序时 Dapr 提供常用功能的最佳实践。开发者可以按标准在微服务中使用 Dapr 提供的常用功能并且部署到任何环境。Dapr 通过提供分布式系统构建块以支撑这种能力。\n\n这些构建块中每一个块都是独立的，意味着你可以在你的应用程序中使用一个、几个或者全部构建块。在 Dapr 的首次发布中，提供以下构建块：\n\n构建块|描述\n--|--\n{% post_link service-invocation 服务调用（Service Invocation） %}| 容错 service-to-service invocation 使方法调用（包括重试调用）远程服务，无论这些服务位于任何被支持的托管环境。\n状态管理（State Management）| 通过状态管理存储键/值对，可以同时在你的应用程序中实现长时间运行、高可用、有状态服务和无状态服务。状态存储是可插拔的并且可以使用 Azure CosmosDB， Azure SQL Server， PostgreSQL， AWS DynamoDB 或者 Redis。\n发布和订阅消息（Publish and Subscribe Messaging）| 发布事件和订阅主题。\n资源绑定（Resource Bindings）| 带有触发器的资源绑定进一步构建在事件驱动的架构之上，通过从任何外部源(如数据库、队列、文件系统等)接收和发送事件来实现伸缩性和容错性。\nActor 模式（Actors）| 有状态和无状态对象的模式，通过方法和状态封装使并发变得简单。Dapr 在它的 actor 运行时中提供很多能力，包括并发、状态、actor 激活/停用生命周期管理、定时器和唤醒 actor 的提醒。\n可观察性（Observability）| Dapr 发出指标、日志和根据以调试和监控 Dapr 和用户应用程序。Dapr支持分布式跟踪，以使用 W3C 跟踪上下文标准和 Open Telemetry 发送到不同的监视工具轻松地诊断和服务生产中的服务间调用。\n信息安全（Secrets）| Dapr 提供信息安全管理并且集成到公共云和本地，以供应用程序代码检索使用。\n\n### 边车架构\n\n---\n\nDapr 通过边车架构以暴露它的 APIs （要么通过程序要么通过一个进程），不需要应用程序代码嵌入任何 Dapr 运行时代码。这使得其它运行时集成 Dapr 变得简单，就像提供隔离的应用程序逻辑以改善可支持性。\n\n### 托管环境\n\n---\n\nDapr 可以在多个环境上托管，包括为本地开发环境自托管，或者部署到一组虚拟机、K8S和边缘（如Azure IoT edge）。\n\n#### 自托管\n\n自托管模式下，Dapr 作为一个隔离的边车进程运行，你的服务可以通过 HTTP 或者 gRPC 调用。自托管模式下，你也可以把 Dapr 部署到一组虚拟机下。\n\n![](/img/dapr/overview-sidecar.png)\n\n#### K8S 托管\n\n在容器托管环境比如 K8s，Dapr 以一个边车容器的方式和应用程序容器运行在同一个 pod 中。\n\n![](/img/dapr/overview-sidecar-kubernetes.png)\n\n### 开发语言 SDKs 和框架\n\n为了使 Dapr 在不同的语言中运用更加自然，Dapr 对 Go、Java、JavaScript、.NET 和 Python 提供特定的 SDK。Dapr 构建块中的功能通过这些 SDKs 暴露，比如：通过一个类型化的语言而不是调用 http/gRPC 接口以保存状态、发布一个事件或者创建一个 actor。这使你能够使用自己选择的语言编写无状态和有状态函数以及 actor 的组合。并且由于这些 SDKs 共享 Dapr 运行时，你可以获得跨语言的 actor 和函数支持。\n\n#### SDKs\n\n- C++ SDK\n- Go SDK\n- Java SDK\n- JavaScript SDK\n- Python SDK\n- .NET SDK\n\n> 注意： Dapr 是语言无关的提供 REST HTTTP API 除了 protobuf 客户端外。\n\n#### 开发框架\n\nDapr 可以用于任何开发框架。这里有一些已经集成到 Dapr 的。\n\n##### Web\n\n在 Dapr .NET SDK 中集成了 `ASP.NET Core`，`ASP.NET Core` 带来了状态路由控制器，该控制器响应来自其他服务的发布/订阅事件。\n\n在 Dapr Java SDK 你可以找到 Spring Boot 集成。\n\nDapr 很容易与 Python Flask 和 node Express 集成，您可以在入门示例中找到它们。\n\n##### Actors\n\nDapr SKDs 支持虚拟 actors ，虚拟 actors 是使并发简单的有状态对象，具有方法和状态封装，并且是为可扩展的分布式应用程序设计的。\n\n##### Azure Functions\n\nDapr 通过扩展与 Azure 函数运行时集成，扩展允许函数与 Dapr 无缝交互。Azual 函数提供一个事件驱动编程模式并且 Dapr 提供云原生构建块。通过这个扩展，你可以同时提供 serverless 和事件驱动应用。更多信息请阅读[用于 Dapr 的Azure 函数扩展](https://cloudblogs.microsoft.com/opensource/2020/07/01/announcing-azure-functions-extension-for-dapr/) 和访问[Azure 函数扩展](https://github.com/dapr/azure-functions-extension)以试用示例。\n\n##### Dapr 工作流\n\n为了使开发人员能够轻松构建使用 Dapr 功能（包括诊断和多语言支持）的工作流应用程序，可以使用Dapr工作流。Dapr 集成了工作流引擎比如 Logic Apps，更多信息阅读[使用 Dapr 和 Logic Apps 的云原生工作流](https://cloudblogs.microsoft.com/opensource/2020/05/26/announcing-cloud-native-workflows-dapr-logic-apps/)和访问[Dapr 工作流](https://github.com/dapr/workflows)试用示例。\n\n### 为运维而设计\n\n---\n\nDapr 是为运维而设计的。[Dapr 仪表板](https://github.com/dapr/dashboard)（通过 Dapr CLI 安装），提供一个以网页为基础的 UI 使你能看信息、看日志和 Dapr 边车更多的信息。\n\n监视仪表板提供了对 Dapr 系统服务和边车的更深层次的可见性，而 Dapr 的可观察性功能提供了对应用程序的深入了解，如跟踪和指标。\n\n### 运行与任何地方\n\n---\n\n#### 本地开发机器以自托管模式运行 Dapr\n\nDapr 可以配置为自托管模式以运行在你本地机器上。每一个运行的服务有一个 Dapr 运行时进程（或者边车），这个进程（或边车）通过配置以使用状态存储、发布/订阅、绑定组件和其它构建块。\n\n你可以使用 Dapr CLI 在你本地机器上运行 Dapr 启用应用程序。通过入门示例试用。\n\n![](/img/dapr/overview_standalone.png)\n\n#### 以 K8S 模式运行 Dapr\n\nDapr 可以配置以运行在任何 K8S 集群上。在 K8S 上 `dapr-sidecar-injector` 和 `dapr-operator` 服务提供了一流的集成，以将 Dapr 作为 sidecar 容器启动与服务容器在同一 pod 中，并提供了已配置到集群中的 Dapr 组件更新的通知。\n\n`dapr-sentry` 服务是一个证书颁发机构，可启用 Dapr 边车实例之间的相互 TLS 进行安全数据加密。有关Sentry服务的更多信息，请阅读[安全概述](https://github.com/dapr/docs/blob/master/concepts/security/README.md#dapr-to-dapr-communication)。\n\n![](/img/dapr/overview_kubernetes.png)\n\n在 Kubernetes 集群中部署并运行启用了 Dapr 的应用程序非常简单，只需在部署方案中添加一些注释即可。您可以在Kubernetes入门示例中看到一些示例。使用 Kubernetes [入门示例](https://github.com/dapr/quickstarts/tree/master/hello-kubernetes)进行尝试。\n\n---\n\n## 参考\n\n- [1] [Implement resilient applications](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/)\n\n    > Resiliency is the ability to recover from failures and continue to function. It isn't about avoiding failures but accepting the fact that failures will happen and responding to them in a way that avoids downtime or data loss. The goal of resiliency is to return the application to a fully functioning state after a failure.\n    > 翻译：Resiliency 是一种从故障中恢复并且继续工作的能力。并不是避开故障而是接受可能会故障的事实并且以某种方式回应它们以避免停机或者数据丢失。Resiliency 的目标是在发生故障后将应用程序返回到完全正常的状态。\n","slug":"doc-overview","published":1,"updated":"2020-09-16T02:58:13.890Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckf6kqn550004du989jpxuydz","content":"<h2 id=\"dapr-概述\">Dapr 概述</h2>\n<hr>\n<p><a href=\"https://github.com/dapr/docs/tree/master/overview\" target=\"_blank\" rel=\"noopener\">Dapr overview</a></p>\n<p>Dapr 是一个可移植的（portable）、事件驱动（event-driven）的运行时框架。企业开发者使用 Dapr 可以轻松构建弹性、无状态和有状态运行在云上和边缘的微服务。并且拥抱开发语言和开发框架的多样性。</p>\n<h3 id=\"任何开发语言-任何开发框架-运行在任何地方\">任何开发语言、任何开发框架、运行在任何地方</h3>\n<hr>\n<p><img src=\"/img/dapr/overview.png\" alt=\"\"></p>\n<p>我们正处于云应用浪潮中。开发者使用 Web + Database 架构（例如经典3层设计）会比较轻松，但当面对天生具备分布式属性的微服务应用架构来说可能就比较吃力了。要成为一个分布式系统专家是有难度的事情，你也没必要成为一个分布式系统专家。开发者应该专注于业务逻辑，同时依赖各种云平台以使应用程序拥有可伸缩性（scale）、容错性（resiliency）、可维护性（maintainability）、弹性（elasticity） 以及云原生架构的其它属性。</p>\n<p>这就是 Dapr 切入点。Dapr 将构建微服务的最佳实践整理为开放、独立的构建块。因此，你可以选择开发语言和框架构建可移植的应用程序。每个构建块都是独立的，你可以在你的应用程序中使用它们中的一个、几个或者所有。</p>\n<h3 id=\"云和边缘微服务构建块\">云和边缘微服务构建块</h3>\n<hr>\n<p><img src=\"/img/dapr/building_blocks.png\" alt=\"\"></p>\n<p>当架构微服务应用程序时有很多东西需要考虑。而当构建微服务应用程序时 Dapr 提供常用功能的最佳实践。开发者可以按标准在微服务中使用 Dapr 提供的常用功能并且部署到任何环境。Dapr 通过提供分布式系统构建块以支撑这种能力。</p>\n<p>这些构建块中每一个块都是独立的，意味着你可以在你的应用程序中使用一个、几个或者全部构建块。在 Dapr 的首次发布中，提供以下构建块：</p>\n<table>\n<thead>\n<tr>\n<th>构建块</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"/article/service-invocation/\" title=\"服务调用（Service Invocation）\">服务调用（Service Invocation）</a></td>\n<td>容错 service-to-service invocation 使方法调用（包括重试调用）远程服务，无论这些服务位于任何被支持的托管环境。</td>\n</tr>\n<tr>\n<td>状态管理（State Management）</td>\n<td>通过状态管理存储键/值对，可以同时在你的应用程序中实现长时间运行、高可用、有状态服务和无状态服务。状态存储是可插拔的并且可以使用 Azure CosmosDB， Azure SQL Server， PostgreSQL， AWS DynamoDB 或者 Redis。</td>\n</tr>\n<tr>\n<td>发布和订阅消息（Publish and Subscribe Messaging）</td>\n<td>发布事件和订阅主题。</td>\n</tr>\n<tr>\n<td>资源绑定（Resource Bindings）</td>\n<td>带有触发器的资源绑定进一步构建在事件驱动的架构之上，通过从任何外部源(如数据库、队列、文件系统等)接收和发送事件来实现伸缩性和容错性。</td>\n</tr>\n<tr>\n<td>Actor 模式（Actors）</td>\n<td>有状态和无状态对象的模式，通过方法和状态封装使并发变得简单。Dapr 在它的 actor 运行时中提供很多能力，包括并发、状态、actor 激活/停用生命周期管理、定时器和唤醒 actor 的提醒。</td>\n</tr>\n<tr>\n<td>可观察性（Observability）</td>\n<td>Dapr 发出指标、日志和根据以调试和监控 Dapr 和用户应用程序。Dapr支持分布式跟踪，以使用 W3C 跟踪上下文标准和 Open Telemetry 发送到不同的监视工具轻松地诊断和服务生产中的服务间调用。</td>\n</tr>\n<tr>\n<td>信息安全（Secrets）</td>\n<td>Dapr 提供信息安全管理并且集成到公共云和本地，以供应用程序代码检索使用。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"边车架构\">边车架构</h3>\n<hr>\n<p>Dapr 通过边车架构以暴露它的 APIs （要么通过程序要么通过一个进程），不需要应用程序代码嵌入任何 Dapr 运行时代码。这使得其它运行时集成 Dapr 变得简单，就像提供隔离的应用程序逻辑以改善可支持性。</p>\n<h3 id=\"托管环境\">托管环境</h3>\n<hr>\n<p>Dapr 可以在多个环境上托管，包括为本地开发环境自托管，或者部署到一组虚拟机、K8S和边缘（如Azure IoT edge）。</p>\n<h4 id=\"自托管\">自托管</h4>\n<p>自托管模式下，Dapr 作为一个隔离的边车进程运行，你的服务可以通过 HTTP 或者 gRPC 调用。自托管模式下，你也可以把 Dapr 部署到一组虚拟机下。</p>\n<p><img src=\"/img/dapr/overview-sidecar.png\" alt=\"\"></p>\n<h4 id=\"k8s-托管\">K8S 托管</h4>\n<p>在容器托管环境比如 K8s，Dapr 以一个边车容器的方式和应用程序容器运行在同一个 pod 中。</p>\n<p><img src=\"/img/dapr/overview-sidecar-kubernetes.png\" alt=\"\"></p>\n<h3 id=\"开发语言-sdks-和框架\">开发语言 SDKs 和框架</h3>\n<p>为了使 Dapr 在不同的语言中运用更加自然，Dapr 对 Go、Java、JavaScript、.NET 和 Python 提供特定的 SDK。Dapr 构建块中的功能通过这些 SDKs 暴露，比如：通过一个类型化的语言而不是调用 http/gRPC 接口以保存状态、发布一个事件或者创建一个 actor。这使你能够使用自己选择的语言编写无状态和有状态函数以及 actor 的组合。并且由于这些 SDKs 共享 Dapr 运行时，你可以获得跨语言的 actor 和函数支持。</p>\n<h4 id=\"sdks\">SDKs</h4>\n<ul>\n<li>C++ SDK</li>\n<li>Go SDK</li>\n<li>Java SDK</li>\n<li>JavaScript SDK</li>\n<li>Python SDK</li>\n<li>.NET SDK</li>\n</ul>\n<blockquote>\n<p>注意： Dapr 是语言无关的提供 REST HTTTP API 除了 protobuf 客户端外。</p>\n</blockquote>\n<h4 id=\"开发框架\">开发框架</h4>\n<p>Dapr 可以用于任何开发框架。这里有一些已经集成到 Dapr 的。</p>\n<h5 id=\"web\">Web</h5>\n<p>在 Dapr .NET SDK 中集成了 <code>ASP.NET Core</code>，<code>ASP.NET Core</code> 带来了状态路由控制器，该控制器响应来自其他服务的发布/订阅事件。</p>\n<p>在 Dapr Java SDK 你可以找到 Spring Boot 集成。</p>\n<p>Dapr 很容易与 Python Flask 和 node Express 集成，您可以在入门示例中找到它们。</p>\n<h5 id=\"actors\">Actors</h5>\n<p>Dapr SKDs 支持虚拟 actors ，虚拟 actors 是使并发简单的有状态对象，具有方法和状态封装，并且是为可扩展的分布式应用程序设计的。</p>\n<h5 id=\"azure-functions\">Azure Functions</h5>\n<p>Dapr 通过扩展与 Azure 函数运行时集成，扩展允许函数与 Dapr 无缝交互。Azual 函数提供一个事件驱动编程模式并且 Dapr 提供云原生构建块。通过这个扩展，你可以同时提供 serverless 和事件驱动应用。更多信息请阅读<a href=\"https://cloudblogs.microsoft.com/opensource/2020/07/01/announcing-azure-functions-extension-for-dapr/\" target=\"_blank\" rel=\"noopener\">用于 Dapr 的Azure 函数扩展</a> 和访问<a href=\"https://github.com/dapr/azure-functions-extension\" target=\"_blank\" rel=\"noopener\">Azure 函数扩展</a>以试用示例。</p>\n<h5 id=\"dapr-工作流\">Dapr 工作流</h5>\n<p>为了使开发人员能够轻松构建使用 Dapr 功能（包括诊断和多语言支持）的工作流应用程序，可以使用Dapr工作流。Dapr 集成了工作流引擎比如 Logic Apps，更多信息阅读<a href=\"https://cloudblogs.microsoft.com/opensource/2020/05/26/announcing-cloud-native-workflows-dapr-logic-apps/\" target=\"_blank\" rel=\"noopener\">使用 Dapr 和 Logic Apps 的云原生工作流</a>和访问<a href=\"https://github.com/dapr/workflows\" target=\"_blank\" rel=\"noopener\">Dapr 工作流</a>试用示例。</p>\n<h3 id=\"为运维而设计\">为运维而设计</h3>\n<hr>\n<p>Dapr 是为运维而设计的。<a href=\"https://github.com/dapr/dashboard\" target=\"_blank\" rel=\"noopener\">Dapr 仪表板</a>（通过 Dapr CLI 安装），提供一个以网页为基础的 UI 使你能看信息、看日志和 Dapr 边车更多的信息。</p>\n<p>监视仪表板提供了对 Dapr 系统服务和边车的更深层次的可见性，而 Dapr 的可观察性功能提供了对应用程序的深入了解，如跟踪和指标。</p>\n<h3 id=\"运行与任何地方\">运行与任何地方</h3>\n<hr>\n<h4 id=\"本地开发机器以自托管模式运行-dapr\">本地开发机器以自托管模式运行 Dapr</h4>\n<p>Dapr 可以配置为自托管模式以运行在你本地机器上。每一个运行的服务有一个 Dapr 运行时进程（或者边车），这个进程（或边车）通过配置以使用状态存储、发布/订阅、绑定组件和其它构建块。</p>\n<p>你可以使用 Dapr CLI 在你本地机器上运行 Dapr 启用应用程序。通过入门示例试用。</p>\n<p><img src=\"/img/dapr/overview_standalone.png\" alt=\"\"></p>\n<h4 id=\"以-k8s-模式运行-dapr\">以 K8S 模式运行 Dapr</h4>\n<p>Dapr 可以配置以运行在任何 K8S 集群上。在 K8S 上 <code>dapr-sidecar-injector</code> 和 <code>dapr-operator</code> 服务提供了一流的集成，以将 Dapr 作为 sidecar 容器启动与服务容器在同一 pod 中，并提供了已配置到集群中的 Dapr 组件更新的通知。</p>\n<p><code>dapr-sentry</code> 服务是一个证书颁发机构，可启用 Dapr 边车实例之间的相互 TLS 进行安全数据加密。有关Sentry服务的更多信息，请阅读<a href=\"https://github.com/dapr/docs/blob/master/concepts/security/README.md#dapr-to-dapr-communication\" target=\"_blank\" rel=\"noopener\">安全概述</a>。</p>\n<p><img src=\"/img/dapr/overview_kubernetes.png\" alt=\"\"></p>\n<p>在 Kubernetes 集群中部署并运行启用了 Dapr 的应用程序非常简单，只需在部署方案中添加一些注释即可。您可以在Kubernetes入门示例中看到一些示例。使用 Kubernetes <a href=\"https://github.com/dapr/quickstarts/tree/master/hello-kubernetes\" target=\"_blank\" rel=\"noopener\">入门示例</a>进行尝试。</p>\n<hr>\n<h2 id=\"参考\">参考</h2>\n<ul>\n<li>\n<p>[1] <a href=\"https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/\" target=\"_blank\" rel=\"noopener\">Implement resilient applications</a></p>\n<blockquote>\n<p>Resiliency is the ability to recover from failures and continue to function. It isn’t about avoiding failures but accepting the fact that failures will happen and responding to them in a way that avoids downtime or data loss. The goal of resiliency is to return the application to a fully functioning state after a failure.<br>\n翻译：Resiliency 是一种从故障中恢复并且继续工作的能力。并不是避开故障而是接受可能会故障的事实并且以某种方式回应它们以避免停机或者数据丢失。Resiliency 的目标是在发生故障后将应用程序返回到完全正常的状态。</p>\n</blockquote>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2>Dapr 概述</h2>\n<hr>\n<p><a href=\"https://github.com/dapr/docs/tree/master/overview\" target=\"_blank\" rel=\"noopener\">Dapr overview</a></p>\n<p>Dapr 是一个可移植的（portable）、事件驱动（event-driven）的运行时框架。企业开发者使用 Dapr 可以轻松构建弹性、无状态和有状态运行在云上和边缘的微服务。并且拥抱开发语言和开发框架的多样性。</p>\n<h3>任何开发语言、任何开发框架、运行在任何地方</h3>\n<hr>\n<p><img src=\"/img/dapr/overview.png\" alt=\"\"></p>\n<p>我们正处于云应用浪潮中。开发者使用 Web + Database 架构（例如经典3层设计）会比较轻松，但当面对天生具备分布式属性的微服务应用架构来说可能就比较吃力了。要成为一个分布式系统专家是有难度的事情，你也没必要成为一个分布式系统专家。开发者应该专注于业务逻辑，同时依赖各种云平台以使应用程序拥有可伸缩性（scale）、容错性（resiliency）、可维护性（maintainability）、弹性（elasticity） 以及云原生架构的其它属性。</p>\n<p>这就是 Dapr 切入点。Dapr 将构建微服务的最佳实践整理为开放、独立的构建块。因此，你可以选择开发语言和框架构建可移植的应用程序。每个构建块都是独立的，你可以在你的应用程序中使用它们中的一个、几个或者所有。</p>\n<h3>云和边缘微服务构建块</h3>\n<hr>\n<p><img src=\"/img/dapr/building_blocks.png\" alt=\"\"></p>\n<p>当架构微服务应用程序时有很多东西需要考虑。而当构建微服务应用程序时 Dapr 提供常用功能的最佳实践。开发者可以按标准在微服务中使用 Dapr 提供的常用功能并且部署到任何环境。Dapr 通过提供分布式系统构建块以支撑这种能力。</p>\n<p>这些构建块中每一个块都是独立的，意味着你可以在你的应用程序中使用一个、几个或者全部构建块。在 Dapr 的首次发布中，提供以下构建块：</p>\n<table>\n<thead>\n<tr>\n<th>构建块</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"/article/service-invocation/\" title=\"服务调用（Service Invocation）\">服务调用（Service Invocation）</a></td>\n<td>容错 service-to-service invocation 使方法调用（包括重试调用）远程服务，无论这些服务位于任何被支持的托管环境。</td>\n</tr>\n<tr>\n<td>状态管理（State Management）</td>\n<td>通过状态管理存储键/值对，可以同时在你的应用程序中实现长时间运行、高可用、有状态服务和无状态服务。状态存储是可插拔的并且可以使用 Azure CosmosDB， Azure SQL Server， PostgreSQL， AWS DynamoDB 或者 Redis。</td>\n</tr>\n<tr>\n<td>发布和订阅消息（Publish and Subscribe Messaging）</td>\n<td>发布事件和订阅主题。</td>\n</tr>\n<tr>\n<td>资源绑定（Resource Bindings）</td>\n<td>带有触发器的资源绑定进一步构建在事件驱动的架构之上，通过从任何外部源(如数据库、队列、文件系统等)接收和发送事件来实现伸缩性和容错性。</td>\n</tr>\n<tr>\n<td>Actor 模式（Actors）</td>\n<td>有状态和无状态对象的模式，通过方法和状态封装使并发变得简单。Dapr 在它的 actor 运行时中提供很多能力，包括并发、状态、actor 激活/停用生命周期管理、定时器和唤醒 actor 的提醒。</td>\n</tr>\n<tr>\n<td>可观察性（Observability）</td>\n<td>Dapr 发出指标、日志和根据以调试和监控 Dapr 和用户应用程序。Dapr支持分布式跟踪，以使用 W3C 跟踪上下文标准和 Open Telemetry 发送到不同的监视工具轻松地诊断和服务生产中的服务间调用。</td>\n</tr>\n<tr>\n<td>信息安全（Secrets）</td>\n<td>Dapr 提供信息安全管理并且集成到公共云和本地，以供应用程序代码检索使用。</td>\n</tr>\n</tbody>\n</table>\n<h3>边车架构</h3>\n<hr>\n<p>Dapr 通过边车架构以暴露它的 APIs （要么通过程序要么通过一个进程），不需要应用程序代码嵌入任何 Dapr 运行时代码。这使得其它运行时集成 Dapr 变得简单，就像提供隔离的应用程序逻辑以改善可支持性。</p>\n<h3>托管环境</h3>\n<hr>\n<p>Dapr 可以在多个环境上托管，包括为本地开发环境自托管，或者部署到一组虚拟机、K8S和边缘（如Azure IoT edge）。</p>\n<h4>自托管</h4>\n<p>自托管模式下，Dapr 作为一个隔离的边车进程运行，你的服务可以通过 HTTP 或者 gRPC 调用。自托管模式下，你也可以把 Dapr 部署到一组虚拟机下。</p>\n<p><img src=\"/img/dapr/overview-sidecar.png\" alt=\"\"></p>\n<h4>K8S 托管</h4>\n<p>在容器托管环境比如 K8s，Dapr 以一个边车容器的方式和应用程序容器运行在同一个 pod 中。</p>\n<p><img src=\"/img/dapr/overview-sidecar-kubernetes.png\" alt=\"\"></p>\n<h3>开发语言 SDKs 和框架</h3>\n<p>为了使 Dapr 在不同的语言中运用更加自然，Dapr 对 Go、Java、JavaScript、.NET 和 Python 提供特定的 SDK。Dapr 构建块中的功能通过这些 SDKs 暴露，比如：通过一个类型化的语言而不是调用 http/gRPC 接口以保存状态、发布一个事件或者创建一个 actor。这使你能够使用自己选择的语言编写无状态和有状态函数以及 actor 的组合。并且由于这些 SDKs 共享 Dapr 运行时，你可以获得跨语言的 actor 和函数支持。</p>\n<h4>SDKs</h4>\n<ul>\n<li>C++ SDK</li>\n<li>Go SDK</li>\n<li>Java SDK</li>\n<li>JavaScript SDK</li>\n<li>Python SDK</li>\n<li>.NET SDK</li>\n</ul>\n<blockquote>\n<p>注意： Dapr 是语言无关的提供 REST HTTTP API 除了 protobuf 客户端外。</p>\n</blockquote>\n<h4>开发框架</h4>\n<p>Dapr 可以用于任何开发框架。这里有一些已经集成到 Dapr 的。</p>\n<h5>Web</h5>\n<p>在 Dapr .NET SDK 中集成了 <code>ASP.NET Core</code>，<code>ASP.NET Core</code> 带来了状态路由控制器，该控制器响应来自其他服务的发布/订阅事件。</p>\n<p>在 Dapr Java SDK 你可以找到 Spring Boot 集成。</p>\n<p>Dapr 很容易与 Python Flask 和 node Express 集成，您可以在入门示例中找到它们。</p>\n<h5>Actors</h5>\n<p>Dapr SKDs 支持虚拟 actors ，虚拟 actors 是使并发简单的有状态对象，具有方法和状态封装，并且是为可扩展的分布式应用程序设计的。</p>\n<h5>Azure Functions</h5>\n<p>Dapr 通过扩展与 Azure 函数运行时集成，扩展允许函数与 Dapr 无缝交互。Azual 函数提供一个事件驱动编程模式并且 Dapr 提供云原生构建块。通过这个扩展，你可以同时提供 serverless 和事件驱动应用。更多信息请阅读<a href=\"https://cloudblogs.microsoft.com/opensource/2020/07/01/announcing-azure-functions-extension-for-dapr/\" target=\"_blank\" rel=\"noopener\">用于 Dapr 的Azure 函数扩展</a> 和访问<a href=\"https://github.com/dapr/azure-functions-extension\" target=\"_blank\" rel=\"noopener\">Azure 函数扩展</a>以试用示例。</p>\n<h5>Dapr 工作流</h5>\n<p>为了使开发人员能够轻松构建使用 Dapr 功能（包括诊断和多语言支持）的工作流应用程序，可以使用Dapr工作流。Dapr 集成了工作流引擎比如 Logic Apps，更多信息阅读<a href=\"https://cloudblogs.microsoft.com/opensource/2020/05/26/announcing-cloud-native-workflows-dapr-logic-apps/\" target=\"_blank\" rel=\"noopener\">使用 Dapr 和 Logic Apps 的云原生工作流</a>和访问<a href=\"https://github.com/dapr/workflows\" target=\"_blank\" rel=\"noopener\">Dapr 工作流</a>试用示例。</p>\n<h3>为运维而设计</h3>\n<hr>\n<p>Dapr 是为运维而设计的。<a href=\"https://github.com/dapr/dashboard\" target=\"_blank\" rel=\"noopener\">Dapr 仪表板</a>（通过 Dapr CLI 安装），提供一个以网页为基础的 UI 使你能看信息、看日志和 Dapr 边车更多的信息。</p>\n<p>监视仪表板提供了对 Dapr 系统服务和边车的更深层次的可见性，而 Dapr 的可观察性功能提供了对应用程序的深入了解，如跟踪和指标。</p>\n<h3>运行与任何地方</h3>\n<hr>\n<h4>本地开发机器以自托管模式运行 Dapr</h4>\n<p>Dapr 可以配置为自托管模式以运行在你本地机器上。每一个运行的服务有一个 Dapr 运行时进程（或者边车），这个进程（或边车）通过配置以使用状态存储、发布/订阅、绑定组件和其它构建块。</p>\n<p>你可以使用 Dapr CLI 在你本地机器上运行 Dapr 启用应用程序。通过入门示例试用。</p>\n<p><img src=\"/img/dapr/overview_standalone.png\" alt=\"\"></p>\n<h4>以 K8S 模式运行 Dapr</h4>\n<p>Dapr 可以配置以运行在任何 K8S 集群上。在 K8S 上 <code>dapr-sidecar-injector</code> 和 <code>dapr-operator</code> 服务提供了一流的集成，以将 Dapr 作为 sidecar 容器启动与服务容器在同一 pod 中，并提供了已配置到集群中的 Dapr 组件更新的通知。</p>\n<p><code>dapr-sentry</code> 服务是一个证书颁发机构，可启用 Dapr 边车实例之间的相互 TLS 进行安全数据加密。有关Sentry服务的更多信息，请阅读<a href=\"https://github.com/dapr/docs/blob/master/concepts/security/README.md#dapr-to-dapr-communication\" target=\"_blank\" rel=\"noopener\">安全概述</a>。</p>\n<p><img src=\"/img/dapr/overview_kubernetes.png\" alt=\"\"></p>\n<p>在 Kubernetes 集群中部署并运行启用了 Dapr 的应用程序非常简单，只需在部署方案中添加一些注释即可。您可以在Kubernetes入门示例中看到一些示例。使用 Kubernetes <a href=\"https://github.com/dapr/quickstarts/tree/master/hello-kubernetes\" target=\"_blank\" rel=\"noopener\">入门示例</a>进行尝试。</p>\n<hr>\n<h2>参考</h2>\n<ul>\n<li>\n<p>[1] <a href=\"https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/\" target=\"_blank\" rel=\"noopener\">Implement resilient applications</a></p>\n<blockquote>\n<p>Resiliency is the ability to recover from failures and continue to function. It isn’t about avoiding failures but accepting the fact that failures will happen and responding to them in a way that avoids downtime or data loss. The goal of resiliency is to return the application to a fully functioning state after a failure.<br>\n翻译：Resiliency 是一种从故障中恢复并且继续工作的能力。并不是避开故障而是接受可能会故障的事实并且以某种方式回应它们以避免停机或者数据丢失。Resiliency 的目标是在发生故障后将应用程序返回到完全正常的状态。</p>\n</blockquote>\n</li>\n</ul>\n"},{"title":"入门","catalog":true,"toc_nav_num":true,"date":"2020-09-17T07:05:58.000Z","subtitle":"docs/getting-started","header-img":"/img/dapr/dapr.svg","catagories":["Dapr"],"_content":"\n## 入门\n\n---\n\napr（Distributed Application Runtime） 是一个可移植的（portable）、事件驱动（event-driven）的运行时框架。开发者通过 Dapr 可以构建弹性、无状态、有状态的运行在云上和边缘的微服务。并且拥抱开发语言和开发框架的多样性。\n\n### 核心概念\n\n---\n\n- **构建块**是一个实现分布式系统能力的组件集，比如：pub/sub，状态管理、资源绑定和分布式追踪。\n- **组建**是构建块 API 的封装实现。例如状态构建块实现可能包含 Redis、Azure Storage、Azure Cosmos DB 和 AWS DynamoDB。很多组件都是可插拔的，所以一个实现可以替换为另一个。\n\n查看 Dapr 概念 了解更多信息。\n\n### 设置开发环境\n\n---\n\nDapr 可以在本地或者 K8S 上运行。我们推荐从本地设置开始探索 Dapr 核心概念并且熟悉 Dapr CLI。跟随这些指令配置本地和 K8S Dapr。\n\n## 下一步\n\n---\n\n1. 安装完 Dapr 后，查看[Hello World 开素开始]以继续。\n2. 探索其它[快速开始]了解更多高级概念，比如：服务调用、发布/订阅、状态管理。\n3. 跟随[如何引导]了解 Dapr 如何解决指定问题，比如创建一个[限速应用]。\n","source":"_posts/getting-started.md","raw":"---\ntitle: 入门\ncatalog: true\ntoc_nav_num: true\ndate: 2020-09-17 15:05:58\nsubtitle: docs/getting-started\nheader-img: /img/dapr/dapr.svg\ntags: \n- Dapr\n- 原文翻译\ncatagories:\n- Dapr\n---\n\n## 入门\n\n---\n\napr（Distributed Application Runtime） 是一个可移植的（portable）、事件驱动（event-driven）的运行时框架。开发者通过 Dapr 可以构建弹性、无状态、有状态的运行在云上和边缘的微服务。并且拥抱开发语言和开发框架的多样性。\n\n### 核心概念\n\n---\n\n- **构建块**是一个实现分布式系统能力的组件集，比如：pub/sub，状态管理、资源绑定和分布式追踪。\n- **组建**是构建块 API 的封装实现。例如状态构建块实现可能包含 Redis、Azure Storage、Azure Cosmos DB 和 AWS DynamoDB。很多组件都是可插拔的，所以一个实现可以替换为另一个。\n\n查看 Dapr 概念 了解更多信息。\n\n### 设置开发环境\n\n---\n\nDapr 可以在本地或者 K8S 上运行。我们推荐从本地设置开始探索 Dapr 核心概念并且熟悉 Dapr CLI。跟随这些指令配置本地和 K8S Dapr。\n\n## 下一步\n\n---\n\n1. 安装完 Dapr 后，查看[Hello World 开素开始]以继续。\n2. 探索其它[快速开始]了解更多高级概念，比如：服务调用、发布/订阅、状态管理。\n3. 跟随[如何引导]了解 Dapr 如何解决指定问题，比如创建一个[限速应用]。\n","slug":"getting-started","published":1,"updated":"2020-09-17T08:07:11.176Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckf6kqn570005du98qpgz9css","content":"<h2 id=\"入门\">入门</h2>\n<hr>\n<p>apr（Distributed Application Runtime） 是一个可移植的（portable）、事件驱动（event-driven）的运行时框架。开发者通过 Dapr 可以构建弹性、无状态、有状态的运行在云上和边缘的微服务。并且拥抱开发语言和开发框架的多样性。</p>\n<h3 id=\"核心概念\">核心概念</h3>\n<hr>\n<ul>\n<li><strong>构建块</strong>是一个实现分布式系统能力的组件集，比如：pub/sub，状态管理、资源绑定和分布式追踪。</li>\n<li><strong>组建</strong>是构建块 API 的封装实现。例如状态构建块实现可能包含 Redis、Azure Storage、Azure Cosmos DB 和 AWS DynamoDB。很多组件都是可插拔的，所以一个实现可以替换为另一个。</li>\n</ul>\n<p>查看 Dapr 概念 了解更多信息。</p>\n<h3 id=\"设置开发环境\">设置开发环境</h3>\n<hr>\n<p>Dapr 可以在本地或者 K8S 上运行。我们推荐从本地设置开始探索 Dapr 核心概念并且熟悉 Dapr CLI。跟随这些指令配置本地和 K8S Dapr。</p>\n<h2 id=\"下一步\">下一步</h2>\n<hr>\n<ol>\n<li>安装完 Dapr 后，查看[Hello World 开素开始]以继续。</li>\n<li>探索其它[快速开始]了解更多高级概念，比如：服务调用、发布/订阅、状态管理。</li>\n<li>跟随[如何引导]了解 Dapr 如何解决指定问题，比如创建一个[限速应用]。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2>入门</h2>\n<hr>\n<p>apr（Distributed Application Runtime） 是一个可移植的（portable）、事件驱动（event-driven）的运行时框架。开发者通过 Dapr 可以构建弹性、无状态、有状态的运行在云上和边缘的微服务。并且拥抱开发语言和开发框架的多样性。</p>\n<h3>核心概念</h3>\n<hr>\n<ul>\n<li><strong>构建块</strong>是一个实现分布式系统能力的组件集，比如：pub/sub，状态管理、资源绑定和分布式追踪。</li>\n<li><strong>组建</strong>是构建块 API 的封装实现。例如状态构建块实现可能包含 Redis、Azure Storage、Azure Cosmos DB 和 AWS DynamoDB。很多组件都是可插拔的，所以一个实现可以替换为另一个。</li>\n</ul>\n<p>查看 Dapr 概念 了解更多信息。</p>\n<h3>设置开发环境</h3>\n<hr>\n<p>Dapr 可以在本地或者 K8S 上运行。我们推荐从本地设置开始探索 Dapr 核心概念并且熟悉 Dapr CLI。跟随这些指令配置本地和 K8S Dapr。</p>\n<h2>下一步</h2>\n<hr>\n<ol>\n<li>安装完 Dapr 后，查看[Hello World 开素开始]以继续。</li>\n<li>探索其它[快速开始]了解更多高级概念，比如：服务调用、发布/订阅、状态管理。</li>\n<li>跟随[如何引导]了解 Dapr 如何解决指定问题，比如创建一个[限速应用]。</li>\n</ol>\n"},{"title":"调用远程服务","catalog":true,"toc_nav_num":true,"date":"2020-09-15T12:57:09.000Z","subtitle":"docs/howto/invoke-and-discover-services/","header-img":"/img/dapr/dapr.svg","catagories":["Dapr"],"_content":"\n## 调用远程服务\n\n---\n\n在很多环境中，多个服务需要互相通讯，开发者常常会问自己以下问题：\n\n- 如何发现和调用不同的服务？\n- 如何处理重试和瞬态错误？\n- 如何正确使用分布式跟踪来查看调用图？\n\nDapr 通过提供一个端点，将反向代理与内置服务发现结合起来，同时利用内置分布式跟踪和错误处理，可以使开发人员克服这些挑战。\n\n更多关于服务调用的信息，阅读{% post_link service-invocation 概念文档 %}\n\n### 为你的服务选择 ID\n\nDapr 允许你为应用程序分配一个全局、唯一的 ID。\n\n这个 ID 封装你的应用程序状态，不管有多少个实例。\n\n#### 使用 Dapr 命令行界面设置 ID\n\n在标准模式下，设置 --app-id 标记：\n\n``` CMD\ndapr run --app-id cart --app-port 5000 python app.py\n```\n\n#### 使用 K8S 设置 ID\n\n在 K8S 中，在 pod 中设置 dapr.io/app-id ：\n\n``` yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: python-app\n  namespace: default\n  labels:\n    app: python-app\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: python-app\n  template:\n    metadata:\n      labels:\n        app: python-app\n      annotations:\n        dapr.io/enabled: \"true\"\n        dapr.io/app-id: \"cart\"\n        dapr.io/app-port: \"5000\"\n...\n\n```\n\n#### 在代码中调用服务\n\nDapr 使用边车、去中心化架构。使用 Dapr 调用应用程序，你可以在你的集群/环境使用 `invoke` 端点。\n\n边车编程模式鼓励每个应用程序和它自己的 Dapr 实例沟通。Dapr 实例相互发现并通讯。\n\n*注意：以下是一个 Python cart 应用程序实例。它可以使用任何编程语言实现*\n\n``` python\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.route('/add', methods=['POST'])\ndef add():\n    return \"Added!\"\n\nif __name__ == '__main__':\n    app.run()\n```\n\n这个 Python 应用程序通过 `/add` 终端暴露了一个 `add()` 方法。\n\n#### 使用 curl 调用\n\n``` curl\ncurl http://localhost:3500/v1.0/invoke/cart/method/add -X POST\n```\n\n由于 add 端点是一个 'POST' 方法，我们在 curl 命令中使用 `-X POST` 。\n\n调用 'GET' 端点：\n\n``` curl\ncurl http://localhost:3500/v1.0/invoke/cart/method/add\n```\n\n调用 'DELETE' 端点：\n\n``` curl\ncurl http://localhost:3500/v1.0/invoke/cart/method/add -X DELETE\n```\n\nDapr 在调用的服务 HTTP 应答消息体中放任何负载。\n\n#### 命名空间\n\n当运行在[支持命名空间的平台]上时，你应该把目标应用程序的命名空间包含在应用程序 ID 中：\n\n``` cmd\nmyApp.production\n```\n\n查看[跨命名空间 API 规范]了解更多关于命名空间的信息。\n\n## 概述\n\n---\n\n上面的示例为你展示了如何直接调用不同的服务（运行在本地或者 K8S），Dapr 输出指标和追踪信息允许你可视化服务间的调用图、错误日志和可选地记录有效负载主体。\n\n## 相关主题\n\n- {% post_link service-invocation 服务调用概念 %}\n- {% post_link service-invocation-api 服务调用-API-规范 %}\n","source":"_posts/invoke-and-discover-services.md","raw":"---\ntitle: 调用远程服务\ncatalog: true\ntoc_nav_num: true\ndate: 2020-09-15 20:57:09\nsubtitle: docs/howto/invoke-and-discover-services/\nheader-img: /img/dapr/dapr.svg\ntags:\n- Dapr\n- 原文翻译\ncatagories:\n- Dapr\n---\n\n## 调用远程服务\n\n---\n\n在很多环境中，多个服务需要互相通讯，开发者常常会问自己以下问题：\n\n- 如何发现和调用不同的服务？\n- 如何处理重试和瞬态错误？\n- 如何正确使用分布式跟踪来查看调用图？\n\nDapr 通过提供一个端点，将反向代理与内置服务发现结合起来，同时利用内置分布式跟踪和错误处理，可以使开发人员克服这些挑战。\n\n更多关于服务调用的信息，阅读{% post_link service-invocation 概念文档 %}\n\n### 为你的服务选择 ID\n\nDapr 允许你为应用程序分配一个全局、唯一的 ID。\n\n这个 ID 封装你的应用程序状态，不管有多少个实例。\n\n#### 使用 Dapr 命令行界面设置 ID\n\n在标准模式下，设置 --app-id 标记：\n\n``` CMD\ndapr run --app-id cart --app-port 5000 python app.py\n```\n\n#### 使用 K8S 设置 ID\n\n在 K8S 中，在 pod 中设置 dapr.io/app-id ：\n\n``` yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: python-app\n  namespace: default\n  labels:\n    app: python-app\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: python-app\n  template:\n    metadata:\n      labels:\n        app: python-app\n      annotations:\n        dapr.io/enabled: \"true\"\n        dapr.io/app-id: \"cart\"\n        dapr.io/app-port: \"5000\"\n...\n\n```\n\n#### 在代码中调用服务\n\nDapr 使用边车、去中心化架构。使用 Dapr 调用应用程序，你可以在你的集群/环境使用 `invoke` 端点。\n\n边车编程模式鼓励每个应用程序和它自己的 Dapr 实例沟通。Dapr 实例相互发现并通讯。\n\n*注意：以下是一个 Python cart 应用程序实例。它可以使用任何编程语言实现*\n\n``` python\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.route('/add', methods=['POST'])\ndef add():\n    return \"Added!\"\n\nif __name__ == '__main__':\n    app.run()\n```\n\n这个 Python 应用程序通过 `/add` 终端暴露了一个 `add()` 方法。\n\n#### 使用 curl 调用\n\n``` curl\ncurl http://localhost:3500/v1.0/invoke/cart/method/add -X POST\n```\n\n由于 add 端点是一个 'POST' 方法，我们在 curl 命令中使用 `-X POST` 。\n\n调用 'GET' 端点：\n\n``` curl\ncurl http://localhost:3500/v1.0/invoke/cart/method/add\n```\n\n调用 'DELETE' 端点：\n\n``` curl\ncurl http://localhost:3500/v1.0/invoke/cart/method/add -X DELETE\n```\n\nDapr 在调用的服务 HTTP 应答消息体中放任何负载。\n\n#### 命名空间\n\n当运行在[支持命名空间的平台]上时，你应该把目标应用程序的命名空间包含在应用程序 ID 中：\n\n``` cmd\nmyApp.production\n```\n\n查看[跨命名空间 API 规范]了解更多关于命名空间的信息。\n\n## 概述\n\n---\n\n上面的示例为你展示了如何直接调用不同的服务（运行在本地或者 K8S），Dapr 输出指标和追踪信息允许你可视化服务间的调用图、错误日志和可选地记录有效负载主体。\n\n## 相关主题\n\n- {% post_link service-invocation 服务调用概念 %}\n- {% post_link service-invocation-api 服务调用-API-规范 %}\n","slug":"invoke-and-discover-services","published":1,"updated":"2020-09-16T02:28:10.314Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckf6kqn580006du9869dn0pvy","content":"<h2 id=\"调用远程服务\">调用远程服务</h2>\n<hr>\n<p>在很多环境中，多个服务需要互相通讯，开发者常常会问自己以下问题：</p>\n<ul>\n<li>如何发现和调用不同的服务？</li>\n<li>如何处理重试和瞬态错误？</li>\n<li>如何正确使用分布式跟踪来查看调用图？</li>\n</ul>\n<p>Dapr 通过提供一个端点，将反向代理与内置服务发现结合起来，同时利用内置分布式跟踪和错误处理，可以使开发人员克服这些挑战。</p>\n<p>更多关于服务调用的信息，阅读<a href=\"/article/service-invocation/\" title=\"概念文档\">概念文档</a></p>\n<h3 id=\"为你的服务选择-id\">为你的服务选择 ID</h3>\n<p>Dapr 允许你为应用程序分配一个全局、唯一的 ID。</p>\n<p>这个 ID 封装你的应用程序状态，不管有多少个实例。</p>\n<h4 id=\"使用-dapr-命令行界面设置-id\">使用 Dapr 命令行界面设置 ID</h4>\n<p>在标准模式下，设置 --app-id 标记：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dapr run --app-id cart --app-port <span class=\"number\">5000</span> python app.py</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用-k8s-设置-id\">使用 K8S 设置 ID</h4>\n<p>在 K8S 中，在 pod 中设置 <a href=\"http://dapr.io/app-id\" target=\"_blank\" rel=\"noopener\">dapr.io/app-id</a> ：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">python-app</span></span><br><span class=\"line\"><span class=\"attr\">  namespace:</span> <span class=\"string\">default</span></span><br><span class=\"line\"><span class=\"attr\">  labels:</span></span><br><span class=\"line\"><span class=\"attr\">    app:</span> <span class=\"string\">python-app</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\"><span class=\"attr\">  replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">  selector:</span></span><br><span class=\"line\"><span class=\"attr\">    matchLabels:</span></span><br><span class=\"line\"><span class=\"attr\">      app:</span> <span class=\"string\">python-app</span></span><br><span class=\"line\"><span class=\"attr\">  template:</span></span><br><span class=\"line\"><span class=\"attr\">    metadata:</span></span><br><span class=\"line\"><span class=\"attr\">      labels:</span></span><br><span class=\"line\"><span class=\"attr\">        app:</span> <span class=\"string\">python-app</span></span><br><span class=\"line\"><span class=\"attr\">      annotations:</span></span><br><span class=\"line\">        <span class=\"string\">dapr.io/enabled:</span> <span class=\"string\">\"true\"</span></span><br><span class=\"line\">        <span class=\"string\">dapr.io/app-id:</span> <span class=\"string\">\"cart\"</span></span><br><span class=\"line\">        <span class=\"string\">dapr.io/app-port:</span> <span class=\"string\">\"5000\"</span></span><br><span class=\"line\"><span class=\"string\">...</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在代码中调用服务\">在代码中调用服务</h4>\n<p>Dapr 使用边车、去中心化架构。使用 Dapr 调用应用程序，你可以在你的集群/环境使用 <code>invoke</code> 端点。</p>\n<p>边车编程模式鼓励每个应用程序和它自己的 Dapr 实例沟通。Dapr 实例相互发现并通讯。</p>\n<p><em>注意：以下是一个 Python cart 应用程序实例。它可以使用任何编程语言实现</em></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route('/add', methods=['POST'])</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Added!\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    app.run()</span><br></pre></td></tr></table></figure>\n<p>这个 Python 应用程序通过 <code>/add</code> 终端暴露了一个 <code>add()</code> 方法。</p>\n<h4 id=\"使用-curl-调用\">使用 curl 调用</h4>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http://localhost:3500/v1.0/invoke/cart/method/add -X POST</span><br></pre></td></tr></table></figure>\n<p>由于 add 端点是一个 ‘POST’ 方法，我们在 curl 命令中使用 <code>-X POST</code> 。</p>\n<p>调用 ‘GET’ 端点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http://localhost:3500/v1.0/invoke/cart/method/add</span><br></pre></td></tr></table></figure>\n<p>调用 ‘DELETE’ 端点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http://localhost:3500/v1.0/invoke/cart/method/add -X DELETE</span><br></pre></td></tr></table></figure>\n<p>Dapr 在调用的服务 HTTP 应答消息体中放任何负载。</p>\n<h4 id=\"命名空间\">命名空间</h4>\n<p>当运行在[支持命名空间的平台]上时，你应该把目标应用程序的命名空间包含在应用程序 ID 中：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myApp.production</span><br></pre></td></tr></table></figure>\n<p>查看[跨命名空间 API 规范]了解更多关于命名空间的信息。</p>\n<h2 id=\"概述\">概述</h2>\n<hr>\n<p>上面的示例为你展示了如何直接调用不同的服务（运行在本地或者 K8S），Dapr 输出指标和追踪信息允许你可视化服务间的调用图、错误日志和可选地记录有效负载主体。</p>\n<h2 id=\"相关主题\">相关主题</h2>\n<ul>\n<li>\n<a href=\"/article/service-invocation/\" title=\"服务调用概念\">服务调用概念</a>\n</li>\n<li>\n<a href=\"/article/service-invocation-api/\" title=\"服务调用-API-规范\">服务调用-API-规范</a>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2>调用远程服务</h2>\n<hr>\n<p>在很多环境中，多个服务需要互相通讯，开发者常常会问自己以下问题：</p>\n<ul>\n<li>如何发现和调用不同的服务？</li>\n<li>如何处理重试和瞬态错误？</li>\n<li>如何正确使用分布式跟踪来查看调用图？</li>\n</ul>\n<p>Dapr 通过提供一个端点，将反向代理与内置服务发现结合起来，同时利用内置分布式跟踪和错误处理，可以使开发人员克服这些挑战。</p>\n<p>更多关于服务调用的信息，阅读<a href=\"/article/service-invocation/\" title=\"概念文档\">概念文档</a></p>\n<h3>为你的服务选择 ID</h3>\n<p>Dapr 允许你为应用程序分配一个全局、唯一的 ID。</p>\n<p>这个 ID 封装你的应用程序状态，不管有多少个实例。</p>\n<h4>使用 Dapr 命令行界面设置 ID</h4>\n<p>在标准模式下，设置 --app-id 标记：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dapr run --app-id cart --app-port <span class=\"number\">5000</span> python app.py</span><br></pre></td></tr></table></figure>\n<h4>使用 K8S 设置 ID</h4>\n<p>在 K8S 中，在 pod 中设置 <a href=\"http://dapr.io/app-id\" target=\"_blank\" rel=\"noopener\">dapr.io/app-id</a> ：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">python-app</span></span><br><span class=\"line\"><span class=\"attr\">  namespace:</span> <span class=\"string\">default</span></span><br><span class=\"line\"><span class=\"attr\">  labels:</span></span><br><span class=\"line\"><span class=\"attr\">    app:</span> <span class=\"string\">python-app</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\"><span class=\"attr\">  replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">  selector:</span></span><br><span class=\"line\"><span class=\"attr\">    matchLabels:</span></span><br><span class=\"line\"><span class=\"attr\">      app:</span> <span class=\"string\">python-app</span></span><br><span class=\"line\"><span class=\"attr\">  template:</span></span><br><span class=\"line\"><span class=\"attr\">    metadata:</span></span><br><span class=\"line\"><span class=\"attr\">      labels:</span></span><br><span class=\"line\"><span class=\"attr\">        app:</span> <span class=\"string\">python-app</span></span><br><span class=\"line\"><span class=\"attr\">      annotations:</span></span><br><span class=\"line\">        <span class=\"string\">dapr.io/enabled:</span> <span class=\"string\">\"true\"</span></span><br><span class=\"line\">        <span class=\"string\">dapr.io/app-id:</span> <span class=\"string\">\"cart\"</span></span><br><span class=\"line\">        <span class=\"string\">dapr.io/app-port:</span> <span class=\"string\">\"5000\"</span></span><br><span class=\"line\"><span class=\"string\">...</span></span><br></pre></td></tr></table></figure>\n<h4>在代码中调用服务</h4>\n<p>Dapr 使用边车、去中心化架构。使用 Dapr 调用应用程序，你可以在你的集群/环境使用 <code>invoke</code> 端点。</p>\n<p>边车编程模式鼓励每个应用程序和它自己的 Dapr 实例沟通。Dapr 实例相互发现并通讯。</p>\n<p><em>注意：以下是一个 Python cart 应用程序实例。它可以使用任何编程语言实现</em></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route('/add', methods=['POST'])</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Added!\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    app.run()</span><br></pre></td></tr></table></figure>\n<p>这个 Python 应用程序通过 <code>/add</code> 终端暴露了一个 <code>add()</code> 方法。</p>\n<h4>使用 curl 调用</h4>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http://localhost:3500/v1.0/invoke/cart/method/add -X POST</span><br></pre></td></tr></table></figure>\n<p>由于 add 端点是一个 ‘POST’ 方法，我们在 curl 命令中使用 <code>-X POST</code> 。</p>\n<p>调用 ‘GET’ 端点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http://localhost:3500/v1.0/invoke/cart/method/add</span><br></pre></td></tr></table></figure>\n<p>调用 ‘DELETE’ 端点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http://localhost:3500/v1.0/invoke/cart/method/add -X DELETE</span><br></pre></td></tr></table></figure>\n<p>Dapr 在调用的服务 HTTP 应答消息体中放任何负载。</p>\n<h4>命名空间</h4>\n<p>当运行在[支持命名空间的平台]上时，你应该把目标应用程序的命名空间包含在应用程序 ID 中：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myApp.production</span><br></pre></td></tr></table></figure>\n<p>查看[跨命名空间 API 规范]了解更多关于命名空间的信息。</p>\n<h2>概述</h2>\n<hr>\n<p>上面的示例为你展示了如何直接调用不同的服务（运行在本地或者 K8S），Dapr 输出指标和追踪信息允许你可视化服务间的调用图、错误日志和可选地记录有效负载主体。</p>\n<h2>相关主题</h2>\n<ul>\n<li>\n<a href=\"/article/service-invocation/\" title=\"服务调用概念\">服务调用概念</a>\n</li>\n<li>\n<a href=\"/article/service-invocation-api/\" title=\"服务调用-API-规范\">服务调用-API-规范</a>\n</li>\n</ul>\n"},{"title":"服务调用 API 规范","catalog":true,"toc_nav_num":true,"date":"2020-09-15T14:21:27.000Z","subtitle":"docs/reference/api/","header-img":"/img/dapr/dapr.svg","catagories":["Dapr"],"_content":"\n## 服务调用 API 规范\n\n---\n\nDapr 给用户提供使用唯一 ID 调用其它应用程序的能力。这个功能允许应用程序通过名称标识符和其它应用程序交互，把服务发现的重担交给 Dapr 运行时。\n\n### 内容\n\n- 在远程 Dapr 应用程序上调用一个方法\n\n### 在远程 Dapr 应用程序上调用一个方法\n\n---\n\n这个终端使你能够调用另一个 Dapr 应用程序启用的方法。\n\n#### HTTP 请求\n\n``` cmd\nPOST/GET/PUT/DELETE http://localhost:<daprPort>/v1.0/invoke/<appId>/method/<method-name>\n```\n\n#### HTTP 应答编码\n\n当一个服务通过 Dapr 调用另一个服务时，被调用的服务状态码会返回给调用方。如果有网络错误或者其它瞬态错误， Dapr 将会返回 `500` 错误并带着详细错误信息。\n\n如果用户通过HTTP调用Dapr来与启用了gRPC的服务对话，被调用的 gRPC 服务错误返回 `500` ，成功返回 `200OK`。\n\n代码|描述\n--|--\n500|请求失败\n\n#### URL 参数\n\n参数|描述\n--|--\ndaprPort｜Dapr 端口\nappId｜远程应用程序 ID\nmethod-name｜调用远程应用程序的方法名称或者 url\n\n#### 请求内容\n\n在请求中，你可以传递请求头：\n\n``` json\n{\n  \"Content-Type\": \"application/json\"\n}\n```\n\n在请求消息体中放置你想发送到服务的数据：\n\n``` json\n{\n  \"arg1\": 10,\n  \"arg2\": 23,\n  \"operator\": \"+\"\n}\n```\n\n#### 通过调用服务接收请求\n\n一旦你的服务代码通过 Dapr 调用另一个服务启用的方法，Dapr 将会发送请求（伴随着请求头和消息体）到应用的 `<method-name>` 终端。\n\n被调用的 Dapr 应用程序监听并且在那个终端应答请求。\n\n#### 跨命名空间调用\n\n在支持命名空间的托管平台，Dapr 应用程序 ID 遵循有效的 FQDN（Fully Qualified Domain Name，全限定域名）转换，包含目标命名空间。例如，以下字符串包含应用程序 ID（myApp），此外应用程序运行的命名空间（production）。\n\n``` cmd\nmyApp.production\n```\n\n支持命名空间平台\n\n- K8S\n\n#### 示例\n\n调用 `mathService` 中的 `add` 方法：\n\n``` curl\ncurl http://localhost:3500/v1.0/invoke/mathService/method/add \\\n  -H \"Content-Type: application/json\"\n  -d '{ \"arg1\": 10, \"arg2\": 23}'\n```\n\n`mathService` 服务需要监听 `/add` 终端以接收和处理请求。\n\nNode 应用程序像这样：\n\n``` nodejs\napp.post('/add', (req, res) => {\n  let args = req.body;\n  const [operandOne, operandTwo] = [Number(args['arg1']), Number(args['arg2'])];\n  \n  let result = operandOne + operandTwo;\n  res.send(result.toString());\n});\n\napp.listen(port, () => console.log(`Listening on port ${port}!`));\n```\n\n> 远程终端应答将在应答消息体中返回。\n\n如果你的服务监听路径嵌套较多（比如：`/api/v1/add`），Dapr 实现了完整的反向代理，所以你可以追加所有需要的路径分段到你的请求 URL 里，例如：\n\n``` url\nhttp://localhost:3500/v1.0/invoke/mathService/method/api/v1/add\n```\n\n如果你调用的 `mathService` 在不同的命名空间中，你可以使用下列 URL：\n\n``` url\nhttp://localhost:3500/v1.0/invoke/mathService.testing/method/api/v1/add\n```\n\n在这个 URL 中，`testing` 是 `mathService` 运行的命名空间。\n","source":"_posts/service-invocation-api.md","raw":"---\ntitle: 服务调用 API 规范\ncatalog: true\ntoc_nav_num: true\ndate: 2020-09-15 22:21:27\nsubtitle: docs/reference/api/\nheader-img: /img/dapr/dapr.svg\ntags:\n- Dapr\n- 原文翻译\ncatagories:\n- Dapr\n---\n\n## 服务调用 API 规范\n\n---\n\nDapr 给用户提供使用唯一 ID 调用其它应用程序的能力。这个功能允许应用程序通过名称标识符和其它应用程序交互，把服务发现的重担交给 Dapr 运行时。\n\n### 内容\n\n- 在远程 Dapr 应用程序上调用一个方法\n\n### 在远程 Dapr 应用程序上调用一个方法\n\n---\n\n这个终端使你能够调用另一个 Dapr 应用程序启用的方法。\n\n#### HTTP 请求\n\n``` cmd\nPOST/GET/PUT/DELETE http://localhost:<daprPort>/v1.0/invoke/<appId>/method/<method-name>\n```\n\n#### HTTP 应答编码\n\n当一个服务通过 Dapr 调用另一个服务时，被调用的服务状态码会返回给调用方。如果有网络错误或者其它瞬态错误， Dapr 将会返回 `500` 错误并带着详细错误信息。\n\n如果用户通过HTTP调用Dapr来与启用了gRPC的服务对话，被调用的 gRPC 服务错误返回 `500` ，成功返回 `200OK`。\n\n代码|描述\n--|--\n500|请求失败\n\n#### URL 参数\n\n参数|描述\n--|--\ndaprPort｜Dapr 端口\nappId｜远程应用程序 ID\nmethod-name｜调用远程应用程序的方法名称或者 url\n\n#### 请求内容\n\n在请求中，你可以传递请求头：\n\n``` json\n{\n  \"Content-Type\": \"application/json\"\n}\n```\n\n在请求消息体中放置你想发送到服务的数据：\n\n``` json\n{\n  \"arg1\": 10,\n  \"arg2\": 23,\n  \"operator\": \"+\"\n}\n```\n\n#### 通过调用服务接收请求\n\n一旦你的服务代码通过 Dapr 调用另一个服务启用的方法，Dapr 将会发送请求（伴随着请求头和消息体）到应用的 `<method-name>` 终端。\n\n被调用的 Dapr 应用程序监听并且在那个终端应答请求。\n\n#### 跨命名空间调用\n\n在支持命名空间的托管平台，Dapr 应用程序 ID 遵循有效的 FQDN（Fully Qualified Domain Name，全限定域名）转换，包含目标命名空间。例如，以下字符串包含应用程序 ID（myApp），此外应用程序运行的命名空间（production）。\n\n``` cmd\nmyApp.production\n```\n\n支持命名空间平台\n\n- K8S\n\n#### 示例\n\n调用 `mathService` 中的 `add` 方法：\n\n``` curl\ncurl http://localhost:3500/v1.0/invoke/mathService/method/add \\\n  -H \"Content-Type: application/json\"\n  -d '{ \"arg1\": 10, \"arg2\": 23}'\n```\n\n`mathService` 服务需要监听 `/add` 终端以接收和处理请求。\n\nNode 应用程序像这样：\n\n``` nodejs\napp.post('/add', (req, res) => {\n  let args = req.body;\n  const [operandOne, operandTwo] = [Number(args['arg1']), Number(args['arg2'])];\n  \n  let result = operandOne + operandTwo;\n  res.send(result.toString());\n});\n\napp.listen(port, () => console.log(`Listening on port ${port}!`));\n```\n\n> 远程终端应答将在应答消息体中返回。\n\n如果你的服务监听路径嵌套较多（比如：`/api/v1/add`），Dapr 实现了完整的反向代理，所以你可以追加所有需要的路径分段到你的请求 URL 里，例如：\n\n``` url\nhttp://localhost:3500/v1.0/invoke/mathService/method/api/v1/add\n```\n\n如果你调用的 `mathService` 在不同的命名空间中，你可以使用下列 URL：\n\n``` url\nhttp://localhost:3500/v1.0/invoke/mathService.testing/method/api/v1/add\n```\n\n在这个 URL 中，`testing` 是 `mathService` 运行的命名空间。\n","slug":"service-invocation-api","published":1,"updated":"2020-09-16T02:26:43.050Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckf6kqn5a0008du98dxk1bhyx","content":"<h2 id=\"服务调用-api-规范\">服务调用 API 规范</h2>\n<hr>\n<p>Dapr 给用户提供使用唯一 ID 调用其它应用程序的能力。这个功能允许应用程序通过名称标识符和其它应用程序交互，把服务发现的重担交给 Dapr 运行时。</p>\n<h3 id=\"内容\">内容</h3>\n<ul>\n<li>在远程 Dapr 应用程序上调用一个方法</li>\n</ul>\n<h3 id=\"在远程-dapr-应用程序上调用一个方法\">在远程 Dapr 应用程序上调用一个方法</h3>\n<hr>\n<p>这个终端使你能够调用另一个 Dapr 应用程序启用的方法。</p>\n<h4 id=\"http-请求\">HTTP 请求</h4>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST/GET/PUT/DELETE http://localhost:&lt;daprPort&gt;/v1.<span class=\"number\">0</span>/invoke/&lt;appId&gt;/method/&lt;method-name&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"http-应答编码\">HTTP 应答编码</h4>\n<p>当一个服务通过 Dapr 调用另一个服务时，被调用的服务状态码会返回给调用方。如果有网络错误或者其它瞬态错误， Dapr 将会返回 <code>500</code> 错误并带着详细错误信息。</p>\n<p>如果用户通过HTTP调用Dapr来与启用了gRPC的服务对话，被调用的 gRPC 服务错误返回 <code>500</code> ，成功返回 <code>200OK</code>。</p>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>500</td>\n<td>请求失败</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"url-参数\">URL 参数</h4>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody></tbody>\n</table>\n<p>daprPort｜Dapr 端口<br>\nappId｜远程应用程序 ID<br>\nmethod-name｜调用远程应用程序的方法名称或者 url</p>\n<h4 id=\"请求内容\">请求内容</h4>\n<p>在请求中，你可以传递请求头：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"Content-Type\"</span>: <span class=\"string\">\"application/json\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在请求消息体中放置你想发送到服务的数据：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"arg1\"</span>: <span class=\"number\">10</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"arg2\"</span>: <span class=\"number\">23</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"operator\"</span>: <span class=\"string\">\"+\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"通过调用服务接收请求\">通过调用服务接收请求</h4>\n<p>一旦你的服务代码通过 Dapr 调用另一个服务启用的方法，Dapr 将会发送请求（伴随着请求头和消息体）到应用的 <code>&lt;method-name&gt;</code> 终端。</p>\n<p>被调用的 Dapr 应用程序监听并且在那个终端应答请求。</p>\n<h4 id=\"跨命名空间调用\">跨命名空间调用</h4>\n<p>在支持命名空间的托管平台，Dapr 应用程序 ID 遵循有效的 FQDN（Fully Qualified Domain Name，全限定域名）转换，包含目标命名空间。例如，以下字符串包含应用程序 ID（myApp），此外应用程序运行的命名空间（production）。</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myApp.production</span><br></pre></td></tr></table></figure>\n<p>支持命名空间平台</p>\n<ul>\n<li>K8S</li>\n</ul>\n<h4 id=\"示例\">示例</h4>\n<p>调用 <code>mathService</code> 中的 <code>add</code> 方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http://localhost:3500/v1.0/invoke/mathService/method/add \\</span><br><span class=\"line\">  -H &quot;Content-Type: application/json&quot;</span><br><span class=\"line\">  -d &apos;&#123; &quot;arg1&quot;: 10, &quot;arg2&quot;: 23&#125;&apos;</span><br></pre></td></tr></table></figure>\n<p><code>mathService</code> 服务需要监听 <code>/add</code> 终端以接收和处理请求。</p>\n<p>Node 应用程序像这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.post(&apos;/add&apos;, (req, res) =&gt; &#123;</span><br><span class=\"line\">  let args = req.body;</span><br><span class=\"line\">  const [operandOne, operandTwo] = [Number(args[&apos;arg1&apos;]), Number(args[&apos;arg2&apos;])];</span><br><span class=\"line\">  </span><br><span class=\"line\">  let result = operandOne + operandTwo;</span><br><span class=\"line\">  res.send(result.toString());</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(port, () =&gt; console.log(`Listening on port $&#123;port&#125;!`));</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>远程终端应答将在应答消息体中返回。</p>\n</blockquote>\n<p>如果你的服务监听路径嵌套较多（比如：<code>/api/v1/add</code>），Dapr 实现了完整的反向代理，所以你可以追加所有需要的路径分段到你的请求 URL 里，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost:3500/v1.0/invoke/mathService/method/api/v1/add</span><br></pre></td></tr></table></figure>\n<p>如果你调用的 <code>mathService</code> 在不同的命名空间中，你可以使用下列 URL：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost:3500/v1.0/invoke/mathService.testing/method/api/v1/add</span><br></pre></td></tr></table></figure>\n<p>在这个 URL 中，<code>testing</code> 是 <code>mathService</code> 运行的命名空间。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>服务调用 API 规范</h2>\n<hr>\n<p>Dapr 给用户提供使用唯一 ID 调用其它应用程序的能力。这个功能允许应用程序通过名称标识符和其它应用程序交互，把服务发现的重担交给 Dapr 运行时。</p>\n<h3>内容</h3>\n<ul>\n<li>在远程 Dapr 应用程序上调用一个方法</li>\n</ul>\n<h3>在远程 Dapr 应用程序上调用一个方法</h3>\n<hr>\n<p>这个终端使你能够调用另一个 Dapr 应用程序启用的方法。</p>\n<h4>HTTP 请求</h4>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST/GET/PUT/DELETE http://localhost:&lt;daprPort&gt;/v1.<span class=\"number\">0</span>/invoke/&lt;appId&gt;/method/&lt;method-name&gt;</span><br></pre></td></tr></table></figure>\n<h4>HTTP 应答编码</h4>\n<p>当一个服务通过 Dapr 调用另一个服务时，被调用的服务状态码会返回给调用方。如果有网络错误或者其它瞬态错误， Dapr 将会返回 <code>500</code> 错误并带着详细错误信息。</p>\n<p>如果用户通过HTTP调用Dapr来与启用了gRPC的服务对话，被调用的 gRPC 服务错误返回 <code>500</code> ，成功返回 <code>200OK</code>。</p>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>500</td>\n<td>请求失败</td>\n</tr>\n</tbody>\n</table>\n<h4>URL 参数</h4>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody></tbody>\n</table>\n<p>daprPort｜Dapr 端口<br>\nappId｜远程应用程序 ID<br>\nmethod-name｜调用远程应用程序的方法名称或者 url</p>\n<h4>请求内容</h4>\n<p>在请求中，你可以传递请求头：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"Content-Type\"</span>: <span class=\"string\">\"application/json\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在请求消息体中放置你想发送到服务的数据：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"arg1\"</span>: <span class=\"number\">10</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"arg2\"</span>: <span class=\"number\">23</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"operator\"</span>: <span class=\"string\">\"+\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4>通过调用服务接收请求</h4>\n<p>一旦你的服务代码通过 Dapr 调用另一个服务启用的方法，Dapr 将会发送请求（伴随着请求头和消息体）到应用的 <code>&lt;method-name&gt;</code> 终端。</p>\n<p>被调用的 Dapr 应用程序监听并且在那个终端应答请求。</p>\n<h4>跨命名空间调用</h4>\n<p>在支持命名空间的托管平台，Dapr 应用程序 ID 遵循有效的 FQDN（Fully Qualified Domain Name，全限定域名）转换，包含目标命名空间。例如，以下字符串包含应用程序 ID（myApp），此外应用程序运行的命名空间（production）。</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myApp.production</span><br></pre></td></tr></table></figure>\n<p>支持命名空间平台</p>\n<ul>\n<li>K8S</li>\n</ul>\n<h4>示例</h4>\n<p>调用 <code>mathService</code> 中的 <code>add</code> 方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http://localhost:3500/v1.0/invoke/mathService/method/add \\</span><br><span class=\"line\">  -H &quot;Content-Type: application/json&quot;</span><br><span class=\"line\">  -d &apos;&#123; &quot;arg1&quot;: 10, &quot;arg2&quot;: 23&#125;&apos;</span><br></pre></td></tr></table></figure>\n<p><code>mathService</code> 服务需要监听 <code>/add</code> 终端以接收和处理请求。</p>\n<p>Node 应用程序像这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.post(&apos;/add&apos;, (req, res) =&gt; &#123;</span><br><span class=\"line\">  let args = req.body;</span><br><span class=\"line\">  const [operandOne, operandTwo] = [Number(args[&apos;arg1&apos;]), Number(args[&apos;arg2&apos;])];</span><br><span class=\"line\">  </span><br><span class=\"line\">  let result = operandOne + operandTwo;</span><br><span class=\"line\">  res.send(result.toString());</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(port, () =&gt; console.log(`Listening on port $&#123;port&#125;!`));</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>远程终端应答将在应答消息体中返回。</p>\n</blockquote>\n<p>如果你的服务监听路径嵌套较多（比如：<code>/api/v1/add</code>），Dapr 实现了完整的反向代理，所以你可以追加所有需要的路径分段到你的请求 URL 里，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost:3500/v1.0/invoke/mathService/method/api/v1/add</span><br></pre></td></tr></table></figure>\n<p>如果你调用的 <code>mathService</code> 在不同的命名空间中，你可以使用下列 URL：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost:3500/v1.0/invoke/mathService.testing/method/api/v1/add</span><br></pre></td></tr></table></figure>\n<p>在这个 URL 中，<code>testing</code> 是 <code>mathService</code> 运行的命名空间。</p>\n"},{"title":"服务调用","catalog":true,"toc_nav_num":true,"date":"2020-09-15T11:49:52.000Z","subtitle":"docs/concepts/service-invocation/","header-img":"/img/dapr/dapr.svg","catagories":["Dapr"],"_content":"\n## 服务调用\n\n[Service Invocation](https://github.com/dapr/docs/tree/master/concepts/service-invocation)\n\n---\n\n使用服务调用 API,你的微服务可以找到其它微服务，并且在你的系统中使用标准协议（当前支持 gRPC 或者 HTTP）进行可靠通讯。\n\n以下是一个 Dapr 服务调用如何工作的高度概述。\n\n![](/img/dapr/service-invocation.png)\n\n1. 服务 A 对服务 B 发起一个 http/gRPC 请求。请求进入到本地 Dapr 边车。\n2. Dapr 发现服务 B 的尾制并且转发消息到服务 B 的 Dapr 边车。\n3. 服务 B 的 Dapr 边车转发请求到服务 B 。服务 B 执行它的业务逻辑响应。\n4. 服务 B 发送一个响应到服务 A 。这个响应进入到服务 B 的边车。\n5. Dapr 转发响应到服务 A 的 Dapr 边车。\n6. 服务 A 接收响应。\n\n作为上面的内容描述的例子，假设我们有以下示例描述的应用程序集合，一个 python 应用程序调用一个 Noed.js 应用程序：https://github.com/dapr/quickstarts/blob/master/hello-kubernetes/README.md\n\n在这样的情景下，python 应用程序作为上面提到的“服务 A”，Node.js 应用程序作为\"服务 B\"。\n\n在例子的上下文中，以下1-6项再一次描述：\n\n1. 假设 Node.js 应用程序有一个 Dapr 应用程序 id “nodeapp”，如示例所示。python 应用程序通过 http://localhost:3500/v1.0/invoke/nodeapp/method/neworder 调用 Node.js 应用程序的 neworder 方法，它首先进入 python 应用程序的本地 Dapr 边车。\n2. Dapr 发现 Node.js 应用程序的位置并且转发请求到 Node.js 应用程序的边车。\n3. Node.js 应用程序的边车转发请求到 Node.js 应用程序。Node.js 应用程序执行它的业务逻辑（就像在示例中描述的一样）记录进入的消息然后持久化订单 ID 到 Redis 中（上面的图中未显示）。\n\n第 4-5 步和上面列表一样。\n\n## 下一步\n\n---\n\n如果你已经准备好开始了，跟着这个指引概述[如何开始一个服务调用]()\n\n如果你想要知道更多关于服务调用如何工作的技术细节，异步到[API 规范]()\n\n","source":"_posts/service-invocation.md","raw":"---\ntitle: 服务调用\ncatalog: true\ntoc_nav_num: true\ndate: 2020-09-15 19:49:52\nsubtitle: docs/concepts/service-invocation/\nheader-img: /img/dapr/dapr.svg\ntags:\n- Dapr\n- 原文翻译\ncatagories:\n- Dapr\n---\n\n## 服务调用\n\n[Service Invocation](https://github.com/dapr/docs/tree/master/concepts/service-invocation)\n\n---\n\n使用服务调用 API,你的微服务可以找到其它微服务，并且在你的系统中使用标准协议（当前支持 gRPC 或者 HTTP）进行可靠通讯。\n\n以下是一个 Dapr 服务调用如何工作的高度概述。\n\n![](/img/dapr/service-invocation.png)\n\n1. 服务 A 对服务 B 发起一个 http/gRPC 请求。请求进入到本地 Dapr 边车。\n2. Dapr 发现服务 B 的尾制并且转发消息到服务 B 的 Dapr 边车。\n3. 服务 B 的 Dapr 边车转发请求到服务 B 。服务 B 执行它的业务逻辑响应。\n4. 服务 B 发送一个响应到服务 A 。这个响应进入到服务 B 的边车。\n5. Dapr 转发响应到服务 A 的 Dapr 边车。\n6. 服务 A 接收响应。\n\n作为上面的内容描述的例子，假设我们有以下示例描述的应用程序集合，一个 python 应用程序调用一个 Noed.js 应用程序：https://github.com/dapr/quickstarts/blob/master/hello-kubernetes/README.md\n\n在这样的情景下，python 应用程序作为上面提到的“服务 A”，Node.js 应用程序作为\"服务 B\"。\n\n在例子的上下文中，以下1-6项再一次描述：\n\n1. 假设 Node.js 应用程序有一个 Dapr 应用程序 id “nodeapp”，如示例所示。python 应用程序通过 http://localhost:3500/v1.0/invoke/nodeapp/method/neworder 调用 Node.js 应用程序的 neworder 方法，它首先进入 python 应用程序的本地 Dapr 边车。\n2. Dapr 发现 Node.js 应用程序的位置并且转发请求到 Node.js 应用程序的边车。\n3. Node.js 应用程序的边车转发请求到 Node.js 应用程序。Node.js 应用程序执行它的业务逻辑（就像在示例中描述的一样）记录进入的消息然后持久化订单 ID 到 Redis 中（上面的图中未显示）。\n\n第 4-5 步和上面列表一样。\n\n## 下一步\n\n---\n\n如果你已经准备好开始了，跟着这个指引概述[如何开始一个服务调用]()\n\n如果你想要知道更多关于服务调用如何工作的技术细节，异步到[API 规范]()\n\n","slug":"service-invocation","published":1,"updated":"2020-09-16T00:55:52.635Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckf6kqn5c0009du98br4rtca9","content":"<h2 id=\"服务调用\">服务调用</h2>\n<p><a href=\"https://github.com/dapr/docs/tree/master/concepts/service-invocation\" target=\"_blank\" rel=\"noopener\">Service Invocation</a></p>\n<hr>\n<p>使用服务调用 API,你的微服务可以找到其它微服务，并且在你的系统中使用标准协议（当前支持 gRPC 或者 HTTP）进行可靠通讯。</p>\n<p>以下是一个 Dapr 服务调用如何工作的高度概述。</p>\n<p><img src=\"/img/dapr/service-invocation.png\" alt=\"\"></p>\n<ol>\n<li>服务 A 对服务 B 发起一个 http/gRPC 请求。请求进入到本地 Dapr 边车。</li>\n<li>Dapr 发现服务 B 的尾制并且转发消息到服务 B 的 Dapr 边车。</li>\n<li>服务 B 的 Dapr 边车转发请求到服务 B 。服务 B 执行它的业务逻辑响应。</li>\n<li>服务 B 发送一个响应到服务 A 。这个响应进入到服务 B 的边车。</li>\n<li>Dapr 转发响应到服务 A 的 Dapr 边车。</li>\n<li>服务 A 接收响应。</li>\n</ol>\n<p>作为上面的内容描述的例子，假设我们有以下示例描述的应用程序集合，一个 python 应用程序调用一个 Noed.js 应用程序：<a href=\"https://github.com/dapr/quickstarts/blob/master/hello-kubernetes/README.md\" target=\"_blank\" rel=\"noopener\">https://github.com/dapr/quickstarts/blob/master/hello-kubernetes/README.md</a></p>\n<p>在这样的情景下，python 应用程序作为上面提到的“服务 A”，Node.js 应用程序作为&quot;服务 B&quot;。</p>\n<p>在例子的上下文中，以下1-6项再一次描述：</p>\n<ol>\n<li>假设 Node.js 应用程序有一个 Dapr 应用程序 id “nodeapp”，如示例所示。python 应用程序通过 <a href=\"http://localhost:3500/v1.0/invoke/nodeapp/method/neworder\" target=\"_blank\" rel=\"noopener\">http://localhost:3500/v1.0/invoke/nodeapp/method/neworder</a> 调用 Node.js 应用程序的 neworder 方法，它首先进入 python 应用程序的本地 Dapr 边车。</li>\n<li>Dapr 发现 Node.js 应用程序的位置并且转发请求到 Node.js 应用程序的边车。</li>\n<li>Node.js 应用程序的边车转发请求到 Node.js 应用程序。Node.js 应用程序执行它的业务逻辑（就像在示例中描述的一样）记录进入的消息然后持久化订单 ID 到 Redis 中（上面的图中未显示）。</li>\n</ol>\n<p>第 4-5 步和上面列表一样。</p>\n<h2 id=\"下一步\">下一步</h2>\n<hr>\n<p>如果你已经准备好开始了，跟着这个指引概述<a href=\"\">如何开始一个服务调用</a></p>\n<p>如果你想要知道更多关于服务调用如何工作的技术细节，异步到<a href=\"\">API 规范</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2>服务调用</h2>\n<p><a href=\"https://github.com/dapr/docs/tree/master/concepts/service-invocation\" target=\"_blank\" rel=\"noopener\">Service Invocation</a></p>\n<hr>\n<p>使用服务调用 API,你的微服务可以找到其它微服务，并且在你的系统中使用标准协议（当前支持 gRPC 或者 HTTP）进行可靠通讯。</p>\n<p>以下是一个 Dapr 服务调用如何工作的高度概述。</p>\n<p><img src=\"/img/dapr/service-invocation.png\" alt=\"\"></p>\n<ol>\n<li>服务 A 对服务 B 发起一个 http/gRPC 请求。请求进入到本地 Dapr 边车。</li>\n<li>Dapr 发现服务 B 的尾制并且转发消息到服务 B 的 Dapr 边车。</li>\n<li>服务 B 的 Dapr 边车转发请求到服务 B 。服务 B 执行它的业务逻辑响应。</li>\n<li>服务 B 发送一个响应到服务 A 。这个响应进入到服务 B 的边车。</li>\n<li>Dapr 转发响应到服务 A 的 Dapr 边车。</li>\n<li>服务 A 接收响应。</li>\n</ol>\n<p>作为上面的内容描述的例子，假设我们有以下示例描述的应用程序集合，一个 python 应用程序调用一个 Noed.js 应用程序：<a href=\"https://github.com/dapr/quickstarts/blob/master/hello-kubernetes/README.md\" target=\"_blank\" rel=\"noopener\">https://github.com/dapr/quickstarts/blob/master/hello-kubernetes/README.md</a></p>\n<p>在这样的情景下，python 应用程序作为上面提到的“服务 A”，Node.js 应用程序作为&quot;服务 B&quot;。</p>\n<p>在例子的上下文中，以下1-6项再一次描述：</p>\n<ol>\n<li>假设 Node.js 应用程序有一个 Dapr 应用程序 id “nodeapp”，如示例所示。python 应用程序通过 <a href=\"http://localhost:3500/v1.0/invoke/nodeapp/method/neworder\" target=\"_blank\" rel=\"noopener\">http://localhost:3500/v1.0/invoke/nodeapp/method/neworder</a> 调用 Node.js 应用程序的 neworder 方法，它首先进入 python 应用程序的本地 Dapr 边车。</li>\n<li>Dapr 发现 Node.js 应用程序的位置并且转发请求到 Node.js 应用程序的边车。</li>\n<li>Node.js 应用程序的边车转发请求到 Node.js 应用程序。Node.js 应用程序执行它的业务逻辑（就像在示例中描述的一样）记录进入的消息然后持久化订单 ID 到 Redis 中（上面的图中未显示）。</li>\n</ol>\n<p>第 4-5 步和上面列表一样。</p>\n<h2>下一步</h2>\n<hr>\n<p>如果你已经准备好开始了，跟着这个指引概述<a href=\"\">如何开始一个服务调用</a></p>\n<p>如果你想要知道更多关于服务调用如何工作的技术细节，异步到<a href=\"\">API 规范</a></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckf6kqn5a0008du98dxk1bhyx","tag_id":"ckf6kqn530003du989uo8eywk","_id":"ckf6kqn5f000bdu984zkola5a"},{"post_id":"ckf6kqn5a0008du98dxk1bhyx","tag_id":"ckf6kqn590007du9820yicaxh","_id":"ckf6kqn5f000cdu98je9llm2n"},{"post_id":"ckf6kqn4y0001du98s1ltkl79","tag_id":"ckf6kqn530003du989uo8eywk","_id":"ckf6kqn5g000edu98smgymgb1"},{"post_id":"ckf6kqn4y0001du98s1ltkl79","tag_id":"ckf6kqn590007du9820yicaxh","_id":"ckf6kqn5g000fdu98yujcpn9p"},{"post_id":"ckf6kqn5c0009du98br4rtca9","tag_id":"ckf6kqn530003du989uo8eywk","_id":"ckf6kqn5h000hdu984i7z96sq"},{"post_id":"ckf6kqn5c0009du98br4rtca9","tag_id":"ckf6kqn590007du9820yicaxh","_id":"ckf6kqn5h000idu98kub2oh1p"},{"post_id":"ckf6kqn510002du982l5tf5ho","tag_id":"ckf6kqn530003du989uo8eywk","_id":"ckf6kqn5i000kdu98092x7vr6"},{"post_id":"ckf6kqn510002du982l5tf5ho","tag_id":"ckf6kqn590007du9820yicaxh","_id":"ckf6kqn5i000ldu982wgpablw"},{"post_id":"ckf6kqn550004du989jpxuydz","tag_id":"ckf6kqn530003du989uo8eywk","_id":"ckf6kqn5i000ndu98dj4vr4g6"},{"post_id":"ckf6kqn550004du989jpxuydz","tag_id":"ckf6kqn590007du9820yicaxh","_id":"ckf6kqn5i000odu98y8evlon8"},{"post_id":"ckf6kqn570005du98qpgz9css","tag_id":"ckf6kqn530003du989uo8eywk","_id":"ckf6kqn5j000qdu98oaqgjb75"},{"post_id":"ckf6kqn570005du98qpgz9css","tag_id":"ckf6kqn590007du9820yicaxh","_id":"ckf6kqn5j000rdu98s9teiegz"},{"post_id":"ckf6kqn580006du9869dn0pvy","tag_id":"ckf6kqn530003du989uo8eywk","_id":"ckf6kqn5j000sdu98k109j6me"},{"post_id":"ckf6kqn580006du9869dn0pvy","tag_id":"ckf6kqn590007du9820yicaxh","_id":"ckf6kqn5j000tdu98e2hhpvvh"}],"Tag":[{"name":"Dapr","_id":"ckf6kqn530003du989uo8eywk"},{"name":"原文翻译","_id":"ckf6kqn590007du9820yicaxh"}]}}